\input webmac
% This program by D. E. Knuth is not copyrighted and can be used freely.
% Version 0 was released in December, 1981.
% Version 1 was released in September, 1982, with version 0 of TeX.
% Slight changes were made in October, 1982, for version 0.6 of TeX.
% Version 1.1 changed "_" to "\_" if not within an identifier (November, 1982).
% Version 1.2 added @= and @\ and marked changed modules (December, 1982).
% Version 1.3 marked and indexed changed modules better (January, 1983).
% Version 1.4 added "history" (February, 1983).
% Version 1.5 conformed to TeX version 0.96 (March, 1983).
% Version 1.6 conformed to TeX version 0.98 (May, 1983).
% Version 1.7 introduced the new change file format (June, 1983).
% Version 2 was released in July, 1983, with version 0.999 of TeX.
% Version 2.1 corrected a bug in changed_module reckoning (August, 1983).
% Version 2.2 corrected it better (August, 1983).
% Version 2.3 starts the output with \input webmac (August, 1983).
% Version 2.4 fixed a bug in compress(#) (September, 1983).
% Version 2.5 cleared xrefswitch after module names (November, 1983).
% Version 2.6 fixed a bug in declaration of trans array (January, 1984).
% Version 2.7 fixed a bug in real constants (August, 1984).
% Version 2.8 fixed a bug in change_buffer movement (August, 1985).
% Version 2.9 increased max_refs and max_toks to 30000 each (January, 1987).
% Version 3, for Sewell's book, fixed long-line bug in input_ln (March, 1989).
% Version 3.1 fixed a bug for programs with only one module (April, 1989).
% Version 4 was major change to allow 8-bit input (September, 1989).
% Version 4.1, for Breitenlohner, avoids English-only output (March, 1990).
% Version 4.2 conforms to ANSI standard for-loop rules (September, 1990).
% Version 4.3 catches extra } in input (Breitenlohner, September, 1991).
% Version 4.4 corrects changed_module logic, %-overflow (January, 1992).

% Here is TeX material that gets inserted after \input webmac
\def\hang{\hangindent 3em\indent\ignorespaces}
\font\ninerm=cmr9
\let\mc=\ninerm % medium caps for names like SAIL
\def\PASCAL{Pascal}
\def\pb{$\.|\ldots\.|$} % Pascal brackets (|...|)
\def\v{\.{\char'174}} % vertical (|) in typewriter font
\def\dleft{[\![} \def\dright{]\!]} % double brackets
\mathchardef\RA="3221 % right arrow
\mathchardef\BA="3224 % double arrow
\def\({} % kludge for alphabetizing certain module names

\def\title{WEAVE}
\def\contentspagenumber{15} % should be odd
\def\topofcontents{\null\vfill
  \titlefalse % include headline on the contents page
  \def\rheader{\mainfont Appendix D\hfil \contentspagenumber}
  \centerline{\titlefont The {\ttitlefont WEAVE} processor}
  \vskip 15pt
  \centerline{(Version 4.4)}
  \vfill}
\pageno=\contentspagenumber \advance\pageno by 1


\N1.  Introduction.
This program converts a \.{WEB} file to a \TeX\ file. It was written
by D. E. Knuth in October, 1981; a somewhat similar {\mc SAIL} program had
been developed in March, 1979, although the earlier program used a top-down
parsing method that is quite different from the present scheme.

The code uses a few features of the local \PASCAL\ compiler that may need
to be changed in other installations:

\yskip\item{1)} Case statements have a default.
\item{2)} Input-output routines may need to be adapted for use with a
particular
character set and/or for printing messages on the user's terminal.

\yskip\noindent
These features are also present in the \PASCAL\ version of \TeX, where they
are used in a similar (but more complex) way. System-dependent portions
of \.{WEAVE} can be identified by looking at the entries for `system
dependencies' in the index below.

The ``banner line'' defined here should be changed whenever \.{WEAVE}
is modified.

\Y\P\D \37$\\{banner}\S\.{\'This\ is\ WEAVE,\ Version\ 4.4\'}$\par
\fi

\M2. The program begins with a fairly normal header, made up of pieces that
will mostly be filled in later. The \.{WEB} input comes from files \\{web%
\_file}
and \\{change\_file}, and the \TeX\ output goes to file \\{tex\_file}.

If it is necessary to abort the job because of a fatal error, the program
calls the `\\{jump\_out}' procedure, which goes to the label \\{end\_of%
\_WEAVE}.

\Y\P\D \37$\\{end\_of\_WEAVE}=9999$\C{go here to wrap it up}\par
\Y\P\hbox{\4}\X4:Compiler directives\X\6
\4\&{program}\1\  \37$\\{WEAVE}(\\{web\_file},\39\\{change\_file},\39\\{tex%
\_file})$;\6
\4\&{label} \37\\{end\_of\_WEAVE};\C{go here to finish}\6
\4\&{const} \37\X8:Constants in the outer block\X\6
\4\&{type} \37\X11:Types in the outer block\X\6
\4\&{var} \37\X9:Globals in the outer block\X\6
\X30:Error handling procedures\X\6
\4\&{procedure}\1\  \37\\{initialize};\6
\4\&{var} \37\X16:Local variables for initialization\X\2\6
\&{begin} \37\X10:Set initial values\X\6
\&{end};\par
\fi

\M3. Some of this code is optional for use when debugging only;
such material is enclosed between the delimiters  \&{debug}  and $  \&{gubed}
$.
Other parts, delimited by  \&{stat}  and $  \&{tats} $, are optionally included
if statistics about \.{WEAVE}'s memory usage are desired.

\Y\P\D \37$\\{debug}\S\B$\C{change this to `$\\{debug}\equiv\null$' when
debugging}\par
\P\D \37$\\{gubed}\S\hbox{}\T$\C{change this to `$\\{gubed}\equiv\null$' when
debugging}\par
\P\F \37$\\{debug}\S\\{begin}$\par
\P\F \37$\\{gubed}\S\\{end}$\Y\par
\P\D \37$\\{stat}\S\B$\C{change this to `$\\{stat}\equiv\null$'   when
gathering usage statistics}\par
\P\D \37$\\{tats}\S\hbox{}\T$\C{change this to `$\\{tats}\equiv\null$'   when
gathering usage statistics}\par
\P\F \37$\\{stat}\S\\{begin}$\par
\P\F \37$\\{tats}\S\\{end}$\par
\fi

\M4. The \PASCAL\ compiler used to develop this system has ``compiler
directives'' that can appear in comments whose first character is a dollar
sign.
In production versions of \.{WEAVE} these directives tell the compiler that
it is safe to avoid range checks and to leave out the extra code it inserts
for the \PASCAL\ debugger's benefit, although interrupts will occur if
there is arithmetic overflow.

\Y\P$\4\X4:Compiler directives\X\S$\6
$\B\J\$\|C-,\39\|A+,\39\|D-\T$\C{no range check, catch arithmetic overflow, no
debug overhead}\6
\&{debug} \37$\B\J\$\|C+,\39\|D+\T$\ \&{gubed}\C{but turn everything on when
debugging}\par
\U2.\fi

\M5. Labels are given symbolic names by the following definitions. We insert
the label `\\{exit}:' just before the `\ignorespaces  \&{end} \unskip' of a
procedure in which we have used the `\&{return}' statement defined below;
the label `\\{restart}' is occasionally used at the very beginning of a
procedure; and the label `\\{reswitch}' is occasionally used just prior to
a \&{case} statement in which some cases change the conditions and we wish to
branch to the newly applicable case.
Loops that are set up with the \&{loop} construction defined below are
commonly exited by going to `\\{done}' or to `\\{found}' or to `\\{not%
\_found}',
and they are sometimes repeated by going to `\\{continue}'.

\Y\P\D \37$\\{exit}=10$\C{go here to leave a procedure}\par
\P\D \37$\\{restart}=20$\C{go here to start a procedure again}\par
\P\D \37$\\{reswitch}=21$\C{go here to start a case statement again}\par
\P\D \37$\\{continue}=22$\C{go here to resume a loop}\par
\P\D \37$\\{done}=30$\C{go here to exit a loop}\par
\P\D \37$\\{found}=31$\C{go here when you've found it}\par
\P\D \37$\\{not\_found}=32$\C{go here when you've found something else}\par
\fi

\M6. Here are some macros for common programming idioms.

\Y\P\D \37$\\{incr}(\#)\S\#\K\#+1$\C{increase a variable by unity}\par
\P\D \37$\\{decr}(\#)\S\#\K\#-1$\C{decrease a variable by unity}\par
\P\D \37$\\{loop}\S$\ \&{while} $\\{true}$ \1\&{do}\ \C{repeat over and over
until a \&{goto}  happens}\par
\P\D \37$\\{do\_nothing}\S$\C{empty statement}\par
\P\D \37$\\{return}\S$\1\5
\&{goto} \37\\{exit}\C{terminate a procedure call}\2\par
\P\F \37$\\{return}\S\\{nil}$\par
\P\F \37$\\{loop}\S\\{xclause}$\par
\fi

\M7. We assume that   \&{case}  statements may include a default case that
applies
if no matching label is found. Thus, we shall use constructions like
$$\vbox{\halign{#\hfil\cr
 \&{case} $\|x$ \&{of}\cr
1: $\langle\,$code for $x=1\,\rangle$;\cr
3: $\langle\,$code for $x=3\,\rangle$;\cr
 \&{othercases}  $\langle\,$code for $\|x\I1$ and $\|x\I3$$\,\rangle$\cr
  \&{endcases} \cr}}$$
since most \PASCAL\ compilers have plugged this hole in the language by
incorporating some sort of default mechanism. For example, the compiler
used to develop \.{WEB} and \TeX\ allows `\\{others}:' as a default label,
and other \PASCAL s allow syntaxes like `\ignorespaces \&{else} \unskip' or
`\&{otherwise}' or `\\{otherwise}:', etc. The definitions of  \&{othercases}
and   \&{endcases}  should be changed to agree with local conventions.
(Of course, if no default mechanism is available, the   \&{case}  statements of
this program must be extended by listing all remaining cases.)

\Y\P\D \37$\\{othercases}\S\\{others}$: \37\C{default for cases not listed
explicitly}\par
\P\D \37$\\{endcases}\S$\ \&{end} \C{follows the default case in an extended   %
\&{case}  statement}\par
\P\F \37$\\{othercases}\S\\{else}$\par
\P\F \37$\\{endcases}\S\\{end}$\par
\fi

\M8. The following parameters are set big enough to handle \TeX, so they
should be sufficient for most applications of \.{WEAVE}.

\Y\P$\4\X8:Constants in the outer block\X\S$\6
$\\{max\_bytes}=45000$;\C{$1/\\{ww}$ times the number of bytes in identifiers,
 index entries, and module names; must be less than 65536}\6
$\\{max\_names}=5000$;\C{number of identifiers, index entries, and module
names;   must be less than 10240}\6
$\\{max\_modules}=2000$;\C{greater than the total number of modules}\6
$\\{hash\_size}=353$;\C{should be prime}\6
$\\{buf\_size}=100$;\C{maximum length of input line}\6
$\\{longest\_name}=400$;\C{module names shouldn't be longer than this}\6
$\\{long\_buf\_size}=500$;\C{$\\{buf\_size}+\\{longest\_name}$}\6
$\\{line\_length}=80$;\C{lines of \TeX\ output have at most this many
characters,   should be less than 256}\6
$\\{max\_refs}=30000$;\C{number of cross references; must be less than 65536}\6
$\\{max\_toks}=30000$;\C{number of symbols in \PASCAL\ texts being parsed;
must be less than 65536}\6
$\\{max\_texts}=2000$;\C{number of phrases in \PASCAL\ texts being parsed;
must be less than 10240}\6
$\\{max\_scraps}=1000$;\C{number of tokens in \PASCAL\ texts being parsed}\6
$\\{stack\_size}=200$;\C{number of simultaneous output levels}\par
\U2.\fi

\M9. A global variable called \\{history} will contain one of four values
at the end of every run: \\{spotless} means that no unusual messages were
printed; \\{harmless\_message} means that a message of possible interest
was printed but no serious errors were detected; \\{error\_message} means that
at least one error was found; \\{fatal\_message} means that the program
terminated abnormally. The value of \\{history} does not influence the
behavior of the program; it is simply computed for the convenience
of systems that might want to use such information.

\Y\P\D \37$\\{spotless}=0$\C{\\{history} value for normal jobs}\par
\P\D \37$\\{harmless\_message}=1$\C{\\{history} value when non-serious info was
printed}\par
\P\D \37$\\{error\_message}=2$\C{\\{history} value when an error was noted}\par
\P\D \37$\\{fatal\_message}=3$\C{\\{history} value when we had to stop
prematurely}\Y\par
\P\D \37$\\{mark\_harmless}\S\hbox{}$\ \&{if} $\\{history}=\\{spotless}$ \1%
\&{then}\5
$\\{history}\K\\{harmless\_message}$\2\par
\P\D \37$\\{mark\_error}\S\\{history}\K\\{error\_message}$\par
\P\D \37$\\{mark\_fatal}\S\\{history}\K\\{fatal\_message}$\par
\Y\P$\4\X9:Globals in the outer block\X\S$\6
\4\\{history}: \37$\\{spotless}\to\\{fatal\_message}$;\C{how bad was this run?}%
\par
\As13, 20, 23, 25, 27, 29, 37, 39, 45, 48, 53, 55, 63, 65, 71, 73, 93, 108,
114, 118, 121, 129, 144, 177, 202, 219, 229, 234, 240, 242, 244, 246\ETs258.
\U2.\fi

\M10. \P$\X10:Set initial values\X\S$\6
$\\{history}\K\\{spotless}$;\par
\As14, 17, 18, 21, 26, 41, 43, 49, 54, 57, 94, 102, 124, 126, 145, 203, 245,
248\ETs259.
\U2.\fi

\N11.  The character set.
One of the main goals in the design of \.{WEB} has been to make it readily
portable between a wide variety of computers. Yet \.{WEB} by its very
nature must use a greater variety of characters than most computer
programs deal with, and character encoding is one of the areas in which
existing machines differ most widely from each other.

To resolve this problem, all input to \.{WEAVE} and \.{TANGLE} is
converted to an internal eight-bit code that is essentially standard
ASCII, the ``American Standard Code for Information Interchange.''
The conversion is done immediately when each character is read in.
Conversely, characters are converted from ASCII to the user's external
representation just before they are output. (The original ASCII code
was seven bits only; \.{WEB} now allows eight bits in an attempt to
keep up with modern times.)

Such an internal code is relevant to users of \.{WEB} only because it is
the code used for preprocessed constants like \.{"A"}. If you are writing
a program in \.{WEB} that makes use of such one-character constants, you
should convert your input to ASCII form, like \.{WEAVE} and \.{TANGLE} do.
Otherwise \.{WEB}'s internal coding scheme does not affect you.

Here is a table of the standard visible ASCII codes:
$$\def\:{\char\count255\global\advance\count255 by 1}
\count255='40
\vbox{
\hbox{\hbox to 40pt{\it\hfill0\/\hfill}%
\hbox to 40pt{\it\hfill1\/\hfill}%
\hbox to 40pt{\it\hfill2\/\hfill}%
\hbox to 40pt{\it\hfill3\/\hfill}%
\hbox to 40pt{\it\hfill4\/\hfill}%
\hbox to 40pt{\it\hfill5\/\hfill}%
\hbox to 40pt{\it\hfill6\/\hfill}%
\hbox to 40pt{\it\hfill7\/\hfill}}
\vskip 4pt
\hrule
\def\^{\vrule height 10.5pt depth 4.5pt}
\halign{\hbox to 0pt{\hskip -24pt\O{#0}\hfill}&\^
\hbox to 40pt{\tt\hfill#\hfill\^}&
&\hbox to 40pt{\tt\hfill#\hfill\^}\cr
04&\:&\:&\:&\:&\:&\:&\:&\:\cr\noalign{\hrule}
05&\:&\:&\:&\:&\:&\:&\:&\:\cr\noalign{\hrule}
06&\:&\:&\:&\:&\:&\:&\:&\:\cr\noalign{\hrule}
07&\:&\:&\:&\:&\:&\:&\:&\:\cr\noalign{\hrule}
10&\:&\:&\:&\:&\:&\:&\:&\:\cr\noalign{\hrule}
11&\:&\:&\:&\:&\:&\:&\:&\:\cr\noalign{\hrule}
12&\:&\:&\:&\:&\:&\:&\:&\:\cr\noalign{\hrule}
13&\:&\:&\:&\:&\:&\:&\:&\:\cr\noalign{\hrule}
14&\:&\:&\:&\:&\:&\:&\:&\:\cr\noalign{\hrule}
15&\:&\:&\:&\:&\:&\:&\:&\:\cr\noalign{\hrule}
16&\:&\:&\:&\:&\:&\:&\:&\:\cr\noalign{\hrule}
17&\:&\:&\:&\:&\:&\:&\:\cr}
\hrule width 280pt}$$
(Actually, of course, code \O{040} is an invisible blank space.)  Code \O{136}
was once an upward arrow (\.{\char'13}), and code \O{137} was
once a left arrow (\.^^X), in olden times when the first draft
of ASCII code was prepared; but \.{WEB} works with today's standard
ASCII in which those codes represent circumflex and underline as shown.

\Y\P$\4\X11:Types in the outer block\X\S$\6
$\\{ASCII\_code}=0\to255$;\C{eight-bit numbers, a subrange of the integers}\par
\As12, 36, 38, 47, 52\ETs201.
\U2.\fi

\M12. The original \PASCAL\ compiler was designed in the late 60s, when six-bit
character sets were common, so it did not make provision for lowercase
letters. Nowadays, of course, we need to deal with both capital and small
letters in a convenient way, so \.{WEB} assumes that it is being used
with a \PASCAL\ whose character set contains at least the characters of
standard ASCII as listed above. Some \PASCAL\ compilers use the original
name \\{char} for the data type associated with the characters in text files,
while other \PASCAL s consider \\{char} to be a 64-element subrange of a larger
data type that has some other name.

In order to accommodate this difference, we shall use the name \\{text\_char}
to stand for the data type of the characters in the input and output
files.  We shall also assume that \\{text\_char} consists of the elements
$\\{chr}(\\{first\_text\_char})$ through $\\{chr}(\\{last\_text\_char})$,
inclusive. The
following definitions should be adjusted if necessary.

\Y\P\D \37$\\{text\_char}\S\\{char}$\C{the data type of characters in text
files}\par
\P\D \37$\\{first\_text\_char}=0$\C{ordinal number of the smallest element of %
\\{text\_char}}\par
\P\D \37$\\{last\_text\_char}=255$\C{ordinal number of the largest element of %
\\{text\_char}}\par
\Y\P$\4\X11:Types in the outer block\X\mathrel{+}\S$\6
$\\{text\_file}=$\1\5
\&{packed} \37\&{file} \1\&{of}\5
\\{text\_char};\2\2\par
\fi

\M13. The \.{WEAVE} and \.{TANGLE} processors convert between ASCII code and
the user's external character set by means of arrays \\{xord} and \\{xchr}
that are analogous to \PASCAL's \\{ord} and \\{chr} functions.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{xord}: \37\&{array} $[\\{text\_char}]$ \1\&{of}\5
\\{ASCII\_code};\C{specifies conversion of input characters}\2\6
\4\\{xchr}: \37\&{array} $[\\{ASCII\_code}]$ \1\&{of}\5
\\{text\_char};\C{specifies conversion of output characters}\2\par
\fi

\M14. If we assume that every system using \.{WEB} is able to read and write
the
visible characters of standard ASCII (although not necessarily using the
ASCII codes to represent them), the following assignment statements initialize
most of the \\{xchr} array properly, without needing any system-dependent
changes. For example, the statement \.{xchr[@\'101]:=\'A\'} that appears
in the present \.{WEB} file might be encoded in, say, {\mc EBCDIC} code
on the external medium on which it resides, but \.{TANGLE} will convert from
this external code to ASCII and back again. Therefore the assignment
statement \.{XCHR[65]:=\'A\'} will appear in the corresponding \PASCAL\ file,
and \PASCAL\ will compile this statement so that $\\{xchr}[65]$ receives the
character \.A in the external (\\{char}) code. Note that it would be quite
incorrect to say \.{xchr[@\'101]:="A"}, because \.{"A"} is a constant of
type \\{integer}, not \\{char}, and because we have $\.{"A"}=65$ regardless of
the external character set.

\Y\P$\4\X10:Set initial values\X\mathrel{+}\S$\6
$\\{xchr}[\O{40}]\K\.{\'\ \'}$;\5
$\\{xchr}[\O{41}]\K\.{\'!\'}$;\5
$\\{xchr}[\O{42}]\K\.{\'"\'}$;\5
$\\{xchr}[\O{43}]\K\.{\'\#\'}$;\5
$\\{xchr}[\O{44}]\K\.{\'\$\'}$;\5
$\\{xchr}[\O{45}]\K\.{\'\%\'}$;\5
$\\{xchr}[\O{46}]\K\.{\'\&\'}$;\5
$\\{xchr}[\O{47}]\K\.{\'\'}\.{\'\'}$;\6
$\\{xchr}[\O{50}]\K\.{\'(\'}$;\5
$\\{xchr}[\O{51}]\K\.{\')\'}$;\5
$\\{xchr}[\O{52}]\K\.{\'*\'}$;\5
$\\{xchr}[\O{53}]\K\.{\'+\'}$;\5
$\\{xchr}[\O{54}]\K\.{\',\'}$;\5
$\\{xchr}[\O{55}]\K\.{\'-\'}$;\5
$\\{xchr}[\O{56}]\K\.{\'.\'}$;\5
$\\{xchr}[\O{57}]\K\.{\'/\'}$;\6
$\\{xchr}[\O{60}]\K\.{\'0\'}$;\5
$\\{xchr}[\O{61}]\K\.{\'1\'}$;\5
$\\{xchr}[\O{62}]\K\.{\'2\'}$;\5
$\\{xchr}[\O{63}]\K\.{\'3\'}$;\5
$\\{xchr}[\O{64}]\K\.{\'4\'}$;\5
$\\{xchr}[\O{65}]\K\.{\'5\'}$;\5
$\\{xchr}[\O{66}]\K\.{\'6\'}$;\5
$\\{xchr}[\O{67}]\K\.{\'7\'}$;\6
$\\{xchr}[\O{70}]\K\.{\'8\'}$;\5
$\\{xchr}[\O{71}]\K\.{\'9\'}$;\5
$\\{xchr}[\O{72}]\K\.{\':\'}$;\5
$\\{xchr}[\O{73}]\K\.{\';\'}$;\5
$\\{xchr}[\O{74}]\K\.{\'<\'}$;\5
$\\{xchr}[\O{75}]\K\.{\'=\'}$;\5
$\\{xchr}[\O{76}]\K\.{\'>\'}$;\5
$\\{xchr}[\O{77}]\K\.{\'?\'}$;\6
$\\{xchr}[\O{100}]\K\.{\'@\'}$;\5
$\\{xchr}[\O{101}]\K\.{\'A\'}$;\5
$\\{xchr}[\O{102}]\K\.{\'B\'}$;\5
$\\{xchr}[\O{103}]\K\.{\'C\'}$;\5
$\\{xchr}[\O{104}]\K\.{\'D\'}$;\5
$\\{xchr}[\O{105}]\K\.{\'E\'}$;\5
$\\{xchr}[\O{106}]\K\.{\'F\'}$;\5
$\\{xchr}[\O{107}]\K\.{\'G\'}$;\6
$\\{xchr}[\O{110}]\K\.{\'H\'}$;\5
$\\{xchr}[\O{111}]\K\.{\'I\'}$;\5
$\\{xchr}[\O{112}]\K\.{\'J\'}$;\5
$\\{xchr}[\O{113}]\K\.{\'K\'}$;\5
$\\{xchr}[\O{114}]\K\.{\'L\'}$;\5
$\\{xchr}[\O{115}]\K\.{\'M\'}$;\5
$\\{xchr}[\O{116}]\K\.{\'N\'}$;\5
$\\{xchr}[\O{117}]\K\.{\'O\'}$;\6
$\\{xchr}[\O{120}]\K\.{\'P\'}$;\5
$\\{xchr}[\O{121}]\K\.{\'Q\'}$;\5
$\\{xchr}[\O{122}]\K\.{\'R\'}$;\5
$\\{xchr}[\O{123}]\K\.{\'S\'}$;\5
$\\{xchr}[\O{124}]\K\.{\'T\'}$;\5
$\\{xchr}[\O{125}]\K\.{\'U\'}$;\5
$\\{xchr}[\O{126}]\K\.{\'V\'}$;\5
$\\{xchr}[\O{127}]\K\.{\'W\'}$;\6
$\\{xchr}[\O{130}]\K\.{\'X\'}$;\5
$\\{xchr}[\O{131}]\K\.{\'Y\'}$;\5
$\\{xchr}[\O{132}]\K\.{\'Z\'}$;\5
$\\{xchr}[\O{133}]\K\.{\'[\'}$;\5
$\\{xchr}[\O{134}]\K\.{\'\\\'}$;\5
$\\{xchr}[\O{135}]\K\.{\']\'}$;\5
$\\{xchr}[\O{136}]\K\.{\'\^\'}$;\5
$\\{xchr}[\O{137}]\K\.{\'\_\'}$;\6
$\\{xchr}[\O{140}]\K\.{\'\`\'}$;\5
$\\{xchr}[\O{141}]\K\.{\'a\'}$;\5
$\\{xchr}[\O{142}]\K\.{\'b\'}$;\5
$\\{xchr}[\O{143}]\K\.{\'c\'}$;\5
$\\{xchr}[\O{144}]\K\.{\'d\'}$;\5
$\\{xchr}[\O{145}]\K\.{\'e\'}$;\5
$\\{xchr}[\O{146}]\K\.{\'f\'}$;\5
$\\{xchr}[\O{147}]\K\.{\'g\'}$;\6
$\\{xchr}[\O{150}]\K\.{\'h\'}$;\5
$\\{xchr}[\O{151}]\K\.{\'i\'}$;\5
$\\{xchr}[\O{152}]\K\.{\'j\'}$;\5
$\\{xchr}[\O{153}]\K\.{\'k\'}$;\5
$\\{xchr}[\O{154}]\K\.{\'l\'}$;\5
$\\{xchr}[\O{155}]\K\.{\'m\'}$;\5
$\\{xchr}[\O{156}]\K\.{\'n\'}$;\5
$\\{xchr}[\O{157}]\K\.{\'o\'}$;\6
$\\{xchr}[\O{160}]\K\.{\'p\'}$;\5
$\\{xchr}[\O{161}]\K\.{\'q\'}$;\5
$\\{xchr}[\O{162}]\K\.{\'r\'}$;\5
$\\{xchr}[\O{163}]\K\.{\'s\'}$;\5
$\\{xchr}[\O{164}]\K\.{\'t\'}$;\5
$\\{xchr}[\O{165}]\K\.{\'u\'}$;\5
$\\{xchr}[\O{166}]\K\.{\'v\'}$;\5
$\\{xchr}[\O{167}]\K\.{\'w\'}$;\6
$\\{xchr}[\O{170}]\K\.{\'x\'}$;\5
$\\{xchr}[\O{171}]\K\.{\'y\'}$;\5
$\\{xchr}[\O{172}]\K\.{\'z\'}$;\5
$\\{xchr}[\O{173}]\K\.{\'\{\'}$;\5
$\\{xchr}[\O{174}]\K\.{\'|\'}$;\5
$\\{xchr}[\O{175}]\K\.{\'\}\'}$;\5
$\\{xchr}[\O{176}]\K\.{\'\~\'}$;\6
$\\{xchr}[0]\K\.{\'\ \'}$;\5
$\\{xchr}[\O{177}]\K\.{\'\ \'}$;\C{these ASCII codes are not used}\par
\fi

\M15. Some of the ASCII codes below \O{40} have been given symbolic names in
\.{WEAVE} and \.{TANGLE} because they are used with a special meaning.

\Y\P\D \37$\\{and\_sign}=\O{4}$\C{equivalent to `\.{and}'}\par
\P\D \37$\\{not\_sign}=\O{5}$\C{equivalent to `\.{not}'}\par
\P\D \37$\\{set\_element\_sign}=\O{6}$\C{equivalent to `\.{in}'}\par
\P\D \37$\\{tab\_mark}=\O{11}$\C{ASCII code used as tab-skip}\par
\P\D \37$\\{line\_feed}=\O{12}$\C{ASCII code thrown away at end of line}\par
\P\D \37$\\{form\_feed}=\O{14}$\C{ASCII code used at end of page}\par
\P\D \37$\\{carriage\_return}=\O{15}$\C{ASCII code used at end of line}\par
\P\D \37$\\{left\_arrow}=\O{30}$\C{equivalent to `\.{:=}'}\par
\P\D \37$\\{not\_equal}=\O{32}$\C{equivalent to `\.{<>}'}\par
\P\D \37$\\{less\_or\_equal}=\O{34}$\C{equivalent to `\.{<=}'}\par
\P\D \37$\\{greater\_or\_equal}=\O{35}$\C{equivalent to `\.{>=}'}\par
\P\D \37$\\{equivalence\_sign}=\O{36}$\C{equivalent to `\.{==}'}\par
\P\D \37$\\{or\_sign}=\O{37}$\C{equivalent to `\.{or}'}\par
\fi

\M16. When we initialize the \\{xord} array and the remaining parts of %
\\{xchr},
it will be convenient to make use of an index variable, \|i.

\Y\P$\4\X16:Local variables for initialization\X\S$\6
\4\|i: \37$0\to255$;\par
\As40, 56\ETs247.
\U2.\fi

\M17. Here now is the system-dependent part of the character set.
If \.{WEB} is being implemented on a garden-variety \PASCAL\ for which
only standard ASCII codes will appear in the input and output files, you
don't need to make any changes here. But if you have, for example, an extended
character set like the one in Appendix~C of {\sl The \TeX book}, the first
line of code in this module should be changed to
$$\hbox{ \&{for} $\|i\K1\mathrel{\&{to}}\O{37}$ \&{do} $\\{xchr}[\|i]\K\\{chr}(%
\|i)$;}$$
\.{WEB}'s character set is essentially identical to \TeX's, even with respect
to
characters less than \O{40}.

Changes to the present module will make \.{WEB} more friendly on computers
that have an extended character set, so that one can type things like
\.^^Z\ instead of \.{<>}. If you have an extended set of characters that
are easily incorporated into text files, you can assign codes arbitrarily
here, giving an \\{xchr} equivalent to whatever characters the users of
\.{WEB} are allowed to have in their input files, provided that unsuitable
characters do not correspond to special codes like \\{carriage\_return}
that are listed above.

(The present file \.{WEAVE.WEB} does not contain any of the non-ASCII
characters, because it is intended to be used with all implementations of
\.{WEB}.  It was originally created on a Stanford system that has a
convenient extended character set, then ``sanitized'' by applying another
program that transliterated all of the non-standard characters into
standard equivalents.)

\Y\P$\4\X10:Set initial values\X\mathrel{+}\S$\6
\&{for} $\|i\K1\mathrel{\&{to}}\O{37}$ \1\&{do}\5
$\\{xchr}[\|i]\K\.{\'\ \'}$;\2\6
\&{for} $\|i\K\O{200}\mathrel{\&{to}}\O{377}$ \1\&{do}\5
$\\{xchr}[\|i]\K\.{\'\ \'}$;\2\par
\fi

\M18. The following system-independent code makes the \\{xord} array contain a
suitable inverse to the information in \\{xchr}.

\Y\P$\4\X10:Set initial values\X\mathrel{+}\S$\6
\&{for} $\|i\K\\{first\_text\_char}\mathrel{\&{to}}\\{last\_text\_char}$ \1%
\&{do}\5
$\\{xord}[\\{chr}(\|i)]\K\.{"\ "}$;\2\6
\&{for} $\|i\K1\mathrel{\&{to}}\O{377}$ \1\&{do}\5
$\\{xord}[\\{xchr}[\|i]]\K\|i$;\2\6
$\\{xord}[\.{\'\ \'}]\K\.{"\ "}$;\par
\fi

\N19.  Input and output.
The input conventions of this program are intended to be very much like those
of \TeX\ (except, of course, that they are much simpler, because much less
needs to be done). Furthermore they are identical to those of \.{TANGLE}.
Therefore people who need to make modifications to all three systems
should be able to do so without too many headaches.

We use the standard \PASCAL\ input/output procedures in several places that
\TeX\ cannot, since \.{WEAVE} does not have to deal with files that are named
dynamically by the user, and since there is no input from the terminal.

\fi

\M20. Terminal output is done by writing on file \\{term\_out}, which is
assumed to
consist of characters of type \\{text\_char}:

\Y\P\D \37$\\{print}(\#)\S\\{write}(\\{term\_out},\39\#)$\C{`\\{print}' means
write on the terminal}\par
\P\D \37$\\{print\_ln}(\#)\S\\{write\_ln}(\\{term\_out},\39\#)$\C{`\\{print}'
and then start new line}\par
\P\D \37$\\{new\_line}\S\\{write\_ln}(\\{term\_out})$\C{start new line}\par
\P\D \37$\\{print\_nl}(\#)\S$\C{print information starting on a new line}\6
\&{begin} \37\\{new\_line};\5
$\\{print}(\#)$;\6
\&{end}\par
\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{term\_out}: \37\\{text\_file};\C{the terminal as an output file}\par
\fi

\M21. Different systems have different ways of specifying that the output on a
certain file will appear on the user's terminal. Here is one way to do this
on the \PASCAL\ system that was used in \.{TANGLE}'s initial development:

\Y\P$\4\X10:Set initial values\X\mathrel{+}\S$\6
$\\{rewrite}(\\{term\_out},\39\.{\'TTY:\'})$;\C{send \\{term\_out} output to
the terminal}\par
\fi

\M22. The \\{update\_terminal} procedure is called when we want
to make sure that everything we have output to the terminal so far has
actually left the computer's internal buffers and been sent.

\Y\P\D \37$\\{update\_terminal}\S\\{break}(\\{term\_out})$\C{empty the terminal
output buffer}\par
\fi

\M23. The main input comes from \\{web\_file}; this input may be overridden
by changes in \\{change\_file}. (If \\{change\_file} is empty, there are no
changes.)

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{web\_file}: \37\\{text\_file};\C{primary input}\6
\4\\{change\_file}: \37\\{text\_file};\C{updates}\par
\fi

\M24. The following code opens the input files.  Since these files were listed
in the program header, we assume that the \PASCAL\ runtime system has
already checked that suitable file names have been given; therefore no
additional error checking needs to be done. We will see below that
\.{WEAVE} reads through the entire input twice.

\Y\P\4\&{procedure}\1\  \37\\{open\_input};\C{prepare to read \\{web\_file} and
\\{change\_file}}\2\6
\&{begin} \37$\\{reset}(\\{web\_file})$;\5
$\\{reset}(\\{change\_file})$;\6
\&{end};\par
\fi

\M25. The main output goes to \\{tex\_file}.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{tex\_file}: \37\\{text\_file};\par
\fi

\M26. The following code opens \\{tex\_file}.
Since this file was listed in the program header, we assume that the
\PASCAL\ runtime system has checked that a suitable external file name has
been given.

\Y\P$\4\X10:Set initial values\X\mathrel{+}\S$\6
$\\{rewrite}(\\{tex\_file})$;\par
\fi

\M27. Input goes into an array called \\{buffer}.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{buffer}: \37\&{array} $[0\to\\{long\_buf\_size}]$ \1\&{of}\5
\\{ASCII\_code};\2\par
\fi

\M28. The \\{input\_ln} procedure brings the next line of input from the
specified
file into the \\{buffer} array and returns the value \\{true}, unless the file
has
already been entirely read, in which case it returns \\{false}. The conventions
of \TeX\ are followed; i.e., \\{ASCII\_code} numbers representing the next line
of the file are input into $\\{buffer}[0]$, $\\{buffer}[1]$, \dots,
$\\{buffer}[\\{limit}-1]$; trailing blanks are ignored;
and the global variable \\{limit} is set to the length of the
line. The value of \\{limit} must be strictly less than \\{buf\_size}.

We assume that none of the \\{ASCII\_code} values
of $\\{buffer}[\|j]$ for $0\L\|j<\\{limit}$ is equal to 0, \O{177}, \\{line%
\_feed}, \\{form\_feed},
or \\{carriage\_return}. Since \\{buf\_size} is strictly less than \\{long\_buf%
\_size},
some of \.{WEAVE}'s routines use the fact that it is safe to refer to
$\\{buffer}[\\{limit}+2]$ without overstepping the bounds of the array.

\Y\P\4\&{function}\1\  \37$\\{input\_ln}(\mathop{\&{var}}\|f:\\{text\_file})$: %
\37\\{boolean};\C{inputs a line or returns \\{false}}\6
\4\&{var} \37\\{final\_limit}: \37$0\to\\{buf\_size}$;\C{\\{limit} without
trailing blanks}\2\6
\&{begin} \37$\\{limit}\K0$;\5
$\\{final\_limit}\K0$;\6
\&{if} $\\{eof}(\|f)$ \1\&{then}\5
$\\{input\_ln}\K\\{false}$\6
\4\&{else} \&{begin} \37\&{while} $\R\\{eoln}(\|f)$ \1\&{do}\6
\&{begin} \37$\\{buffer}[\\{limit}]\K\\{xord}[\|f\^]$;\5
$\\{get}(\|f)$;\5
$\\{incr}(\\{limit})$;\6
\&{if} $\\{buffer}[\\{limit}-1]\I\.{"\ "}$ \1\&{then}\5
$\\{final\_limit}\K\\{limit}$;\2\6
\&{if} $\\{limit}=\\{buf\_size}$ \1\&{then}\6
\&{begin} \37\&{while} $\R\\{eoln}(\|f)$ \1\&{do}\5
$\\{get}(\|f)$;\2\6
$\\{decr}(\\{limit})$;\C{keep $\\{buffer}[\\{buf\_size}]$ empty}\6
\&{if} $\\{final\_limit}>\\{limit}$ \1\&{then}\5
$\\{final\_limit}\K\\{limit}$;\2\6
$\\{print\_nl}(\.{\'!\ Input\ line\ too\ long\'})$;\5
$\\{loc}\K0$;\5
\\{error};\6
\&{end};\2\6
\&{end};\2\6
$\\{read\_ln}(\|f)$;\5
$\\{limit}\K\\{final\_limit}$;\5
$\\{input\_ln}\K\\{true}$;\6
\&{end};\2\6
\&{end};\par
\fi

\N29.  Reporting errors to the user.
The \.{WEAVE} processor operates in three phases: first it inputs the source
file and stores cross-reference data, then it inputs the source once again and
produces the \TeX\ output file, and finally it sorts and outputs the index.

The global variables \\{phase\_one} and \\{phase\_three} tell which Phase we
are in.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{phase\_one}: \37\\{boolean};\C{\\{true} in Phase I, \\{false} in Phases II
and III}\6
\4\\{phase\_three}: \37\\{boolean};\C{\\{true} in Phase III, \\{false} in
Phases I and II}\par
\fi

\M30. If an error is detected while we are debugging,
we usually want to look at the contents of memory.
A special procedure will be declared later for this purpose.

\Y\P$\4\X30:Error handling procedures\X\S$\6
\&{debug} \37\ \&{procedure}\1\  \37\\{debug\_help};\5
\\{forward};\ \&{gubed} \par
\As31\ET33.
\U2.\fi

\M31. The command `$\\{err\_print}(\.{\'!\ Error\ message\'})$' will report a
syntax error to
the user, by printing the error message at the beginning of a new line and
then giving an indication of where the error was spotted in the source file.
Note that no period follows the error message, since the error routine
will automatically supply a period.

The actual error indications are provided by a procedure called \\{error}.
However, error messages are not actually reported during phase one,
since errors detected on the first pass will be detected again
during the second.

\Y\P\D \37$\\{err\_print}(\#)\S$\1\6
\&{begin} \37\&{if} $\R\\{phase\_one}$ \1\&{then}\6
\&{begin} \37\\{new\_line};\5
$\\{print}(\#)$;\5
\\{error};\6
\&{end};\2\6
\&{end}\2\par
\Y\P$\4\X30:Error handling procedures\X\mathrel{+}\S$\6
\4\&{procedure}\1\  \37\\{error};\C{prints `\..' and location of error message}%
\6
\4\&{var} \37$\|k,\39\|l$: \37$0\to\\{long\_buf\_size}$;\C{indices into %
\\{buffer}}\2\6
\&{begin} \37\X32:Print error location based on input buffer\X;\6
\\{update\_terminal};\5
\\{mark\_error};\6
\&{debug} \37$\\{debug\_skipped}\K\\{debug\_cycle}$;\5
\\{debug\_help};\ \&{gubed}\6
\&{end};\par
\fi

\M32. The error locations can be indicated by using the global variables
\\{loc}, \\{line}, and \\{changing}, which tell respectively the first
unlooked-at position in \\{buffer}, the current line number, and whether or not
the current line is from \\{change\_file} or \\{web\_file}.
This routine should be modified on systems whose standard text editor
has special line-numbering conventions.

\Y\P$\4\X32:Print error location based on input buffer\X\S$\6
\&{begin} \37\&{if} $\\{changing}$ \1\&{then}\5
$\\{print}(\.{\'.\ (change\ file\ \'})$\ \&{else} $\\{print}(\.{\'.\ (\'})$;\2\6
$\\{print\_ln}(\.{\'l.\'},\39\\{line}:1,\39\.{\')\'})$;\6
\&{if} $\\{loc}\G\\{limit}$ \1\&{then}\5
$\|l\K\\{limit}$\6
\4\&{else} $\|l\K\\{loc}$;\2\6
\&{for} $\|k\K1\mathrel{\&{to}}\|l$ \1\&{do}\6
\&{if} $\\{buffer}[\|k-1]=\\{tab\_mark}$ \1\&{then}\5
$\\{print}(\.{\'\ \'})$\6
\4\&{else} $\\{print}(\\{xchr}[\\{buffer}[\|k-1]])$;\C{print the characters
already read}\2\2\6
\\{new\_line};\6
\&{for} $\|k\K1\mathrel{\&{to}}\|l$ \1\&{do}\5
$\\{print}(\.{\'\ \'})$;\C{space out the next line}\2\6
\&{for} $\|k\K\|l+1\mathrel{\&{to}}\\{limit}$ \1\&{do}\5
$\\{print}(\\{xchr}[\\{buffer}[\|k-1]])$;\C{print the part not yet read}\2\6
\&{if} $\\{buffer}[\\{limit}]=\.{"|"}$ \1\&{then}\5
$\\{print}(\\{xchr}[\.{"|"}])$;\C{end of \PASCAL\ text in module names}\2\6
$\\{print}(\.{\'\ \'})$;\C{this space separates the message from future
asterisks}\6
\&{end}\par
\U31.\fi

\M33. The \\{jump\_out} procedure just cuts across all active procedure levels
and jumps out of the program. This is the only non-local \&{goto} statement
in \.{WEAVE}. It is used when no recovery from a particular error has
been provided.

Some \PASCAL\ compilers do not implement non-local \&{goto}  statements.
In such cases the code that appears at label \\{end\_of\_WEAVE} should be
copied into the \\{jump\_out} procedure, followed by a call to a system
procedure
that terminates the program.

\Y\P\D \37$\\{fatal\_error}(\#)\S$\1\6
\&{begin} \37\\{new\_line};\5
$\\{print}(\#)$;\5
\\{error};\5
\\{mark\_fatal};\5
\\{jump\_out};\6
\&{end}\2\par
\Y\P$\4\X30:Error handling procedures\X\mathrel{+}\S$\6
\4\&{procedure}\1\  \37\\{jump\_out};\2\6
\&{begin} \37\&{goto} \37\\{end\_of\_WEAVE};\6
\&{end};\par
\fi

\M34. Sometimes the program's behavior is far different from what it should be,
and \.{WEAVE} prints an error message that is really for the \.{WEAVE}
maintenance person, not the user. In such cases the program says
$\\{confusion}(\.{\'indication\ of\ where\ we\ are\'})$.

\Y\P\D \37$\\{confusion}(\#)\S\\{fatal\_error}(\.{\'!\ This\ can\'}\.{\'t\
happen\ (\'},\39\#,\39\.{\')\'})$\par
\fi

\M35. An overflow stop occurs if \.{WEAVE}'s tables aren't large enough.

\Y\P\D \37$\\{overflow}(\#)\S\\{fatal\_error}(\.{\'!\ Sorry,\ \'},\39\#,\39\.{%
\'\ capacity\ exceeded\'})$\par
\fi

\N36.  Data structures.
During the first phase of its processing, \.{WEAVE} puts identifier names,
index entries, and module names into the large \\{byte\_mem} array, which is
packed with eight-bit integers. Allocation is sequential, since names are
never deleted.

An auxiliary array \\{byte\_start} is used as a directory for \\{byte\_mem},
and the \\{link}, \\{ilk}, and \\{xref} arrays give further information about
names.
These auxiliary arrays consist of sixteen-bit items.

\Y\P$\4\X11:Types in the outer block\X\mathrel{+}\S$\6
$\\{eight\_bits}=0\to255$;\C{unsigned one-byte quantity}\6
$\\{sixteen\_bits}=0\to65535$;\C{unsigned two-byte quantity}\par
\fi

\M37. \.{WEAVE} has been designed to avoid the need for indices that are more
than sixteen bits wide, so that it can be used on most computers. But
there are programs that need more than 65536 bytes; \TeX\ is one of these.
To get around this problem, a slight complication has been added to the
data structures:  \\{byte\_mem} is a two-dimensional array, whose first index
is either 0 or 1. (For generality, the first index is actually allowed to
run between 0 and $\\{ww}-1$, where \\{ww} is defined to be 2; the program will
work for any positive value of \\{ww}, and it can be simplified in obvious
ways if $\\{ww}=1$.)

\Y\P\D \37$\\{ww}=2$\C{we multiply the byte capacity by approximately this
amount}\par
\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{byte\_mem}: \37\&{packed} \37\&{array} $[0\to\\{ww}-1,\390\to\\{max%
\_bytes}]$ \1\&{of}\5
\\{ASCII\_code};\C{characters of names}\2\6
\4\\{byte\_start}: \37\&{array} $[0\to\\{max\_names}]$ \1\&{of}\5
\\{sixteen\_bits};\C{directory into \\{byte\_mem}}\2\6
\4\\{link}: \37\&{array} $[0\to\\{max\_names}]$ \1\&{of}\5
\\{sixteen\_bits};\C{hash table or tree links}\2\6
\4\\{ilk}: \37\&{array} $[0\to\\{max\_names}]$ \1\&{of}\5
\\{sixteen\_bits};\C{type codes or tree links}\2\6
\4\\{xref}: \37\&{array} $[0\to\\{max\_names}]$ \1\&{of}\5
\\{sixteen\_bits};\C{heads of cross-reference lists}\2\par
\fi

\M38. The names of identifiers are found by computing a hash address \|h and
then looking at strings of bytes signified by $\\{hash}[\|h]$, $\\{link}[%
\\{hash}[\|h]]$,
$\\{link}[\\{link}[\\{hash}[\|h]]]$, \dots, until either finding the desired
name
or encountering a zero.

A `\\{name\_pointer}' variable, which signifies a name, is an index into
\\{byte\_start}. The actual sequence of characters in the name pointed to by
\|p appears in positions $\\{byte\_start}[\|p]$ to $\\{byte\_start}[\|p+%
\\{ww}]-1$, inclusive,
in the segment of \\{byte\_mem} whose first index is $\|p\mathbin{\&{mod}}%
\\{ww}$. Thus, when
$\\{ww}=2$ the even-numbered name bytes appear in $\\{byte\_mem}[0,\hbox{$*$}]$
and the odd-numbered ones appear in $\\{byte\_mem}[1,\hbox{$*$}]$.
The pointer 0 is used for undefined module names; we don't
want to use it for the names of identifiers, since 0 stands for a null
pointer in a linked list.

We usually have $\\{byte\_start}[\\{name\_ptr}+\|w]=\\{byte\_ptr}[(\\{name%
\_ptr}+\|w)\mathbin{\&{mod}}\\{ww}]$
for $0\L\|w<\\{ww}$, since these are the starting positions for the next \\{ww}
names to be stored in \\{byte\_mem}.

\Y\P\D \37$\\{length}(\#)\S\\{byte\_start}[\#+\\{ww}]-\\{byte\_start}[\#]$%
\C{the length of a name}\par
\Y\P$\4\X11:Types in the outer block\X\mathrel{+}\S$\6
$\\{name\_pointer}=0\to\\{max\_names}$;\C{identifies a name}\par
\fi

\M39. \P$\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{name\_ptr}: \37\\{name\_pointer};\C{first unused position in \\{byte%
\_start}}\6
\4\\{byte\_ptr}: \37\&{array} $[0\to\\{ww}-1]$ \1\&{of}\5
$0\to\\{max\_bytes}$;\C{first unused position in \\{byte\_mem}}\2\par
\fi

\M40. \P$\X16:Local variables for initialization\X\mathrel{+}\S$\6
\4\\{wi}: \37$0\to\\{ww}-1$;\C{to initialize the \\{byte\_mem} indices}\par
\fi

\M41. \P$\X10:Set initial values\X\mathrel{+}\S$\6
\&{for} $\\{wi}\K0\mathrel{\&{to}}\\{ww}-1$ \1\&{do}\6
\&{begin} \37$\\{byte\_start}[\\{wi}]\K0$;\5
$\\{byte\_ptr}[\\{wi}]\K0$;\6
\&{end};\2\6
$\\{byte\_start}[\\{ww}]\K0$;\C{this makes name 0 of length zero}\6
$\\{name\_ptr}\K1$;\par
\fi

\M42. Several types of identifiers are distinguished by their \\{ilk}:

\yskip\hang \\{normal} identifiers are part of the \PASCAL\ program and
will appear in italic type.

\yskip\hang \\{roman} identifiers are index entries that appear after
\.{@\^} in the \.{WEB} file.

\yskip\hang \\{wildcard} identifiers are index entries that appear after
\.{@:} in the \.{WEB} file.

\yskip\hang \\{typewriter} identifiers are index entries that appear after
\.{@.} in the \.{WEB} file.

\yskip\hang \\{array\_like}, \\{begin\_like}, \dots, \\{var\_like}
identifiers are \PASCAL\ reserved words whose \\{ilk} explains how they are
to be treated when \PASCAL\ code is being formatted.

\yskip\hang Finally, if \|c is an ASCII code, an \\{ilk} equal to
$\\{char\_like}+\|c$ denotes a reserved word that will be converted to
character
\|c.

\Y\P\D \37$\\{normal}=0$\C{ordinary identifiers have \\{normal} ilk}\par
\P\D \37$\\{roman}=1$\C{normal index entries have \\{roman} ilk}\par
\P\D \37$\\{wildcard}=2$\C{user-formatted index entries have \\{wildcard} ilk}%
\par
\P\D \37$\\{typewriter}=3$\C{`typewriter type' entries have \\{typewriter} ilk}%
\par
\P\D \37$\\{reserved}(\#)\S(\\{ilk}[\#]>\\{typewriter})$\C{tells if a name is a
reserved word}\par
\P\D \37$\\{array\_like}=4$\C{\&{array}, \&{file}, \&{set}}\par
\P\D \37$\\{begin\_like}=5$\C{\&{begin}}\par
\P\D \37$\\{case\_like}=6$\C{\&{case}}\par
\P\D \37$\\{const\_like}=7$\C{\&{const}, \&{label}, \&{type}}\par
\P\D \37$\\{div\_like}=8$\C{\&{div}, \&{mod}}\par
\P\D \37$\\{do\_like}=9$\C{\&{do}, \&{of}, \&{then}}\par
\P\D \37$\\{else\_like}=10$\C{\&{else}}\par
\P\D \37$\\{end\_like}=11$\C{\&{end}}\par
\P\D \37$\\{for\_like}=12$\C{\&{for}, \&{while}, \&{with}}\par
\P\D \37$\\{goto\_like}=13$\C{\&{goto}, \&{packed}}\par
\P\D \37$\\{if\_like}=14$\C{\&{if}}\par
\P\D \37$\\{in\_like}=15$\C{\&{in}}\par
\P\D \37$\\{nil\_like}=16$\C{\&{nil}}\par
\P\D \37$\\{proc\_like}=17$\C{\&{function}, \&{procedure}, \&{program}}\par
\P\D \37$\\{record\_like}=18$\C{\&{record}}\par
\P\D \37$\\{repeat\_like}=19$\C{\&{repeat}}\par
\P\D \37$\\{to\_like}=20$\C{\&{downto}, \&{to}}\par
\P\D \37$\\{until\_like}=21$\C{\&{until}}\par
\P\D \37$\\{var\_like}=22$\C{\&{var}}\par
\P\D \37$\\{loop\_like}=23$\C{\&{loop}, \&{xclause}}\par
\P\D \37$\\{char\_like}=24$\C{\&{and}, \&{or}, \&{not}, \&{in}}\par
\fi

\M43. The names of modules are stored in \\{byte\_mem} together
with the identifier names, but a hash table is not used for them because
\.{WEAVE} needs to be able to recognize a module name when given a prefix of
that name. A conventional binary seach tree is used to retrieve module names,
with fields called \\{llink} and \\{rlink} in place of \\{link} and \\{ilk}.
The
root of this tree is $\\{rlink}[0]$.

\Y\P\D \37$\\{llink}\S\\{link}$\C{left link in binary search tree for module
names}\par
\P\D \37$\\{rlink}\S\\{ilk}$\C{right link in binary search tree for module
names}\par
\P\D \37$\\{root}\S\\{rlink}[0]$\C{the root of the binary search tree for
module names}\par
\Y\P$\4\X10:Set initial values\X\mathrel{+}\S$\6
$\\{root}\K0$;\C{the binary search tree starts out with nothing in it}\par
\fi

\M44. Here is a little procedure that prints the text of a given name on the
user's terminal.

\Y\P\4\&{procedure}\1\  \37$\\{print\_id}(\|p:\\{name\_pointer})$;\C{print
identifier or module name}\6
\4\&{var} \37\|k: \37$0\to\\{max\_bytes}$;\C{index into \\{byte\_mem}}\6
\|w: \37$0\to\\{ww}-1$;\C{row of \\{byte\_mem}}\2\6
\&{begin} \37\&{if} $\|p\G\\{name\_ptr}$ \1\&{then}\5
$\\{print}(\.{\'IMPOSSIBLE\'})$\6
\4\&{else} \&{begin} \37$\|w\K\|p\mathbin{\&{mod}}\\{ww}$;\6
\&{for} $\|k\K\\{byte\_start}[\|p]\mathrel{\&{to}}\\{byte\_start}[\|p+%
\\{ww}]-1$ \1\&{do}\5
$\\{print}(\\{xchr}[\\{byte\_mem}[\|w,\39\|k]])$;\2\6
\&{end};\2\6
\&{end};\par
\fi

\M45. We keep track of the current module number in
\\{module\_count}, which is the total number of modules that have started.
Modules which have been altered by a change file entry
have their \\{changed\_module} flag turned on during the first phase.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{module\_count}: \37$0\to\\{max\_modules}$;\C{the current module number}\6
\4\\{changed\_module}: \37\&{packed} \37\&{array} $[0\to\\{max\_modules}]$ \1%
\&{of}\5
\\{boolean};\C{is it changed?}\2\6
\4\\{change\_exists}: \37\\{boolean};\C{has any module changed?}\par
\fi

\M46. The other large memory area in \.{WEAVE} keeps the cross-reference data.
All uses of the name \|p are recorded in a linked list beginning at
$\\{xref}[\|p]$, which points into the \\{xmem} array. Entries in \\{xmem}
consist
of two sixteen-bit items per word, called the \\{num} and \\{xlink} fields.
If \|x is an index into \\{xmem}, reached from name \|p, the value of $\\{num}(%
\|x)$
is either a module number where \|p is used, or it is \\{def\_flag} plus a
module number where \|p is defined; and $\\{xlink}(\|x)$ points to the next
such
cross reference for \|p, if any. This list of cross references is in
decreasing order by module number. The current number of cross references
is \\{xref\_ptr}.

The global variable \\{xref\_switch} is set either to \\{def\_flag} or to zero,
depending on whether the next cross reference to an identifier is to be
underlined or not in the index. This switch is set to \\{def\_flag} when
\.{@!} or \.{@d} or \.{@f} is scanned, and it is cleared to zero when
the next identifier or index entry cross reference has been made. Similarly,
the global variable \\{mod\_xref\_switch} is either \\{def\_flag} or zero,
depending
on whether a module name is being defined or used.

\Y\P\D \37$\\{num}(\#)\S\\{xmem}[\#].\\{num\_field}$\par
\P\D \37$\\{xlink}(\#)\S\\{xmem}[\#].\\{xlink\_field}$\par
\P\D \37$\\{def\_flag}=10240$\C{must be strictly larger than \\{max\_modules}}%
\par
\fi

\M47. \P$\X11:Types in the outer block\X\mathrel{+}\S$\6
$\\{xref\_number}=0\to\\{max\_refs}$;\par
\fi

\M48. \P$\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{xmem}: \37\&{array} $[\\{xref\_number}]$ \1\&{of}\5
\&{packed} \37\1\&{record} \37\hbox{}\6
\4\\{num\_field}: \37\\{sixteen\_bits};\C{module number plus zero or \\{def%
\_flag}}\6
\4\\{xlink\_field}: \37\\{sixteen\_bits};\C{pointer to the previous cross
reference}\2\6
\&{end};\2\6
\4\\{xref\_ptr}: \37\\{xref\_number};\C{the largest occupied position in %
\\{xmem}}\6
\4$\\{xref\_switch},\39\\{mod\_xref\_switch}$: \37$0\to\\{def\_flag}$;\C{either
zero or \\{def\_flag}}\par
\fi

\M49. \P$\X10:Set initial values\X\mathrel{+}\S$\6
$\\{xref\_ptr}\K0$;\5
$\\{xref\_switch}\K0$;\5
$\\{mod\_xref\_switch}\K0$;\5
$\\{num}(0)\K0$;\5
$\\{xref}[0]\K0$;\C{cross references to undefined modules}\par
\fi

\M50. A new cross reference for an identifier is formed by calling \\{new%
\_xref},
which discards duplicate entries and ignores non-underlined references
to one-letter identifiers or \PASCAL's reserved words.

\Y\P\D \37$\\{append\_xref}(\#)\S$\1\6
\&{if} $\\{xref\_ptr}=\\{max\_refs}$ \1\&{then}\5
$\\{overflow}(\.{\'cross\ reference\'})$\6
\4\&{else} \&{begin} \37$\\{incr}(\\{xref\_ptr})$;\5
$\\{num}(\\{xref\_ptr})\K\#$;\6
\&{end}\2\2\par
\Y\P\4\&{procedure}\1\  \37$\\{new\_xref}(\|p:\\{name\_pointer})$;\6
\4\&{label} \37\\{exit};\6
\4\&{var} \37\|q: \37\\{xref\_number};\C{pointer to previous cross reference}\6
$\|m,\39\|n$: \37\\{sixteen\_bits};\C{new and previous cross-reference value}\2%
\6
\&{begin} \37\&{if} $(\\{reserved}(\|p)\V(\\{byte\_start}[\|p]+1=\\{byte%
\_start}[\|p+\\{ww}]))\W(\\{xref\_switch}=0)$ \1\&{then}\5
\&{return};\2\6
$\|m\K\\{module\_count}+\\{xref\_switch}$;\5
$\\{xref\_switch}\K0$;\5
$\|q\K\\{xref}[\|p]$;\6
\&{if} $\|q>0$ \1\&{then}\6
\&{begin} \37$\|n\K\\{num}(\|q)$;\6
\&{if} $(\|n=\|m)\V(\|n=\|m+\\{def\_flag})$ \1\&{then}\5
\&{return}\6
\4\&{else} \&{if} $\|m=\|n+\\{def\_flag}$ \1\&{then}\6
\&{begin} \37$\\{num}(\|q)\K\|m$;\5
\&{return};\6
\&{end};\2\2\6
\&{end};\2\6
$\\{append\_xref}(\|m)$;\5
$\\{xlink}(\\{xref\_ptr})\K\|q$;\5
$\\{xref}[\|p]\K\\{xref\_ptr}$;\6
\4\\{exit}: \37\&{end};\par
\fi

\M51. The cross reference lists for module names are slightly different.
Suppose
that a module name is defined in modules $m_1$, \dots, $m_k$ and used in
modules $n_1$, \dots, $n_l$. Then its list will contain $m_1+\\{def\_flag}$,
$m_k+\\{def\_flag}$, \dots, $m_2+\\{def\_flag}$, $n_l$, \dots, $n_1$, in
this order.  After Phase II, however, the order will be
$m_1+\\{def\_flag}$, \dots, $m_k+\\{def\_flag}$, $n_1$, \dots, $n_l$.

\Y\P\4\&{procedure}\1\  \37$\\{new\_mod\_xref}(\|p:\\{name\_pointer})$;\6
\4\&{var} \37$\|q,\39\|r$: \37\\{xref\_number};\C{pointers to previous cross
references}\2\6
\&{begin} \37$\|q\K\\{xref}[\|p]$;\5
$\|r\K0$;\6
\&{if} $\|q>0$ \1\&{then}\6
\&{begin} \37\&{if} $\\{mod\_xref\_switch}=0$ \1\&{then}\6
\&{while} $\\{num}(\|q)\G\\{def\_flag}$ \1\&{do}\6
\&{begin} \37$\|r\K\|q$;\5
$\|q\K\\{xlink}(\|q)$;\6
\&{end}\2\6
\4\&{else} \&{if} $\\{num}(\|q)\G\\{def\_flag}$ \1\&{then}\6
\&{begin} \37$\|r\K\|q$;\5
$\|q\K\\{xlink}(\|q)$;\6
\&{end};\2\2\6
\&{end};\2\6
$\\{append\_xref}(\\{module\_count}+\\{mod\_xref\_switch})$;\5
$\\{xlink}(\\{xref\_ptr})\K\|q$;\5
$\\{mod\_xref\_switch}\K0$;\6
\&{if} $\|r=0$ \1\&{then}\5
$\\{xref}[\|p]\K\\{xref\_ptr}$\6
\4\&{else} $\\{xlink}(\|r)\K\\{xref\_ptr}$;\2\6
\&{end};\par
\fi

\M52. A third large area of memory is used for sixteen-bit `tokens', which
appear
in short lists similar to the strings of characters in \\{byte\_mem}. Token
lists
are used to contain the result of \PASCAL\ code translated into \TeX\ form;
further details about them will be explained later. A \\{text\_pointer}
variable
is an index into \\{tok\_start}.

\Y\P$\4\X11:Types in the outer block\X\mathrel{+}\S$\6
$\\{text\_pointer}=0\to\\{max\_texts}$;\C{identifies a token list}\par
\fi

\M53. The first position of \\{tok\_mem}
that is unoccupied by replacement text is called \\{tok\_ptr}, and the first
unused location of \\{tok\_start} is called \\{text\_ptr}.
Thus, we usually have $\\{tok\_start}[\\{text\_ptr}]=\\{tok\_ptr}$.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\hbox{\hskip1em}\\{tok\_mem}: \37\&{packed} \37\&{array} $[0\to\\{max%
\_toks}]$ \1\&{of}\5
\\{sixteen\_bits};\C{tokens}\2\6
\4\hbox{\hskip1em}\\{tok\_start}: \37\&{array} $[\\{text\_pointer}]$ \1\&{of}\5
\\{sixteen\_bits};\C{directory into \\{tok\_mem}}\2\6
\4\hbox{\hskip1em}\\{text\_ptr}: \37\\{text\_pointer};\C{first unused position
in \\{tok\_start}}\6
\4\hbox{\hskip1em}\\{tok\_ptr}: \37$0\to\\{max\_toks}$;\C{first unused position
in \\{tok\_mem}}\6
\&{stat} \37$\\{max\_tok\_ptr},\39\\{max\_txt\_ptr}$: \37$0\to\\{max\_toks}$;%
\C{largest values occurring}\6
\&{tats}\par
\fi

\M54. \P$\X10:Set initial values\X\mathrel{+}\S$\6
$\\{tok\_ptr}\K1$;\5
$\\{text\_ptr}\K1$;\5
$\\{tok\_start}[0]\K1$;\5
$\\{tok\_start}[1]\K1$;\6
\&{stat} \37$\\{max\_tok\_ptr}\K1$;\5
$\\{max\_txt\_ptr}\K1$;\ \&{tats}\par
\fi

\N55.  Searching for identifiers.
The hash table described above is updated by the \\{id\_lookup} procedure,
which finds a given identifier and returns a pointer to its index in
\\{byte\_start}. The identifier is supposed to match character by character
and it is also supposed to have a given \\{ilk} code; the same name may be
present more than once if it is supposed to appear in the index with
different typesetting conventions.
If the identifier was not already present, it is inserted into the table.

Because of the way \.{WEAVE}'s scanning mechanism works, it is most convenient
to let \\{id\_lookup} search for an identifier that is present in the %
\\{buffer}
array. Two other global variables specify its position in the buffer: the
first character is $\\{buffer}[\\{id\_first}]$, and the last is $\\{buffer}[%
\\{id\_loc}-1]$.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{id\_first}: \37$0\to\\{long\_buf\_size}$;\C{where the current identifier
begins in the buffer}\6
\4\\{id\_loc}: \37$0\to\\{long\_buf\_size}$;\C{just after the current
identifier in the buffer}\7
\4\\{hash}: \37\&{array} $[0\to\\{hash\_size}]$ \1\&{of}\5
\\{sixteen\_bits};\C{heads of hash lists}\2\par
\fi

\M56. Initially all the hash lists are empty.

\Y\P$\4\X16:Local variables for initialization\X\mathrel{+}\S$\6
\4\|h: \37$0\to\\{hash\_size}$;\C{index into hash-head array}\par
\fi

\M57. \P$\X10:Set initial values\X\mathrel{+}\S$\6
\&{for} $\|h\K0\mathrel{\&{to}}\\{hash\_size}-1$ \1\&{do}\5
$\\{hash}[\|h]\K0$;\2\par
\fi

\M58. Here now is the main procedure for finding identifiers (and index
entries).  The parameter \|t is set to the desired \\{ilk} code. The
identifier must either have $\\{ilk}=\|t$, or we must have
$\|t=\\{normal}$ and the identifier must be a reserved word.

\Y\P\4\&{function}\1\  \37$\\{id\_lookup}(\|t:\\{eight\_bits})$: \37\\{name%
\_pointer};\C{finds current identifier}\6
\4\&{label} \37\\{found};\6
\4\&{var} \37\|i: \37$0\to\\{long\_buf\_size}$;\C{index into \\{buffer}}\6
\|h: \37$0\to\\{hash\_size}$;\C{hash code}\6
\|k: \37$0\to\\{max\_bytes}$;\C{index into \\{byte\_mem}}\6
\|w: \37$0\to\\{ww}-1$;\C{row of \\{byte\_mem}}\6
\|l: \37$0\to\\{long\_buf\_size}$;\C{length of the given identifier}\6
\|p: \37\\{name\_pointer};\C{where the identifier is being sought}\2\6
\&{begin} \37$\|l\K\\{id\_loc}-\\{id\_first}$;\C{compute the length}\6
\X59:Compute the hash code \|h\X;\6
\X60:Compute the name location \|p\X;\6
\&{if} $\|p=\\{name\_ptr}$ \1\&{then}\5
\X62:Enter a new name into the table at position \|p\X;\2\6
$\\{id\_lookup}\K\|p$;\6
\&{end};\par
\fi

\M59. A simple hash code is used: If the sequence of
ASCII codes is $c_1c_2\ldots c_m$, its hash value will be
$$(2^{n-1}c_1+2^{n-2}c_2+\cdots+c_n)\,\bmod\,\\{hash\_size}.$$

\Y\P$\4\X59:Compute the hash code \|h\X\S$\6
$\|h\K\\{buffer}[\\{id\_first}]$;\5
$\|i\K\\{id\_first}+1$;\6
\&{while} $\|i<\\{id\_loc}$ \1\&{do}\6
\&{begin} \37$\|h\K(\|h+\|h+\\{buffer}[\|i])\mathbin{\&{mod}}\\{hash\_size}$;\5
$\\{incr}(\|i)$;\6
\&{end}\2\par
\U58.\fi

\M60. If the identifier is new, it will be placed in position $\|p=\\{name%
\_ptr}$,
otherwise \|p will point to its existing location.

\Y\P$\4\X60:Compute the name location \|p\X\S$\6
$\|p\K\\{hash}[\|h]$;\6
\&{while} $\|p\I0$ \1\&{do}\6
\&{begin} \37\&{if} $(\\{length}(\|p)=\|l)\W((\\{ilk}[\|p]=\|t)\V((\|t=%
\\{normal})\W\\{reserved}(\|p)))$ \1\&{then}\5
\X61:Compare name \|p with current identifier, \&{goto} \\{found} if equal\X;\2%
\6
$\|p\K\\{link}[\|p]$;\6
\&{end};\2\6
$\|p\K\\{name\_ptr}$;\C{the current identifier is new}\6
$\\{link}[\|p]\K\\{hash}[\|h]$;\5
$\\{hash}[\|h]\K\|p$;\C{insert \|p at beginning of hash list}\6
\4\\{found}: \37\par
\U58.\fi

\M61. \P$\X61:Compare name \|p with current identifier, \&{goto} \\{found} if
equal\X\S$\6
\&{begin} \37$\|i\K\\{id\_first}$;\5
$\|k\K\\{byte\_start}[\|p]$;\5
$\|w\K\|p\mathbin{\&{mod}}\\{ww}$;\6
\&{while} $(\|i<\\{id\_loc})\W(\\{buffer}[\|i]=\\{byte\_mem}[\|w,\39\|k])$ \1%
\&{do}\6
\&{begin} \37$\\{incr}(\|i)$;\5
$\\{incr}(\|k)$;\6
\&{end};\2\6
\&{if} $\|i=\\{id\_loc}$ \1\&{then}\5
\&{goto} \37\\{found};\C{all characters agree}\2\6
\&{end}\par
\U60.\fi

\M62. When we begin the following segment of the program, $\|p=\\{name\_ptr}$.

\Y\P$\4\X62:Enter a new name into the table at position \|p\X\S$\6
\&{begin} \37$\|w\K\\{name\_ptr}\mathbin{\&{mod}}\\{ww}$;\6
\&{if} $\\{byte\_ptr}[\|w]+\|l>\\{max\_bytes}$ \1\&{then}\5
$\\{overflow}(\.{\'byte\ memory\'})$;\2\6
\&{if} $\\{name\_ptr}+\\{ww}>\\{max\_names}$ \1\&{then}\5
$\\{overflow}(\.{\'name\'})$;\2\6
$\|i\K\\{id\_first}$;\5
$\|k\K\\{byte\_ptr}[\|w]$;\C{get ready to move the identifier into \\{byte%
\_mem}}\6
\&{while} $\|i<\\{id\_loc}$ \1\&{do}\6
\&{begin} \37$\\{byte\_mem}[\|w,\39\|k]\K\\{buffer}[\|i]$;\5
$\\{incr}(\|k)$;\5
$\\{incr}(\|i)$;\6
\&{end};\2\6
$\\{byte\_ptr}[\|w]\K\|k$;\5
$\\{byte\_start}[\\{name\_ptr}+\\{ww}]\K\|k$;\5
$\\{incr}(\\{name\_ptr})$;\5
$\\{ilk}[\|p]\K\|t$;\5
$\\{xref}[\|p]\K0$;\6
\&{end}\par
\U58.\fi

\N63.  Initializing the table of reserved words.
We have to get \PASCAL's reserved words into the hash table, and the
simplest way to do this is to insert them every time \.{WEAVE} is run.
A few macros permit us to do the initialization with a compact program.

\Y\P\D \37$\\{sid9}(\#)\S\\{buffer}[9]\K\#$;\5
$\\{cur\_name}\K\\{id\_lookup}$\par
\P\D \37$\\{sid8}(\#)\S\\{buffer}[8]\K\#$;\5
\\{sid9}\par
\P\D \37$\\{sid7}(\#)\S\\{buffer}[7]\K\#$;\5
\\{sid8}\par
\P\D \37$\\{sid6}(\#)\S\\{buffer}[6]\K\#$;\5
\\{sid7}\par
\P\D \37$\\{sid5}(\#)\S\\{buffer}[5]\K\#$;\5
\\{sid6}\par
\P\D \37$\\{sid4}(\#)\S\\{buffer}[4]\K\#$;\5
\\{sid5}\par
\P\D \37$\\{sid3}(\#)\S\\{buffer}[3]\K\#$;\5
\\{sid4}\par
\P\D \37$\\{sid2}(\#)\S\\{buffer}[2]\K\#$;\5
\\{sid3}\par
\P\D \37$\\{sid1}(\#)\S\\{buffer}[1]\K\#$;\5
\\{sid2}\par
\P\D \37$\\{id2}\S\\{id\_first}\K8$;\5
\\{sid8}\par
\P\D \37$\\{id3}\S\\{id\_first}\K7$;\5
\\{sid7}\par
\P\D \37$\\{id4}\S\\{id\_first}\K6$;\5
\\{sid6}\par
\P\D \37$\\{id5}\S\\{id\_first}\K5$;\5
\\{sid5}\par
\P\D \37$\\{id6}\S\\{id\_first}\K4$;\5
\\{sid4}\par
\P\D \37$\\{id7}\S\\{id\_first}\K3$;\5
\\{sid3}\par
\P\D \37$\\{id8}\S\\{id\_first}\K2$;\5
\\{sid2}\par
\P\D \37$\\{id9}\S\\{id\_first}\K1$;\5
\\{sid1}\par
\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{cur\_name}: \37\\{name\_pointer};\C{points to the identifier just
inserted}\par
\fi

\M64. The intended use of the macros above might not be immediately obvious,
but the riddle is answered by the following:

\Y\P$\4\X64:Store all the reserved words\X\S$\6
$\\{id\_loc}\K10$;\6
$\\{id3}(\.{"a"})(\.{"n"})(\.{"d"})(\\{char\_like}+\\{and\_sign})$;\6
$\\{id5}(\.{"a"})(\.{"r"})(\.{"r"})(\.{"a"})(\.{"y"})(\\{array\_like})$;\6
$\\{id5}(\.{"b"})(\.{"e"})(\.{"g"})(\.{"i"})(\.{"n"})(\\{begin\_like})$;\6
$\\{id4}(\.{"c"})(\.{"a"})(\.{"s"})(\.{"e"})(\\{case\_like})$;\6
$\\{id5}(\.{"c"})(\.{"o"})(\.{"n"})(\.{"s"})(\.{"t"})(\\{const\_like})$;\6
$\\{id3}(\.{"d"})(\.{"i"})(\.{"v"})(\\{div\_like})$;\6
$\\{id2}(\.{"d"})(\.{"o"})(\\{do\_like})$;\6
$\\{id6}(\.{"d"})(\.{"o"})(\.{"w"})(\.{"n"})(\.{"t"})(\.{"o"})(\\{to\_like})$;\6
$\\{id4}(\.{"e"})(\.{"l"})(\.{"s"})(\.{"e"})(\\{else\_like})$;\6
$\\{id3}(\.{"e"})(\.{"n"})(\.{"d"})(\\{end\_like})$;\6
$\\{id4}(\.{"f"})(\.{"i"})(\.{"l"})(\.{"e"})(\\{array\_like})$;\6
$\\{id3}(\.{"f"})(\.{"o"})(\.{"r"})(\\{for\_like})$;\6
$\\{id8}(\.{"f"})(\.{"u"})(\.{"n"})(\.{"c"})(\.{"t"})(\.{"i"})(\.{"o"})(%
\.{"n"})(\\{proc\_like})$;\6
$\\{id4}(\.{"g"})(\.{"o"})(\.{"t"})(\.{"o"})(\\{goto\_like})$;\6
$\\{id2}(\.{"i"})(\.{"f"})(\\{if\_like})$;\6
$\\{id2}(\.{"i"})(\.{"n"})(\\{char\_like}+\\{set\_element\_sign})$;\6
$\\{id5}(\.{"l"})(\.{"a"})(\.{"b"})(\.{"e"})(\.{"l"})(\\{const\_like})$;\6
$\\{id3}(\.{"m"})(\.{"o"})(\.{"d"})(\\{div\_like})$;\6
$\\{id3}(\.{"n"})(\.{"i"})(\.{"l"})(\\{nil\_like})$;\6
$\\{id3}(\.{"n"})(\.{"o"})(\.{"t"})(\\{char\_like}+\\{not\_sign})$;\6
$\\{id2}(\.{"o"})(\.{"f"})(\\{do\_like})$;\6
$\\{id2}(\.{"o"})(\.{"r"})(\\{char\_like}+\\{or\_sign})$;\6
$\\{id6}(\.{"p"})(\.{"a"})(\.{"c"})(\.{"k"})(\.{"e"})(\.{"d"})(\\{goto%
\_like})$;\6
$\\{id9}(\.{"p"})(\.{"r"})(\.{"o"})(\.{"c"})(\.{"e"})(\.{"d"})(\.{"u"})(%
\.{"r"})(\.{"e"})(\\{proc\_like})$;\6
$\\{id7}(\.{"p"})(\.{"r"})(\.{"o"})(\.{"g"})(\.{"r"})(\.{"a"})(\.{"m"})(\\{proc%
\_like})$;\6
$\\{id6}(\.{"r"})(\.{"e"})(\.{"c"})(\.{"o"})(\.{"r"})(\.{"d"})(\\{record%
\_like})$;\6
$\\{id6}(\.{"r"})(\.{"e"})(\.{"p"})(\.{"e"})(\.{"a"})(\.{"t"})(\\{repeat%
\_like})$;\6
$\\{id3}(\.{"s"})(\.{"e"})(\.{"t"})(\\{array\_like})$;\6
$\\{id4}(\.{"t"})(\.{"h"})(\.{"e"})(\.{"n"})(\\{do\_like})$;\6
$\\{id2}(\.{"t"})(\.{"o"})(\\{to\_like})$;\6
$\\{id4}(\.{"t"})(\.{"y"})(\.{"p"})(\.{"e"})(\\{const\_like})$;\6
$\\{id5}(\.{"u"})(\.{"n"})(\.{"t"})(\.{"i"})(\.{"l"})(\\{until\_like})$;\6
$\\{id3}(\.{"v"})(\.{"a"})(\.{"r"})(\\{var\_like})$;\6
$\\{id5}(\.{"w"})(\.{"h"})(\.{"i"})(\.{"l"})(\.{"e"})(\\{for\_like})$;\6
$\\{id4}(\.{"w"})(\.{"i"})(\.{"t"})(\.{"h"})(\\{for\_like})$;\6
$\\{id7}(\.{"x"})(\.{"c"})(\.{"l"})(\.{"a"})(\.{"u"})(\.{"s"})(\.{"e"})(\\{loop%
\_like})$;\par
\U261.\fi

\N65.  Searching for module names.
The \\{mod\_lookup} procedure finds the module name $\\{mod\_text}[1\to\|l]$ in
the
search tree, after inserting it if necessary, and returns a pointer to
where it was found.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{mod\_text}: \37\&{array} $[0\to\\{longest\_name}]$ \1\&{of}\5
\\{ASCII\_code};\C{name being sought for}\2\par
\fi

\M66. According to the rules of \.{WEB}, no module name
should be a proper prefix of another, so a ``clean'' comparison should
occur between any two names. The result of \\{mod\_lookup} is 0 if this
prefix condition is violated. An error message is printed when such violations
are detected during phase two of \.{WEAVE}.

\Y\P\D \37$\\{less}=0$\C{the first name is lexicographically less than the
second}\par
\P\D \37$\\{equal}=1$\C{the first name is equal to the second}\par
\P\D \37$\\{greater}=2$\C{the first name is lexicographically greater than the
second}\par
\P\D \37$\\{prefix}=3$\C{the first name is a proper prefix of the second}\par
\P\D \37$\\{extension}=4$\C{the first name is a proper extension of the second}%
\par
\Y\P\4\&{function}\1\  \37$\\{mod\_lookup}(\|l:\\{sixteen\_bits})$: \37\\{name%
\_pointer};\C{finds module name}\6
\4\&{label} \37\\{found};\6
\4\&{var} \37\|c: \37$\\{less}\to\\{extension}$;\C{comparison between two
names}\6
\|j: \37$0\to\\{longest\_name}$;\C{index into \\{mod\_text}}\6
\|k: \37$0\to\\{max\_bytes}$;\C{index into \\{byte\_mem}}\6
\|w: \37$0\to\\{ww}-1$;\C{row of \\{byte\_mem}}\6
\|p: \37\\{name\_pointer};\C{current node of the search tree}\6
\|q: \37\\{name\_pointer};\C{father of node \|p}\2\6
\&{begin} \37$\|c\K\\{greater}$;\5
$\|q\K0$;\5
$\|p\K\\{root}$;\6
\&{while} $\|p\I0$ \1\&{do}\6
\&{begin} \37\X68:Set variable \|c to the result of comparing the given name to
name \|p\X;\6
$\|q\K\|p$;\6
\&{if} $\|c=\\{less}$ \1\&{then}\5
$\|p\K\\{llink}[\|q]$\6
\4\&{else} \&{if} $\|c=\\{greater}$ \1\&{then}\5
$\|p\K\\{rlink}[\|q]$\6
\4\&{else} \&{goto} \37\\{found};\2\2\6
\&{end};\2\6
\X67:Enter a new module name into the tree\X;\6
\4\\{found}: \37\&{if} $\|c\I\\{equal}$ \1\&{then}\6
\&{begin} \37$\\{err\_print}(\.{\'!\ Incompatible\ section\ names\'})$;\5
$\|p\K0$;\6
\&{end};\2\6
$\\{mod\_lookup}\K\|p$;\6
\&{end};\par
\fi

\M67. \P$\X67:Enter a new module name into the tree\X\S$\6
$\|w\K\\{name\_ptr}\mathbin{\&{mod}}\\{ww}$;\5
$\|k\K\\{byte\_ptr}[\|w]$;\6
\&{if} $\|k+\|l>\\{max\_bytes}$ \1\&{then}\5
$\\{overflow}(\.{\'byte\ memory\'})$;\2\6
\&{if} $\\{name\_ptr}>\\{max\_names}-\\{ww}$ \1\&{then}\5
$\\{overflow}(\.{\'name\'})$;\2\6
$\|p\K\\{name\_ptr}$;\6
\&{if} $\|c=\\{less}$ \1\&{then}\5
$\\{llink}[\|q]\K\|p$\6
\4\&{else} $\\{rlink}[\|q]\K\|p$;\2\6
$\\{llink}[\|p]\K0$;\5
$\\{rlink}[\|p]\K0$;\5
$\\{xref}[\|p]\K0$;\5
$\|c\K\\{equal}$;\6
\&{for} $\|j\K1\mathrel{\&{to}}\|l$ \1\&{do}\5
$\\{byte\_mem}[\|w,\39\|k+\|j-1]\K\\{mod\_text}[\|j]$;\2\6
$\\{byte\_ptr}[\|w]\K\|k+\|l$;\5
$\\{byte\_start}[\\{name\_ptr}+\\{ww}]\K\|k+\|l$;\5
$\\{incr}(\\{name\_ptr})$;\par
\U66.\fi

\M68. \P$\X68:Set variable \|c to the result of comparing the given name to
name \|p\X\S$\6
\&{begin} \37$\|k\K\\{byte\_start}[\|p]$;\5
$\|w\K\|p\mathbin{\&{mod}}\\{ww}$;\5
$\|c\K\\{equal}$;\5
$\|j\K1$;\6
\&{while} $(\|k<\\{byte\_start}[\|p+\\{ww}])\W(\|j\L\|l)\W(\\{mod\_text}[\|j]=%
\\{byte\_mem}[\|w,\39\|k])$ \1\&{do}\6
\&{begin} \37$\\{incr}(\|k)$;\5
$\\{incr}(\|j)$;\6
\&{end};\2\6
\&{if} $\|k=\\{byte\_start}[\|p+\\{ww}]$ \1\&{then}\6
\&{if} $\|j>\|l$ \1\&{then}\5
$\|c\K\\{equal}$\6
\4\&{else} $\|c\K\\{extension}$\2\6
\4\&{else} \&{if} $\|j>\|l$ \1\&{then}\5
$\|c\K\\{prefix}$\6
\4\&{else} \&{if} $\\{mod\_text}[\|j]<\\{byte\_mem}[\|w,\39\|k]$ \1\&{then}\5
$\|c\K\\{less}$\6
\4\&{else} $\|c\K\\{greater}$;\2\2\2\6
\&{end}\par
\Us66\ET69.\fi

\M69. The \\{prefix\_lookup} procedure is supposed to find exactly one module
name that has $\\{mod\_text}[1\to\|l]$ as a prefix. Actually the algorithm
silently accepts also the situation that some module name is a prefix of
$\\{mod\_text}[1\to\|l]$, because the user who painstakingly typed in more than
necessary probably doesn't want to be told about the wasted effort.

Recall that error messages are not printed during phase one. It is
possible that the \\{prefix\_lookup} procedure will fail on the first pass,
because there is no match, yet the second pass might detect no error if a
matching module name has occurred after the offending prefix. In such a
case the cross-reference information will be incorrect and \.{WEAVE} will
report no error. However, such a mistake will be detected by the
\.{TANGLE} processor.

\Y\P\4\&{function}\1\  \37$\\{prefix\_lookup}(\|l:\\{sixteen\_bits})$: \37%
\\{name\_pointer};\C{finds name extension}\6
\4\&{var} \37\|c: \37$\\{less}\to\\{extension}$;\C{comparison between two
names}\6
\\{count}: \37$0\to\\{max\_names}$;\C{the number of hits}\6
\|j: \37$0\to\\{longest\_name}$;\C{index into \\{mod\_text}}\6
\|k: \37$0\to\\{max\_bytes}$;\C{index into \\{byte\_mem}}\6
\|w: \37$0\to\\{ww}-1$;\C{row of \\{byte\_mem}}\6
\|p: \37\\{name\_pointer};\C{current node of the search tree}\6
\|q: \37\\{name\_pointer};\C{another place to resume the search after one
branch is done}\6
\|r: \37\\{name\_pointer};\C{extension found}\2\6
\&{begin} \37$\|q\K0$;\5
$\|p\K\\{root}$;\5
$\\{count}\K0$;\5
$\|r\K0$;\C{begin search at root of tree}\6
\&{while} $\|p\I0$ \1\&{do}\6
\&{begin} \37\X68:Set variable \|c to the result of comparing the given name to
name \|p\X;\6
\&{if} $\|c=\\{less}$ \1\&{then}\5
$\|p\K\\{llink}[\|p]$\6
\4\&{else} \&{if} $\|c=\\{greater}$ \1\&{then}\5
$\|p\K\\{rlink}[\|p]$\6
\4\&{else} \&{begin} \37$\|r\K\|p$;\5
$\\{incr}(\\{count})$;\5
$\|q\K\\{rlink}[\|p]$;\5
$\|p\K\\{llink}[\|p]$;\6
\&{end};\2\2\6
\&{if} $\|p=0$ \1\&{then}\6
\&{begin} \37$\|p\K\|q$;\5
$\|q\K0$;\6
\&{end};\2\6
\&{end};\2\6
\&{if} $\\{count}\I1$ \1\&{then}\6
\&{if} $\\{count}=0$ \1\&{then}\5
$\\{err\_print}(\.{\'!\ Name\ does\ not\ match\'})$\6
\4\&{else} $\\{err\_print}(\.{\'!\ Ambiguous\ prefix\'})$;\2\2\6
$\\{prefix\_lookup}\K\|r$;\C{the result will be 0 if there was no match}\6
\&{end};\par
\fi

\N70.  Lexical scanning.
Let us now consider the subroutines that read the \.{WEB} source file
and break it into meaningful units. There are four such procedures:
One simply skips to the next `\.{@\ }' or `\.{@*}' that begins a
module; another passes over the \TeX\ text at the beginning of a
module; the third passes over the \TeX\ text in a \PASCAL\ comment;
and the last, which is the most interesting, gets the next token of
a \PASCAL\ text.

\fi

\M71. But first we need to consider the low-level routine \\{get\_line}
that takes care of merging \\{change\_file} into \\{web\_file}. The \\{get%
\_line}
procedure also updates the line numbers for error messages.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{ii}: \37\\{integer};\C{general purpose  \&{for}  loop variable in the
outer block}\6
\4\\{line}: \37\\{integer};\C{the number of the current line in the current
file}\6
\4\\{other\_line}: \37\\{integer};\C{the number of the current line in the
input file that   is not currently being read}\6
\4\\{temp\_line}: \37\\{integer};\C{used when interchanging \\{line} with %
\\{other\_line}}\6
\4\\{limit}: \37$0\to\\{long\_buf\_size}$;\C{the last character position
occupied in the buffer}\6
\4\\{loc}: \37$0\to\\{long\_buf\_size}$;\C{the next character position to be
read from the buffer}\6
\4\\{input\_has\_ended}: \37\\{boolean};\C{if \\{true}, there is no more input}%
\6
\4\\{changing}: \37\\{boolean};\C{if \\{true}, the current line is from %
\\{change\_file}}\6
\4\\{change\_pending}: \37\\{boolean};\C{if \\{true}, the current change is not
yet   recorded in $\\{changed\_module}[\\{module\_count}]$}\par
\fi

\M72. As we change \\{changing} from \\{true} to \\{false} and back again, we
must
remember to swap the values of \\{line} and \\{other\_line} so that the \\{err%
\_print}
routine will be sure to report the correct line number.

\Y\P\D \37$\\{change\_changing}\S\\{changing}\K\R\\{changing}$;\5
$\\{temp\_line}\K\\{other\_line}$;\5
$\\{other\_line}\K\\{line}$;\5
$\\{line}\K\\{temp\_line}$\C{\\{line}\hbox{$\null\BA\null$}\\{other\_line}}\par
\fi

\M73. When \\{changing} is \\{false}, the next line of \\{change\_file} is kept
in
$\\{change\_buffer}[0\to\\{change\_limit}]$, for purposes of comparison with
the next
line of \\{web\_file}. After the change file has been completely input, we
set $\\{change\_limit}\K0$, so that no further matches will be made.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{change\_buffer}: \37\&{array} $[0\to\\{buf\_size}]$ \1\&{of}\5
\\{ASCII\_code};\2\6
\4\\{change\_limit}: \37$0\to\\{buf\_size}$;\C{the last position occupied in %
\\{change\_buffer}}\par
\fi

\M74. Here's a simple function that checks if the two buffers are different.

\Y\P\4\&{function}\1\  \37\\{lines\_dont\_match}: \37\\{boolean};\6
\4\&{label} \37\\{exit};\6
\4\&{var} \37\|k: \37$0\to\\{buf\_size}$;\C{index into the buffers}\2\6
\&{begin} \37$\\{lines\_dont\_match}\K\\{true}$;\6
\&{if} $\\{change\_limit}\I\\{limit}$ \1\&{then}\5
\&{return};\2\6
\&{if} $\\{limit}>0$ \1\&{then}\6
\&{for} $\|k\K0\mathrel{\&{to}}\\{limit}-1$ \1\&{do}\6
\&{if} $\\{change\_buffer}[\|k]\I\\{buffer}[\|k]$ \1\&{then}\5
\&{return};\2\2\2\6
$\\{lines\_dont\_match}\K\\{false}$;\6
\4\\{exit}: \37\&{end};\par
\fi

\M75. Procedure \\{prime\_the\_change\_buffer} sets \\{change\_buffer} in
preparation
for the next matching operation. Since blank lines in the change file are
not used for matching, we have $(\\{change\_limit}=0)\W\R\\{changing}$ if and
only if the change file is exhausted. This procedure is called only
when \\{changing} is true; hence error messages will be reported correctly.

\Y\P\4\&{procedure}\1\  \37\\{prime\_the\_change\_buffer};\6
\4\&{label} \37$\\{continue},\39\\{done},\39\\{exit}$;\6
\4\&{var} \37\|k: \37$0\to\\{buf\_size}$;\C{index into the buffers}\2\6
\&{begin} \37$\\{change\_limit}\K0$;\C{this value will be used if the change
file ends}\6
\X76:Skip over comment lines in the change file; \&{return} if end of file\X;\6
\X77:Skip to the next nonblank line; \&{return} if end of file\X;\6
\X78:Move \\{buffer} and \\{limit} to \\{change\_buffer} and \\{change\_limit}%
\X;\6
\4\\{exit}: \37\&{end};\par
\fi

\M76. While looking for a line that begins with \.{@x} in the change file,
we allow lines that begin with \.{@}, as long as they don't begin with
\.{@y} or \.{@z} (which would probably indicate that the change file is
fouled up).

\Y\P$\4\X76:Skip over comment lines in the change file; \&{return} if end of
file\X\S$\6
\~ \1\&{loop}\ \&{begin} \37$\\{incr}(\\{line})$;\6
\&{if} $\R\\{input\_ln}(\\{change\_file})$ \1\&{then}\5
\&{return};\2\6
\&{if} $\\{limit}<2$ \1\&{then}\5
\&{goto} \37\\{continue};\2\6
\&{if} $\\{buffer}[0]\I\.{"@"}$ \1\&{then}\5
\&{goto} \37\\{continue};\2\6
\&{if} $(\\{buffer}[1]\G\.{"X"})\W(\\{buffer}[1]\L\.{"Z"})$ \1\&{then}\5
$\\{buffer}[1]\K\\{buffer}[1]+\.{"z"}-\.{"Z"}$;\C{lowercasify}\2\6
\&{if} $\\{buffer}[1]=\.{"x"}$ \1\&{then}\5
\&{goto} \37\\{done};\2\6
\&{if} $(\\{buffer}[1]=\.{"y"})\V(\\{buffer}[1]=\.{"z"})$ \1\&{then}\6
\&{begin} \37$\\{loc}\K2$;\5
$\\{err\_print}(\.{\'!\ Where\ is\ the\ matching\ @x?\'})$;\6
\&{end};\2\6
\4\\{continue}: \37\&{end};\2\6
\4\\{done}: \37\par
\U75.\fi

\M77. Here we are looking at lines following the \.{@x}.

\Y\P$\4\X77:Skip to the next nonblank line; \&{return} if end of file\X\S$\6
\1\&{repeat} \37$\\{incr}(\\{line})$;\6
\&{if} $\R\\{input\_ln}(\\{change\_file})$ \1\&{then}\6
\&{begin} \37$\\{err\_print}(\.{\'!\ Change\ file\ ended\ after\ @x\'})$;\5
\&{return};\6
\&{end};\2\6
\4\&{until}\5
$\\{limit}>0$;\2\par
\U75.\fi

\M78. \P$\X78:Move \\{buffer} and \\{limit} to \\{change\_buffer} and \\{change%
\_limit}\X\S$\6
\&{begin} \37$\\{change\_limit}\K\\{limit}$;\6
\&{if} $\\{limit}>0$ \1\&{then}\6
\&{for} $\|k\K0\mathrel{\&{to}}\\{limit}-1$ \1\&{do}\5
$\\{change\_buffer}[\|k]\K\\{buffer}[\|k]$;\2\2\6
\&{end}\par
\Us75\ET79.\fi

\M79. The following procedure is used to see if the next change entry should
go into effect; it is called only when \\{changing} is false.
The idea is to test whether or not the current
contents of \\{buffer} matches the current contents of \\{change\_buffer}.
If not, there's nothing more to do; but if so, a change is called for:
All of the text down to the \.{@y} is supposed to match. An error
message is issued if any discrepancy is found. Then the procedure
prepares to read the next line from \\{change\_file}.

When a match is found, the current module is marked as changed unless
the first line after the \.{@x} and after the \.{@y} both start with
either \.{\'@*\'} or \.{\'@\ \'} (possibly preceded by whitespace).

\Y\P\D \37$\\{if\_module\_start\_then\_make\_change\_pending}(\#)\S\\{loc}\K0$;%
\5
$\\{buffer}[\\{limit}]\K\.{"!"}$;\6
\&{while} $(\\{buffer}[\\{loc}]=\.{"\ "})\V(\\{buffer}[\\{loc}]=\\{tab\_mark})$
\1\&{do}\5
$\\{incr}(\\{loc})$;\2\6
$\\{buffer}[\\{limit}]\K\.{"\ "}$;\6
\&{if} $\\{buffer}[\\{loc}]=\.{"@"}$ \1\&{then}\6
\&{if} $(\\{buffer}[\\{loc}+1]=\.{"*"})\V(\\{buffer}[\\{loc}+1]=\.{"\ "})\V(%
\\{buffer}[\\{loc}+1]=\\{tab\_mark})$ \1\&{then}\5
$\\{change\_pending}\K\#$\2\2\par
\Y\P\4\&{procedure}\1\  \37\\{check\_change};\C{switches to \\{change\_file} if
the buffers match}\6
\4\&{label} \37\\{exit};\6
\4\&{var} \37\|n: \37\\{integer};\C{the number of discrepancies found}\6
\|k: \37$0\to\\{buf\_size}$;\C{index into the buffers}\2\6
\&{begin} \37\&{if} $\\{lines\_dont\_match}$ \1\&{then}\5
\&{return};\2\6
$\\{change\_pending}\K\\{false}$;\6
\&{if} $\R\\{changed\_module}[\\{module\_count}]$ \1\&{then}\6
\&{begin} \37$\\{if\_module\_start\_then\_make\_change\_pending}(\\{true})$;\6
\&{if} $\R\\{change\_pending}$ \1\&{then}\5
$\\{changed\_module}[\\{module\_count}]\K\\{true}$;\2\6
\&{end};\2\6
$\|n\K0$;\6
\~ \1\&{loop}\ \&{begin} \37\\{change\_changing};\C{now it's \\{true}}\6
$\\{incr}(\\{line})$;\6
\&{if} $\R\\{input\_ln}(\\{change\_file})$ \1\&{then}\6
\&{begin} \37$\\{err\_print}(\.{\'!\ Change\ file\ ended\ before\ @y\'})$;\5
$\\{change\_limit}\K0$;\5
\\{change\_changing};\C{\\{false} again}\6
\&{return};\6
\&{end};\2\6
\X80:If the current line starts with \.{@y}, report any discrepancies and %
\&{return}\X;\6
\X78:Move \\{buffer} and \\{limit} to \\{change\_buffer} and \\{change\_limit}%
\X;\6
\\{change\_changing};\C{now it's \\{false}}\6
$\\{incr}(\\{line})$;\6
\&{if} $\R\\{input\_ln}(\\{web\_file})$ \1\&{then}\6
\&{begin} \37$\\{err\_print}(\.{\'!\ WEB\ file\ ended\ during\ a\ change\'})$;\5
$\\{input\_has\_ended}\K\\{true}$;\5
\&{return};\6
\&{end};\2\6
\&{if} $\\{lines\_dont\_match}$ \1\&{then}\5
$\\{incr}(\|n)$;\2\6
\&{end};\2\6
\4\\{exit}: \37\&{end};\par
\fi

\M80. \P$\X80:If the current line starts with \.{@y}, report any discrepancies
and \&{return}\X\S$\6
\&{if} $\\{limit}>1$ \1\&{then}\6
\&{if} $\\{buffer}[0]=\.{"@"}$ \1\&{then}\6
\&{begin} \37\&{if} $(\\{buffer}[1]\G\.{"X"})\W(\\{buffer}[1]\L\.{"Z"})$ \1%
\&{then}\5
$\\{buffer}[1]\K\\{buffer}[1]+\.{"z"}-\.{"Z"}$;\C{lowercasify}\2\6
\&{if} $(\\{buffer}[1]=\.{"x"})\V(\\{buffer}[1]=\.{"z"})$ \1\&{then}\6
\&{begin} \37$\\{loc}\K2$;\5
$\\{err\_print}(\.{\'!\ Where\ is\ the\ matching\ @y?\'})$;\6
\&{end}\6
\4\&{else} \&{if} $\\{buffer}[1]=\.{"y"}$ \1\&{then}\6
\&{begin} \37\&{if} $\|n>0$ \1\&{then}\6
\&{begin} \37$\\{loc}\K2$;\5
$\\{err\_print}(\.{\'!\ Hmm...\ \'},\39\|n:1,\39\.{\'\ of\ the\ preceding\
lines\ failed\ to\ match\'})$;\6
\&{end};\2\6
\&{return};\6
\&{end};\2\2\6
\&{end}\2\2\par
\U79.\fi

\M81. The \\{reset\_input} procedure, which gets \.{WEAVE} ready to read the
user's \.{WEB} input, is used at the beginning of phases one and two.

\Y\P\4\&{procedure}\1\  \37\\{reset\_input};\2\6
\&{begin} \37\\{open\_input};\5
$\\{line}\K0$;\5
$\\{other\_line}\K0$;\6
$\\{changing}\K\\{true}$;\5
\\{prime\_the\_change\_buffer};\5
\\{change\_changing};\6
$\\{limit}\K0$;\5
$\\{loc}\K1$;\5
$\\{buffer}[0]\K\.{"\ "}$;\5
$\\{input\_has\_ended}\K\\{false}$;\6
\&{end};\par
\fi

\M82. The \\{get\_line} procedure is called when $\\{loc}>\\{limit}$; it puts
the next
line of merged input into the buffer and updates the other variables
appropriately. A space is placed at the right end of the line.

\Y\P\4\&{procedure}\1\  \37\\{get\_line};\C{inputs the next line}\6
\4\&{label} \37\\{restart};\2\6
\&{begin} \37\\{restart}: \37\&{if} $\\{changing}$ \1\&{then}\5
\X84:Read from \\{change\_file} and maybe turn off \\{changing}\X;\2\6
\&{if} $\R\\{changing}$ \1\&{then}\6
\&{begin} \37\X83:Read from \\{web\_file} and maybe turn on \\{changing}\X;\6
\&{if} $\\{changing}$ \1\&{then}\5
\&{goto} \37\\{restart};\2\6
\&{end};\2\6
$\\{loc}\K0$;\5
$\\{buffer}[\\{limit}]\K\.{"\ "}$;\6
\&{end};\par
\fi

\M83. \P$\X83:Read from \\{web\_file} and maybe turn on \\{changing}\X\S$\6
\&{begin} \37$\\{incr}(\\{line})$;\6
\&{if} $\R\\{input\_ln}(\\{web\_file})$ \1\&{then}\5
$\\{input\_has\_ended}\K\\{true}$\6
\4\&{else} \&{if} $\\{limit}=\\{change\_limit}$ \1\&{then}\6
\&{if} $\\{buffer}[0]=\\{change\_buffer}[0]$ \1\&{then}\6
\&{if} $\\{change\_limit}>0$ \1\&{then}\5
\\{check\_change};\2\2\2\2\6
\&{end}\par
\U82.\fi

\M84. \P$\X84:Read from \\{change\_file} and maybe turn off \\{changing}\X\S$\6
\&{begin} \37$\\{incr}(\\{line})$;\6
\&{if} $\R\\{input\_ln}(\\{change\_file})$ \1\&{then}\6
\&{begin} \37$\\{err\_print}(\.{\'!\ Change\ file\ ended\ without\ @z\'})$;\5
$\\{buffer}[0]\K\.{"@"}$;\5
$\\{buffer}[1]\K\.{"z"}$;\5
$\\{limit}\K2$;\6
\&{end};\2\6
\&{if} $\\{limit}>0$ \1\&{then}\C{check if the change has ended}\6
\&{begin} \37\&{if} $\\{change\_pending}$ \1\&{then}\6
\&{begin} \37$\\{if\_module\_start\_then\_make\_change\_pending}(\\{false})$;\6
\&{if} $\\{change\_pending}$ \1\&{then}\6
\&{begin} \37$\\{changed\_module}[\\{module\_count}]\K\\{true}$;\5
$\\{change\_pending}\K\\{false}$;\6
\&{end};\2\6
\&{end};\2\6
$\\{buffer}[\\{limit}]\K\.{"\ "}$;\6
\&{if} $\\{buffer}[0]=\.{"@"}$ \1\&{then}\6
\&{begin} \37\&{if} $(\\{buffer}[1]\G\.{"X"})\W(\\{buffer}[1]\L\.{"Z"})$ \1%
\&{then}\5
$\\{buffer}[1]\K\\{buffer}[1]+\.{"z"}-\.{"Z"}$;\C{lowercasify}\2\6
\&{if} $(\\{buffer}[1]=\.{"x"})\V(\\{buffer}[1]=\.{"y"})$ \1\&{then}\6
\&{begin} \37$\\{loc}\K2$;\5
$\\{err\_print}(\.{\'!\ Where\ is\ the\ matching\ @z?\'})$;\6
\&{end}\6
\4\&{else} \&{if} $\\{buffer}[1]=\.{"z"}$ \1\&{then}\6
\&{begin} \37\\{prime\_the\_change\_buffer};\5
\\{change\_changing};\6
\&{end};\2\2\6
\&{end};\2\6
\&{end};\2\6
\&{end}\par
\U82.\fi

\M85. At the end of the program, we will tell the user if the change file
had a line that didn't match any relevant line in \\{web\_file}.

\Y\P$\4\X85:Check that all changes have been read\X\S$\6
\&{if} $\\{change\_limit}\I0$ \1\&{then}\C{\\{changing} is false}\6
\&{begin} \37\&{for} $\\{ii}\K0\mathrel{\&{to}}\\{change\_limit}$ \1\&{do}\5
$\\{buffer}[\\{ii}]\K\\{change\_buffer}[\\{ii}]$;\2\6
$\\{limit}\K\\{change\_limit}$;\5
$\\{changing}\K\\{true}$;\5
$\\{line}\K\\{other\_line}$;\5
$\\{loc}\K\\{change\_limit}$;\5
$\\{err\_print}(\.{\'!\ Change\ file\ entry\ did\ not\ match\'})$;\6
\&{end}\2\par
\U261.\fi

\M86. Control codes in \.{WEB}, which begin with `\.{@}', are converted
into a numeric code designed to simplify \.{WEAVE}'s logic; for example,
larger numbers are given to the control codes that denote more significant
milestones, and the code of \\{new\_module} should be the largest of
all. Some of these numeric control codes take the place of ASCII
control codes that will not otherwise appear in the output of the
scanning routines.

\Y\P\D \37$\\{ignore}=0$\C{control code of no interest to \.{WEAVE}}\par
\P\D \37$\\{verbatim}=\O{2}$\C{extended ASCII alpha will not appear}\par
\P\D \37$\\{force\_line}=\O{3}$\C{extended ASCII beta will not appear}\par
\P\D \37$\\{begin\_comment}=\O{11}$\C{ASCII tab mark will not appear}\par
\P\D \37$\\{end\_comment}=\O{12}$\C{ASCII line feed will not appear}\par
\P\D \37$\\{octal}=\O{14}$\C{ASCII form feed will not appear}\par
\P\D \37$\\{hex}=\O{15}$\C{ASCII carriage return will not appear}\par
\P\D \37$\\{double\_dot}=\O{40}$\C{ASCII space will not appear except in
strings}\par
\P\D \37$\\{no\_underline}=\O{175}$\C{this code will be intercepted without
confusion}\par
\P\D \37$\\{underline}=\O{176}$\C{this code will be intercepted without
confusion}\par
\P\D \37$\\{param}=\O{177}$\C{ASCII delete will not appear}\par
\P\D \37$\\{xref\_roman}=\O{203}$\C{control code for `\.{@\^}'}\par
\P\D \37$\\{xref\_wildcard}=\O{204}$\C{control code for `\.{@:}'}\par
\P\D \37$\\{xref\_typewriter}=\O{205}$\C{control code for `\.{@.}'}\par
\P\D \37$\\{TeX\_string}=\O{206}$\C{control code for `\.{@t}'}\par
\P\D \37$\\{check\_sum}=\O{207}$\C{control code for `\.{@\$}'}\par
\P\D \37$\\{join}=\O{210}$\C{control code for `\.{@\&}'}\par
\P\D \37$\\{thin\_space}=\O{211}$\C{control code for `\.{@,}'}\par
\P\D \37$\\{math\_break}=\O{212}$\C{control code for `\.{@\char'174}'}\par
\P\D \37$\\{line\_break}=\O{213}$\C{control code for `\.{@/}'}\par
\P\D \37$\\{big\_line\_break}=\O{214}$\C{control code for `\.{@\#}'}\par
\P\D \37$\\{no\_line\_break}=\O{215}$\C{control code for `\.{@+}'}\par
\P\D \37$\\{pseudo\_semi}=\O{216}$\C{control code for `\.{@;}'}\par
\P\D \37$\\{format}=\O{217}$\C{control code for `\.{@f}'}\par
\P\D \37$\\{definition}=\O{220}$\C{control code for `\.{@d}'}\par
\P\D \37$\\{begin\_Pascal}=\O{221}$\C{control code for `\.{@p}'}\par
\P\D \37$\\{module\_name}=\O{222}$\C{control code for `\.{@<}'}\par
\P\D \37$\\{new\_module}=\O{223}$\C{control code for `\.{@\ }' and `\.{@*}'}\par
\fi

\M87. Control codes are converted from ASCII to \.{WEAVE}'s internal
representation by the \\{control\_code} routine.

\Y\P\4\&{function}\1\  \37$\\{control\_code}(\|c:\\{ASCII\_code})$: \37\\{eight%
\_bits};\C{convert \|c   after \.{@}}\2\6
\&{begin} \37\&{case} $\|c$ \1\&{of}\6
\4\.{"@"}: \37$\\{control\_code}\K\.{"@"}$;\C{`quoted' at sign}\6
\4\.{"\'"}: \37$\\{control\_code}\K\\{octal}$;\C{precedes octal constant}\6
\4\.{""}\.{""}: \37$\\{control\_code}\K\\{hex}$;\C{precedes hexadecimal
constant}\6
\4\.{"\$"}: \37$\\{control\_code}\K\\{check\_sum}$;\C{precedes check sum
constant}\6
\4$\.{"\ "},\39\\{tab\_mark},\39\.{"*"}$: \37$\\{control\_code}\K\\{new%
\_module}$;\C{beginning of a new module}\6
\4\.{"="}: \37$\\{control\_code}\K\\{verbatim}$;\6
\4\.{"\\"}: \37$\\{control\_code}\K\\{force\_line}$;\6
\4$\.{"D"},\39\.{"d"}$: \37$\\{control\_code}\K\\{definition}$;\C{macro
definition}\6
\4$\.{"F"},\39\.{"f"}$: \37$\\{control\_code}\K\\{format}$;\C{format
definition}\6
\4\.{"\{"}: \37$\\{control\_code}\K\\{begin\_comment}$;\C{begin-comment
delimiter}\6
\4\.{"\}"}: \37$\\{control\_code}\K\\{end\_comment}$;\C{end-comment delimiter}\6
\4$\.{"P"},\39\.{"p"}$: \37$\\{control\_code}\K\\{begin\_Pascal}$;\C{\PASCAL\
text in unnamed module}\6
\4\.{"\&"}: \37$\\{control\_code}\K\\{join}$;\C{concatenate two tokens}\6
\4\.{"<"}: \37$\\{control\_code}\K\\{module\_name}$;\C{beginning of a module
name}\6
\4\.{">"}: \37\&{begin} \37$\\{err\_print}(\.{\'!\ Extra\ @>\'})$;\5
$\\{control\_code}\K\\{ignore}$;\6
\&{end};\C{end of module name should not be discovered in this way}\6
\4$\.{"T"},\39\.{"t"}$: \37$\\{control\_code}\K\\{TeX\_string}$;\C{\TeX\ box
within \PASCAL}\6
\4\.{"!"}: \37$\\{control\_code}\K\\{underline}$;\C{set definition flag}\6
\4\.{"?"}: \37$\\{control\_code}\K\\{no\_underline}$;\C{reset definition flag}\6
\4\.{"\^"}: \37$\\{control\_code}\K\\{xref\_roman}$;\C{index entry to be
typeset normally}\6
\4\.{":"}: \37$\\{control\_code}\K\\{xref\_wildcard}$;\C{index entry to be in
user format}\6
\4\.{"."}: \37$\\{control\_code}\K\\{xref\_typewriter}$;\C{index entry to be in
typewriter type}\6
\4\.{","}: \37$\\{control\_code}\K\\{thin\_space}$;\C{puts extra space in %
\PASCAL\ format}\6
\4\.{"|"}: \37$\\{control\_code}\K\\{math\_break}$;\C{allows a break in a
formula}\6
\4\.{"/"}: \37$\\{control\_code}\K\\{line\_break}$;\C{forces end-of-line in %
\PASCAL\ format}\6
\4\.{"\#"}: \37$\\{control\_code}\K\\{big\_line\_break}$;\C{forces end-of-line
and some space besides}\6
\4\.{"+"}: \37$\\{control\_code}\K\\{no\_line\_break}$;\C{cancels end-of-line
down to single space}\6
\4\.{";"}: \37$\\{control\_code}\K\\{pseudo\_semi}$;\C{acts like a semicolon,
but is invisible}\6
\hbox{\4}\X88:Special control codes allowed only when debugging\X\6
\4\&{othercases} \37\&{begin} \37$\\{err\_print}(\.{\'!\ Unknown\ control\ code%
\'})$;\5
$\\{control\_code}\K\\{ignore}$;\6
\&{end}\2\6
\&{endcases};\6
\&{end};\par
\fi

\M88. If \.{WEAVE} is compiled with debugging commands, one can write
\.{@2}, \.{@1}, and \.{@0} to turn tracing fully on, partly on,
and off, respectively.

\Y\P$\4\X88:Special control codes allowed only when debugging\X\S$\6
\&{debug} \37\hbox{}\6
\4$\.{"0"},\39\.{"1"},\39\.{"2"}$: \37\&{begin} \37$\\{tracing}\K\|c-\.{"0"}$;\5
$\\{control\_code}\K\\{ignore}$;\6
\&{end};\6
\&{gubed}\par
\U87.\fi

\M89. The \\{skip\_limbo} routine is used on the first pass to skip through
portions of the input that are not in any modules, i.e., that precede
the first module. After this procedure has been called, the value of
\\{input\_has\_ended} will tell whether or not a new module has
actually been found.

\Y\P\4\&{procedure}\1\  \37\\{skip\_limbo};\C{skip to next module}\6
\4\&{label} \37\\{exit};\6
\4\&{var} \37\|c: \37\\{ASCII\_code};\C{character following \.{@}}\2\6
\&{begin} \37\~ \1\&{loop}\6
\&{if} $\\{loc}>\\{limit}$ \1\&{then}\6
\&{begin} \37\\{get\_line};\6
\&{if} $\\{input\_has\_ended}$ \1\&{then}\5
\&{return};\2\6
\&{end}\6
\4\&{else} \&{begin} \37$\\{buffer}[\\{limit}+1]\K\.{"@"}$;\6
\&{while} $\\{buffer}[\\{loc}]\I\.{"@"}$ \1\&{do}\5
$\\{incr}(\\{loc})$;\2\6
\&{if} $\\{loc}\L\\{limit}$ \1\&{then}\6
\&{begin} \37$\\{loc}\K\\{loc}+2$;\5
$\|c\K\\{buffer}[\\{loc}-1]$;\6
\&{if} $(\|c=\.{"\ "})\V(\|c=\\{tab\_mark})\V(\|c=\.{"*"})$ \1\&{then}\5
\&{return};\2\6
\&{end};\2\6
\&{end};\2\2\6
\4\\{exit}: \37\&{end};\par
\fi

\M90. The \\{skip\_TeX} routine is used on the first pass to skip through
the \TeX\ code at the beginning of a module. It returns the next
control code or `\v' found in the input. A \\{new\_module} is
assumed to exist at the very end of the file.

\Y\P\4\&{function}\1\  \37\\{skip\_TeX}: \37\\{eight\_bits};\C{skip past pure %
\TeX\ code}\6
\4\&{label} \37\\{done};\6
\4\&{var} \37\|c: \37\\{eight\_bits};\C{control code found}\2\6
\&{begin} \37\~ \1\&{loop}\6
\&{begin} \37\&{if} $\\{loc}>\\{limit}$ \1\&{then}\6
\&{begin} \37\\{get\_line};\6
\&{if} $\\{input\_has\_ended}$ \1\&{then}\6
\&{begin} \37$\|c\K\\{new\_module}$;\5
\&{goto} \37\\{done};\6
\&{end};\2\6
\&{end};\2\6
$\\{buffer}[\\{limit}+1]\K\.{"@"}$;\6
\1\&{repeat} \37$\|c\K\\{buffer}[\\{loc}]$;\5
$\\{incr}(\\{loc})$;\6
\&{if} $\|c=\.{"|"}$ \1\&{then}\5
\&{goto} \37\\{done};\2\6
\4\&{until}\5
$\|c=\.{"@"}$;\2\6
\&{if} $\\{loc}\L\\{limit}$ \1\&{then}\6
\&{begin} \37$\|c\K\\{control\_code}(\\{buffer}[\\{loc}])$;\5
$\\{incr}(\\{loc})$;\5
\&{goto} \37\\{done};\6
\&{end};\2\6
\&{end};\2\6
\4\\{done}: \37$\\{skip\_TeX}\K\|c$;\6
\&{end};\par
\fi

\M91. The \\{skip\_comment} routine is used on the first pass to skip
through \TeX\ code in \PASCAL\ comments. The \\{bal} parameter
tells how many left braces are assumed to have been scanned when
this routine is called, and the procedure returns a corresponding
value of \\{bal} at the point that scanning has stopped. Scanning
stops either at a `\v' that introduces \PASCAL\ text,
in which case the returned value is positive, or it stops at the
end of the comment, in which case the returned value is zero.
The scanning also stops in anomalous situations when the comment
doesn't end or when it contains an illegal use of \.{@}.
One should call $\\{skip\_comment}(1)$ when beginning to scan a comment.

\Y\P\4\&{function}\1\  \37$\\{skip\_comment}(\\{bal}:\\{eight\_bits})$: \37%
\\{eight\_bits};\C{skips \TeX\   code in comments}\6
\4\&{label} \37\\{done};\6
\4\&{var} \37\|c: \37\\{ASCII\_code};\C{the current character}\2\6
\&{begin} \37\~ \1\&{loop}\6
\&{begin} \37\&{if} $\\{loc}>\\{limit}$ \1\&{then}\6
\&{begin} \37\\{get\_line};\6
\&{if} $\\{input\_has\_ended}$ \1\&{then}\6
\&{begin} \37$\\{bal}\K0$;\5
\&{goto} \37\\{done};\6
\&{end};\C{an error message will occur in phase two}\2\6
\&{end};\2\6
$\|c\K\\{buffer}[\\{loc}]$;\5
$\\{incr}(\\{loc})$;\6
\&{if} $\|c=\.{"|"}$ \1\&{then}\5
\&{goto} \37\\{done};\2\6
\X92:Do special things when $\|c=\.{"@"},\.{"\\"},\.{"\{"},\.{"\}"}$; \&{goto} %
\\{done} at end\X;\6
\&{end};\2\6
\4\\{done}: \37$\\{skip\_comment}\K\\{bal}$;\6
\&{end};\par
\fi

\M92. \P$\X92:Do special things when $\|c=\.{"@"},\.{"\\"},\.{"\{"},\.{"\}"}$; %
\&{goto} \\{done} at end\X\S$\6
\&{if} $\|c=\.{"@"}$ \1\&{then}\6
\&{begin} \37$\|c\K\\{buffer}[\\{loc}]$;\6
\&{if} $(\|c\I\.{"\ "})\W(\|c\I\\{tab\_mark})\W(\|c\I\.{"*"})$ \1\&{then}\5
$\\{incr}(\\{loc})$\6
\4\&{else} \&{begin} \37$\\{decr}(\\{loc})$;\5
$\\{bal}\K0$;\5
\&{goto} \37\\{done};\6
\&{end}\C{an error message will occur in phase two}\2\6
\&{end}\6
\4\&{else} \&{if} $(\|c=\.{"\\"})\W(\\{buffer}[\\{loc}]\I\.{"@"})$ \1\&{then}\5
$\\{incr}(\\{loc})$\6
\4\&{else} \&{if} $\|c=\.{"\{"}$ \1\&{then}\5
$\\{incr}(\\{bal})$\6
\4\&{else} \&{if} $\|c=\.{"\}"}$ \1\&{then}\6
\&{begin} \37$\\{decr}(\\{bal})$;\6
\&{if} $\\{bal}=0$ \1\&{then}\5
\&{goto} \37\\{done};\2\6
\&{end}\2\2\2\2\par
\U91.\fi

\N93.  Inputting the next token.
As stated above, \.{WEAVE}'s most interesting lexical scanning routine is the
\\{get\_next} function that inputs the next token of \PASCAL\ input. However,
\\{get\_next} is not especially complicated.

The result of \\{get\_next} is either an ASCII code for some special character,
or it is a special code representing a pair of characters (e.g., `\.{:=}'
or `\.{..}'), or it is the numeric value computed by the \\{control\_code}
procedure, or it is one of the following special codes:

\yskip\hang \\{exponent}: The `\.E' in a real constant.

\yskip\hang \\{identifier}: In this case the global variables \\{id\_first}
and \\{id\_loc} will have been set to the appropriate values needed by the
\\{id\_lookup} routine.

\yskip\hang \\{string}: In this case the global variables \\{id\_first} and
\\{id\_loc} will have been set to the beginning and ending-plus-one locations
in the buffer.  The string ends with the first reappearance of its initial
delimiter; thus, for example, $$\.{\'This isn\'\'t a single string\'}$$
will be treated as two consecutive strings, the first being \.{\'This
isn\'}.

\yskip\noindent Furthermore, some of the control codes cause
\\{get\_next} to take additional actions:

\yskip\hang \\{xref\_roman}, \\{xref\_wildcard},
\\{xref\_typewriter}, \\{TeX\_string}: The values of
\\{id\_first} and \\{id\_loc} will be set so that the string in question
appears
in $\\{buffer}[\\{id\_first}\to(\\{id\_loc}-1)]$.

\yskip\hang \\{module\_name}: In this case the global variable \\{cur\_module}
will
point to the \\{byte\_start} entry for the module name that has just been
scanned.

\yskip\noindent If \\{get\_next} sees `\.{@!}' or `\.{@?}',
it sets \\{xref\_switch} to \\{def\_flag} or zero and goes on to the next
token.

A global variable called \\{scanning\_hex} is set \\{true} during the time that
the letters \.A through \.F should be treated as if they were digits.

\Y\P\D \37$\\{exponent}=\O{200}$\C{\.E or \.e following a digit}\par
\P\D \37$\\{string}=\O{201}$\C{\PASCAL\ string or \.{WEB} precomputed string}%
\par
\P\D \37$\\{identifier}=\O{202}$\C{\PASCAL\ identifier or reserved word}\par
\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{cur\_module}: \37\\{name\_pointer};\C{name of module just scanned}\6
\4\\{scanning\_hex}: \37\\{boolean};\C{are we scanning a hexadecimal constant?}%
\par
\fi

\M94. \P$\X10:Set initial values\X\mathrel{+}\S$\6
$\\{scanning\_hex}\K\\{false}$;\par
\fi

\M95. As one might expect, \\{get\_next} consists mostly of a big switch
that branches to the various special cases that can arise.

\Y\P\D \37$\\{up\_to}(\#)\S\#-24,\39\#-23,\39\#-22,\39\#-21,\39\#-20,\39\#-19,%
\39\#-18,\39\#-17,\39\#-16,\39\#-15,\39\#-14,\39\#-13,\39\#-12,\39\#-11,\39%
\#-10,\39\#-9,\39\#-8,\39\#-7,\39\#-6,\39\#-5,\39\#-4,\39\#-3,\39\#-2,\39\#-1,%
\39\#$\par
\Y\P\4\&{function}\1\  \37\\{get\_next}: \37\\{eight\_bits};\C{produces the
next input token}\6
\4\&{label} \37$\\{restart},\39\\{done},\39\\{found}$;\6
\4\&{var} \37\|c: \37\\{eight\_bits};\C{the current character}\6
\|d: \37\\{eight\_bits};\C{the next character}\6
$\|j,\39\|k$: \37$0\to\\{longest\_name}$;\C{indices into \\{mod\_text}}\2\6
\&{begin} \37\\{restart}: \37\&{if} $\\{loc}>\\{limit}$ \1\&{then}\6
\&{begin} \37\\{get\_line};\6
\&{if} $\\{input\_has\_ended}$ \1\&{then}\6
\&{begin} \37$\|c\K\\{new\_module}$;\5
\&{goto} \37\\{found};\6
\&{end};\2\6
\&{end};\2\6
$\|c\K\\{buffer}[\\{loc}]$;\5
$\\{incr}(\\{loc})$;\6
\&{if} $\\{scanning\_hex}$ \1\&{then}\5
\X96:Go to \\{found} if \|c is a hexadecimal digit, otherwise set $\\{scanning%
\_hex}\K\\{false}$\X;\2\6
\&{case} $\|c$ \1\&{of}\6
\4$\.{"A"},\39\\{up\_to}(\.{"Z"}),\39\.{"a"},\39\\{up\_to}(\.{"z"})$: \37%
\X98:Get an identifier\X;\6
\4$\.{"\'"},\39\.{""}\.{""}$: \37\X99:Get a string\X;\6
\4\.{"@"}: \37\X100:Get control code and possible module name\X;\6
\hbox{\4}\X97:Compress two-symbol combinations like `\.{:=}'\X\6
\4$\.{"\ "},\39\\{tab\_mark}$: \37\&{goto} \37\\{restart};\C{ignore spaces and
tabs}\6
\4\.{"\}"}: \37\&{begin} \37$\\{err\_print}(\.{\'!\ Extra\ \}\'})$;\5
\&{goto} \37\\{restart};\6
\&{end};\6
\4\&{othercases} \37\&{if} $\|c\G128$ \1\&{then}\5
\&{goto} \37\\{restart}\C{ignore nonstandard characters}\6
\4\&{else} \\{do\_nothing}\2\2\6
\&{endcases};\6
\4\\{found}: \37\&{debug} \37\&{if} $\\{trouble\_shooting}$ \1\&{then}\5
\\{debug\_help};\2\ \&{gubed}\6
$\\{get\_next}\K\|c$;\6
\&{end};\par
\fi

\M96. \P$\X96:Go to \\{found} if \|c is a hexadecimal digit, otherwise set $%
\\{scanning\_hex}\K\\{false}$\X\S$\6
\&{if} $((\|c\G\.{"0"})\W(\|c\L\.{"9"}))\V((\|c\G\.{"A"})\W(\|c\L\.{"F"}))$ \1%
\&{then}\5
\&{goto} \37\\{found}\6
\4\&{else} $\\{scanning\_hex}\K\\{false}$\2\par
\U95.\fi

\M97. Note that the following code substitutes \.{@\{} and \.{@\}} for the
respective combinations `\.{(*}' and `\.{*)}'. Explicit braces should be used
for \TeX\ comments in \PASCAL\ text.

\Y\P\D \37$\\{compress}(\#)\S$\1\6
\&{begin} \37\&{if} $\\{loc}\L\\{limit}$ \1\&{then}\6
\&{begin} \37$\|c\K\#$;\5
$\\{incr}(\\{loc})$;\6
\&{end};\2\6
\&{end}\2\par
\Y\P$\4\X97:Compress two-symbol combinations like `\.{:=}'\X\S$\6
\4\.{"."}: \37\&{if} $\\{buffer}[\\{loc}]=\.{"."}$ \1\&{then}\5
$\\{compress}(\\{double\_dot})$\6
\4\&{else} \&{if} $\\{buffer}[\\{loc}]=\.{")"}$ \1\&{then}\5
$\\{compress}(\.{"]"})$;\2\2\6
\4\.{":"}: \37\&{if} $\\{buffer}[\\{loc}]=\.{"="}$ \1\&{then}\5
$\\{compress}(\\{left\_arrow})$;\2\6
\4\.{"="}: \37\&{if} $\\{buffer}[\\{loc}]=\.{"="}$ \1\&{then}\5
$\\{compress}(\\{equivalence\_sign})$;\2\6
\4\.{">"}: \37\&{if} $\\{buffer}[\\{loc}]=\.{"="}$ \1\&{then}\5
$\\{compress}(\\{greater\_or\_equal})$;\2\6
\4\.{"<"}: \37\&{if} $\\{buffer}[\\{loc}]=\.{"="}$ \1\&{then}\5
$\\{compress}(\\{less\_or\_equal})$\6
\4\&{else} \&{if} $\\{buffer}[\\{loc}]=\.{">"}$ \1\&{then}\5
$\\{compress}(\\{not\_equal})$;\2\2\6
\4\.{"("}: \37\&{if} $\\{buffer}[\\{loc}]=\.{"*"}$ \1\&{then}\5
$\\{compress}(\\{begin\_comment})$\6
\4\&{else} \&{if} $\\{buffer}[\\{loc}]=\.{"."}$ \1\&{then}\5
$\\{compress}(\.{"["})$;\2\2\6
\4\.{"*"}: \37\&{if} $\\{buffer}[\\{loc}]=\.{")"}$ \1\&{then}\5
$\\{compress}(\\{end\_comment})$;\2\par
\U95.\fi

\M98. \P$\X98:Get an identifier\X\S$\6
\&{begin} \37\&{if} $((\|c=\.{"E"})\V(\|c=\.{"e"}))\W(\\{loc}>1)$ \1\&{then}\6
\&{if} $(\\{buffer}[\\{loc}-2]\L\.{"9"})\W(\\{buffer}[\\{loc}-2]\G\.{"0"})$ \1%
\&{then}\5
$\|c\K\\{exponent}$;\2\2\6
\&{if} $\|c\I\\{exponent}$ \1\&{then}\6
\&{begin} \37$\\{decr}(\\{loc})$;\5
$\\{id\_first}\K\\{loc}$;\6
\1\&{repeat} \37$\\{incr}(\\{loc})$;\5
$\|d\K\\{buffer}[\\{loc}]$;\6
\4\&{until}\5
$((\|d<\.{"0"})\V((\|d>\.{"9"})\W(\|d<\.{"A"}))\V((\|d>\.{"Z"})\W(\|d<\.{"a"}))%
\V(\|d>\.{"z"}))\W(\|d\I\.{"\_"})$;\2\6
$\|c\K\\{identifier}$;\5
$\\{id\_loc}\K\\{loc}$;\6
\&{end};\2\6
\&{end}\par
\U95.\fi

\M99. A string that starts and ends with single or double quote marks is
scanned by the following piece of the program.

\Y\P$\4\X99:Get a string\X\S$\6
\&{begin} \37$\\{id\_first}\K\\{loc}-1$;\6
\1\&{repeat} \37$\|d\K\\{buffer}[\\{loc}]$;\5
$\\{incr}(\\{loc})$;\6
\&{if} $\\{loc}>\\{limit}$ \1\&{then}\6
\&{begin} \37$\\{err\_print}(\.{\'!\ String\ constant\ didn\'}\.{\'t\ end\'})$;%
\5
$\\{loc}\K\\{limit}$;\5
$\|d\K\|c$;\6
\&{end};\2\6
\4\&{until}\5
$\|d=\|c$;\2\6
$\\{id\_loc}\K\\{loc}$;\5
$\|c\K\\{string}$;\6
\&{end}\par
\U95.\fi

\M100. After an \.{@} sign has been scanned, the next character tells us
whether there is more work to do.

\Y\P$\4\X100:Get control code and possible module name\X\S$\6
\&{begin} \37$\|c\K\\{control\_code}(\\{buffer}[\\{loc}])$;\5
$\\{incr}(\\{loc})$;\6
\&{if} $\|c=\\{underline}$ \1\&{then}\6
\&{begin} \37$\\{xref\_switch}\K\\{def\_flag}$;\5
\&{goto} \37\\{restart};\6
\&{end}\6
\4\&{else} \&{if} $\|c=\\{no\_underline}$ \1\&{then}\6
\&{begin} \37$\\{xref\_switch}\K0$;\5
\&{goto} \37\\{restart};\6
\&{end}\6
\4\&{else} \&{if} $(\|c\L\\{TeX\_string})\W(\|c\G\\{xref\_roman})$ \1\&{then}\5
\X106:Scan to the next \.{@>}\X\6
\4\&{else} \&{if} $\|c=\\{hex}$ \1\&{then}\5
$\\{scanning\_hex}\K\\{true}$\6
\4\&{else} \&{if} $\|c=\\{module\_name}$ \1\&{then}\5
\X101:Scan the module name and make \\{cur\_module} point to it\X\6
\4\&{else} \&{if} $\|c=\\{verbatim}$ \1\&{then}\5
\X107:Scan a verbatim string\X;\2\2\2\2\2\2\6
\&{end}\par
\U95.\fi

\M101. The occurrence of a module name sets \\{xref\_switch} to zero,
because the module name might (for example) follow \&{var}.

\Y\P$\4\X101:Scan the module name and make \\{cur\_module} point to it\X\S$\6
\&{begin} \37\X103:Put module name into $\\{mod\_text}[1\to\|k]$\X;\6
\&{if} $\|k>3$ \1\&{then}\6
\&{begin} \37\&{if} $(\\{mod\_text}[\|k]=\.{"."})\W(\\{mod\_text}[\|k-1]=%
\.{"."})\W(\\{mod\_text}[\|k-2]=\.{"."})$ \1\&{then}\5
$\\{cur\_module}\K\\{prefix\_lookup}(\|k-3)$\6
\4\&{else} $\\{cur\_module}\K\\{mod\_lookup}(\|k)$;\2\6
\&{end}\6
\4\&{else} $\\{cur\_module}\K\\{mod\_lookup}(\|k)$;\2\6
$\\{xref\_switch}\K0$;\6
\&{end}\par
\U100.\fi

\M102. Module names are placed into the \\{mod\_text} array with consecutive
spaces,
tabs, and carriage-returns replaced by single spaces. There will be no
spaces at the beginning or the end. (We set $\\{mod\_text}[0]\K\.{"\ "}$ to
facilitate
this, since the \\{mod\_lookup} routine uses $\\{mod\_text}[1]$ as the first
character of the name.)

\Y\P$\4\X10:Set initial values\X\mathrel{+}\S$\6
$\\{mod\_text}[0]\K\.{"\ "}$;\par
\fi

\M103. \P$\X103:Put module name into $\\{mod\_text}[1\to\|k]$\X\S$\6
$\|k\K0$;\6
\~ \1\&{loop}\ \&{begin} \37\&{if} $\\{loc}>\\{limit}$ \1\&{then}\6
\&{begin} \37\\{get\_line};\6
\&{if} $\\{input\_has\_ended}$ \1\&{then}\6
\&{begin} \37$\\{err\_print}(\.{\'!\ Input\ ended\ in\ section\ name\'})$;\5
$\\{loc}\K1$;\5
\&{goto} \37\\{done};\6
\&{end};\2\6
\&{end};\2\6
$\|d\K\\{buffer}[\\{loc}]$;\5
\X104:If end of name, \&{goto} \\{done}\X;\6
$\\{incr}(\\{loc})$;\6
\&{if} $\|k<\\{longest\_name}-1$ \1\&{then}\5
$\\{incr}(\|k)$;\2\6
\&{if} $(\|d=\.{"\ "})\V(\|d=\\{tab\_mark})$ \1\&{then}\6
\&{begin} \37$\|d\K\.{"\ "}$;\6
\&{if} $\\{mod\_text}[\|k-1]=\.{"\ "}$ \1\&{then}\5
$\\{decr}(\|k)$;\2\6
\&{end};\2\6
$\\{mod\_text}[\|k]\K\|d$;\6
\&{end};\2\6
\4\\{done}: \37\X105:Check for overlong name\X;\6
\&{if} $(\\{mod\_text}[\|k]=\.{"\ "})\W(\|k>0)$ \1\&{then}\5
$\\{decr}(\|k)$\2\par
\U101.\fi

\M104. \P$\X104:If end of name, \&{goto} \\{done}\X\S$\6
\&{if} $\|d=\.{"@"}$ \1\&{then}\6
\&{begin} \37$\|d\K\\{buffer}[\\{loc}+1]$;\6
\&{if} $\|d=\.{">"}$ \1\&{then}\6
\&{begin} \37$\\{loc}\K\\{loc}+2$;\5
\&{goto} \37\\{done};\6
\&{end};\2\6
\&{if} $(\|d=\.{"\ "})\V(\|d=\\{tab\_mark})\V(\|d=\.{"*"})$ \1\&{then}\6
\&{begin} \37$\\{err\_print}(\.{\'!\ Section\ name\ didn\'}\.{\'t\ end\'})$;\5
\&{goto} \37\\{done};\6
\&{end};\2\6
$\\{incr}(\|k)$;\5
$\\{mod\_text}[\|k]\K\.{"@"}$;\5
$\\{incr}(\\{loc})$;\C{now $\|d=\\{buffer}[\\{loc}]$ again}\6
\&{end}\2\par
\U103.\fi

\M105. \P$\X105:Check for overlong name\X\S$\6
\&{if} $\|k\G\\{longest\_name}-2$ \1\&{then}\6
\&{begin} \37$\\{print\_nl}(\.{\'!\ Section\ name\ too\ long:\ \'})$;\6
\&{for} $\|j\K1\mathrel{\&{to}}25$ \1\&{do}\5
$\\{print}(\\{xchr}[\\{mod\_text}[\|j]])$;\2\6
$\\{print}(\.{\'...\'})$;\5
\\{mark\_harmless};\6
\&{end}\2\par
\U103.\fi

\M106. \P$\X106:Scan to the next \.{@>}\X\S$\6
\&{begin} \37$\\{id\_first}\K\\{loc}$;\5
$\\{buffer}[\\{limit}+1]\K\.{"@"}$;\6
\&{while} $\\{buffer}[\\{loc}]\I\.{"@"}$ \1\&{do}\5
$\\{incr}(\\{loc})$;\2\6
$\\{id\_loc}\K\\{loc}$;\6
\&{if} $\\{loc}>\\{limit}$ \1\&{then}\6
\&{begin} \37$\\{err\_print}(\.{\'!\ Control\ text\ didn\'}\.{\'t\ end\'})$;\5
$\\{loc}\K\\{limit}$;\6
\&{end}\6
\4\&{else} \&{begin} \37$\\{loc}\K\\{loc}+2$;\6
\&{if} $\\{buffer}[\\{loc}-1]\I\.{">"}$ \1\&{then}\5
$\\{err\_print}(\.{\'!\ Control\ codes\ are\ forbidden\ in\ control\ text\'})$;%
\2\6
\&{end};\2\6
\&{end}\par
\U100.\fi

\M107. A verbatim \PASCAL\ string will be treated like ordinary strings, but
with no surrounding delimiters.  At the present point in the program we
have $\\{buffer}[\\{loc}-1]=\\{verbatim}$; we must set \\{id\_first} to the
beginning
of the string itself, and \\{id\_loc} to its ending-plus-one location in the
buffer.  We also set \\{loc} to the position just after the ending delimiter.

\Y\P$\4\X107:Scan a verbatim string\X\S$\6
\&{begin} \37$\\{id\_first}\K\\{loc}$;\5
$\\{incr}(\\{loc})$;\5
$\\{buffer}[\\{limit}+1]\K\.{"@"}$;\5
$\\{buffer}[\\{limit}+2]\K\.{">"}$;\6
\&{while} $(\\{buffer}[\\{loc}]\I\.{"@"})\V(\\{buffer}[\\{loc}+1]\I\.{">"})$ \1%
\&{do}\5
$\\{incr}(\\{loc})$;\2\6
\&{if} $\\{loc}\G\\{limit}$ \1\&{then}\5
$\\{err\_print}(\.{\'!\ Verbatim\ string\ didn\'}\.{\'t\ end\'})$;\2\6
$\\{id\_loc}\K\\{loc}$;\5
$\\{loc}\K\\{loc}+2$;\6
\&{end}\par
\U100.\fi

\N108.  Phase one processing.
We now have accumulated enough subroutines to make it possible to carry out
\.{WEAVE}'s first pass over the source file. If everything works right,
both phase one and phase two of \.{WEAVE} will assign the same numbers to
modules, and these numbers will agree with what \.{TANGLE} does.

The global variable \\{next\_control} often contains the most recent output of
\\{get\_next}; in interesting cases, this will be the control code that
ended a module or part of a module.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{next\_control}: \37\\{eight\_bits};\C{control code waiting to be acting
upon}\par
\fi

\M109. The overall processing strategy in phase one has the following
straightforward outline.

\Y\P$\4\X109:Phase I: Read all the user's text and store the cross references\X%
\S$\6
$\\{phase\_one}\K\\{true}$;\5
$\\{phase\_three}\K\\{false}$;\5
\\{reset\_input};\5
$\\{module\_count}\K0$;\5
\\{skip\_limbo};\5
$\\{change\_exists}\K\\{false}$;\6
\&{while} $\R\\{input\_has\_ended}$ \1\&{do}\5
\X110:Store cross reference data for the current module\X;\2\6
$\\{changed\_module}[\\{module\_count}]\K\\{change\_exists}$;\C{the index
changes if anything does}\6
$\\{phase\_one}\K\\{false}$;\C{prepare for second phase}\6
\X120:Print error messages about unused or undefined module names\X;\par
\U261.\fi

\M110. \P$\X110:Store cross reference data for the current module\X\S$\6
\&{begin} \37$\\{incr}(\\{module\_count})$;\6
\&{if} $\\{module\_count}=\\{max\_modules}$ \1\&{then}\5
$\\{overflow}(\.{\'section\ number\'})$;\2\6
$\\{changed\_module}[\\{module\_count}]\K\\{changing}$;\C{it will become %
\\{true} if any line changes}\6
\&{if} $\\{buffer}[\\{loc}-1]=\.{"*"}$ \1\&{then}\6
\&{begin} \37$\\{print}(\.{\'*\'},\39\\{module\_count}:1)$;\5
\\{update\_terminal};\C{print a progress report}\6
\&{end};\2\6
\X113:Store cross references in the \TeX\ part of a module\X;\6
\X115:Store cross references in the \(definition part of a module\X;\6
\X117:Store cross references in the \PASCAL\ part of a module\X;\6
\&{if} $\\{changed\_module}[\\{module\_count}]$ \1\&{then}\5
$\\{change\_exists}\K\\{true}$;\2\6
\&{end}\par
\U109.\fi

\M111. The \\{Pascal\_xref} subroutine stores references to identifiers in
\PASCAL\ text material beginning with the current value of \\{next\_control}
and continuing until \\{next\_control} is `\.\{' or `\v', or until the next
``milestone'' is passed (i.e., $\\{next\_control}\G\\{format}$). If
$\\{next\_control}\G\\{format}$ when \\{Pascal\_xref} is called, nothing will
happen;
but if $\\{next\_control}=\.{"|"}$ upon entry, the procedure assumes that this
is
the `\v' preceding \PASCAL\ text that is to be processed.

The program uses the fact that our internal code numbers satisfy
the relations $\\{xref\_roman}=\\{identifier}+\\{roman}$ and $\\{xref%
\_wildcard}=\\{identifier}+\\{wildcard}$ and $\\{xref\_typewriter}=%
\\{identifier}+\\{typewriter}$ and $\\{normal}=0$. An implied `\.{@!}' is
inserted after
\&{function}, \&{procedure}, \&{program}, and \&{var}.

\Y\P\4\&{procedure}\1\  \37\\{Pascal\_xref};\C{makes cross references for %
\PASCAL\ identifiers}\6
\4\&{label} \37\\{exit};\6
\4\&{var} \37\|p: \37\\{name\_pointer};\C{a referenced name}\2\6
\&{begin} \37\&{while} $\\{next\_control}<\\{format}$ \1\&{do}\6
\&{begin} \37\&{if} $(\\{next\_control}\G\\{identifier})\W(\\{next\_control}\L%
\\{xref\_typewriter})$ \1\&{then}\6
\&{begin} \37$\|p\K\\{id\_lookup}(\\{next\_control}-\\{identifier})$;\5
$\\{new\_xref}(\|p)$;\6
\&{if} $(\\{ilk}[\|p]=\\{proc\_like})\V(\\{ilk}[\|p]=\\{var\_like})$ \1\&{then}%
\5
$\\{xref\_switch}\K\\{def\_flag}$;\C{implied `\.{@!}'}\2\6
\&{end};\2\6
$\\{next\_control}\K\\{get\_next}$;\6
\&{if} $(\\{next\_control}=\.{"|"})\V(\\{next\_control}=\.{"\{"})$ \1\&{then}\5
\&{return};\2\6
\&{end};\2\6
\4\\{exit}: \37\&{end};\par
\fi

\M112. The \\{outer\_xref} subroutine is like \\{Pascal\_xref} but it begins
with $\\{next\_control}\I\.{"|"}$ and ends with $\\{next\_control}\G%
\\{format}$. Thus, it
handles \PASCAL\ text with embedded comments.

\Y\P\4\&{procedure}\1\  \37\\{outer\_xref};\C{extension of \\{Pascal\_xref}}\6
\4\&{var} \37\\{bal}: \37\\{eight\_bits};\C{brace level in comment}\2\6
\&{begin} \37\&{while} $\\{next\_control}<\\{format}$ \1\&{do}\6
\&{if} $\\{next\_control}\I\.{"\{"}$ \1\&{then}\5
\\{Pascal\_xref}\6
\4\&{else} \&{begin} \37$\\{bal}\K\\{skip\_comment}(1)$;\5
$\\{next\_control}\K\.{"|"}$;\6
\&{while} $\\{bal}>0$ \1\&{do}\6
\&{begin} \37\\{Pascal\_xref};\6
\&{if} $\\{next\_control}=\.{"|"}$ \1\&{then}\5
$\\{bal}\K\\{skip\_comment}(\\{bal})$\6
\4\&{else} $\\{bal}\K0$;\C{an error will be reported in phase two}\2\6
\&{end};\2\6
\&{end};\2\2\6
\&{end};\par
\fi

\M113. In the \TeX\ part of a module, cross reference entries are made only for
the identifiers in \PASCAL\ texts enclosed in \pb, or for control texts
enclosed in \.{@\^}$\,\ldots\,$\.{@>} or \.{@.}$\,\ldots\,$\.{@>}
or \.{@:}$\,\ldots\,$\.{@>}.

\Y\P$\4\X113:Store cross references in the \TeX\ part of a module\X\S$\6
\1\&{repeat} \37$\\{next\_control}\K\\{skip\_TeX}$;\6
\&{case} $\\{next\_control}$ \1\&{of}\6
\4\\{underline}: \37$\\{xref\_switch}\K\\{def\_flag}$;\6
\4\\{no\_underline}: \37$\\{xref\_switch}\K0$;\6
\4\.{"|"}: \37\\{Pascal\_xref};\6
\4$\\{xref\_roman},\39\\{xref\_wildcard},\39\\{xref\_typewriter},\39\\{module%
\_name}$: \37\&{begin} \37$\\{loc}\K\\{loc}-2$;\5
$\\{next\_control}\K\\{get\_next}$;\C{scan to \.{@>}}\6
\&{if} $\\{next\_control}\I\\{module\_name}$ \1\&{then}\5
$\\{new\_xref}(\\{id\_lookup}(\\{next\_control}-\\{identifier}))$;\2\6
\&{end};\6
\4\&{othercases} \37\\{do\_nothing}\2\6
\&{endcases};\6
\4\&{until}\5
$\\{next\_control}\G\\{format}$\2\par
\U110.\fi

\M114. During the definition and \PASCAL\ parts of a module, cross references
are made for all identifiers except reserved words; however, the
identifiers in a format definition are referenced even if they are
reserved. The \TeX\ code in comments is, of course, ignored, except for
\PASCAL\ portions enclosed in \pb; the text of a module name is skipped
entirely, even if it contains \pb\ constructions.

The variables \\{lhs} and \\{rhs} point to the respective identifiers involved
in a format definition.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4$\\{lhs},\39\\{rhs}$: \37\\{name\_pointer};\C{indices into \\{byte\_start}
for format identifiers}\par
\fi

\M115. When we get to the following code we have $\\{next\_control}\G%
\\{format}$.

\Y\P$\4\X115:Store cross references in the \(definition part of a module\X\S$\6
\&{while} $\\{next\_control}\L\\{definition}$ \1\&{do}\C{\\{format} or %
\\{definition}}\6
\&{begin} \37$\\{xref\_switch}\K\\{def\_flag}$;\C{implied \.{@!}}\6
\&{if} $\\{next\_control}=\\{definition}$ \1\&{then}\5
$\\{next\_control}\K\\{get\_next}$\6
\4\&{else} \X116:Process a format definition\X;\2\6
\\{outer\_xref};\6
\&{end}\2\par
\U110.\fi

\M116. Error messages for improper format definitions will be issued in phase
two. Our job in phase one is to define the \\{ilk} of a properly formatted
identifier, and to fool the \\{new\_xref} routine into thinking that the
identifier on the right-hand side of the format definition is not a
reserved word.

\Y\P$\4\X116:Process a format definition\X\S$\6
\&{begin} \37$\\{next\_control}\K\\{get\_next}$;\6
\&{if} $\\{next\_control}=\\{identifier}$ \1\&{then}\6
\&{begin} \37$\\{lhs}\K\\{id\_lookup}(\\{normal})$;\5
$\\{ilk}[\\{lhs}]\K\\{normal}$;\5
$\\{new\_xref}(\\{lhs})$;\5
$\\{next\_control}\K\\{get\_next}$;\6
\&{if} $\\{next\_control}=\\{equivalence\_sign}$ \1\&{then}\6
\&{begin} \37$\\{next\_control}\K\\{get\_next}$;\6
\&{if} $\\{next\_control}=\\{identifier}$ \1\&{then}\6
\&{begin} \37$\\{rhs}\K\\{id\_lookup}(\\{normal})$;\5
$\\{ilk}[\\{lhs}]\K\\{ilk}[\\{rhs}]$;\5
$\\{ilk}[\\{rhs}]\K\\{normal}$;\5
$\\{new\_xref}(\\{rhs})$;\5
$\\{ilk}[\\{rhs}]\K\\{ilk}[\\{lhs}]$;\5
$\\{next\_control}\K\\{get\_next}$;\6
\&{end};\2\6
\&{end};\2\6
\&{end};\2\6
\&{end}\par
\U115.\fi

\M117. Finally, when the \TeX\ and definition parts have been treated, we have
$\\{next\_control}\G\\{begin\_Pascal}$.

\Y\P$\4\X117:Store cross references in the \PASCAL\ part of a module\X\S$\6
\&{if} $\\{next\_control}\L\\{module\_name}$ \1\&{then}\C{\\{begin\_Pascal} or %
\\{module\_name}}\6
\&{begin} \37\&{if} $\\{next\_control}=\\{begin\_Pascal}$ \1\&{then}\5
$\\{mod\_xref\_switch}\K0$\6
\4\&{else} $\\{mod\_xref\_switch}\K\\{def\_flag}$;\2\6
\1\&{repeat} \37\&{if} $\\{next\_control}=\\{module\_name}$ \1\&{then}\5
$\\{new\_mod\_xref}(\\{cur\_module})$;\2\6
$\\{next\_control}\K\\{get\_next}$;\5
\\{outer\_xref};\6
\4\&{until}\5
$\\{next\_control}>\\{module\_name}$;\2\6
\&{end}\2\par
\U110.\fi

\M118. After phase one has looked at everything, we want to check that each
module name was both defined and used.
The variable \\{cur\_xref} will point to cross references for the
current module name of interest.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{cur\_xref}: \37\\{xref\_number};\C{temporary cross reference pointer}\par
\fi

\M119. The following recursive procedure
walks through the tree of module names and prints out anomalies.

\Y\P\4\&{procedure}\1\  \37$\\{mod\_check}(\|p:\\{name\_pointer})$;\C{print
anomalies in subtree \|p}\2\6
\&{begin} \37\&{if} $\|p>0$ \1\&{then}\6
\&{begin} \37$\\{mod\_check}(\\{llink}[\|p])$;\6
$\\{cur\_xref}\K\\{xref}[\|p]$;\6
\&{if} $\\{num}(\\{cur\_xref})<\\{def\_flag}$ \1\&{then}\6
\&{begin} \37$\\{print\_nl}(\.{\'!\ Never\ defined:\ <\'})$;\5
$\\{print\_id}(\|p)$;\5
$\\{print}(\.{\'>\'})$;\5
\\{mark\_harmless};\6
\&{end};\2\6
\&{while} $\\{num}(\\{cur\_xref})\G\\{def\_flag}$ \1\&{do}\5
$\\{cur\_xref}\K\\{xlink}(\\{cur\_xref})$;\2\6
\&{if} $\\{cur\_xref}=0$ \1\&{then}\6
\&{begin} \37$\\{print\_nl}(\.{\'!\ Never\ used:\ <\'})$;\5
$\\{print\_id}(\|p)$;\5
$\\{print}(\.{\'>\'})$;\5
\\{mark\_harmless};\6
\&{end};\2\6
$\\{mod\_check}(\\{rlink}[\|p])$;\6
\&{end};\2\6
\&{end};\par
\fi

\M120. \P$\X120:Print error messages about unused or undefined module names\X%
\S$\ $\\{mod\_check}(\\{root})$\par
\U109.\fi

\N121.  Low-level output routines.
The \TeX\ output is supposed to appear in lines at most \\{line\_length}
characters long, so we place it into an output buffer. During the output
process, \\{out\_line} will hold the current line number of the line about to
be output.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{out\_buf}: \37\&{array} $[0\to\\{line\_length}]$ \1\&{of}\5
\\{ASCII\_code};\C{assembled characters}\2\6
\4\\{out\_ptr}: \37$0\to\\{line\_length}$;\C{number of characters in \\{out%
\_buf}}\6
\4\\{out\_line}: \37\\{integer};\C{coordinates of next line to be output}\par
\fi

\M122. The \\{flush\_buffer} routine empties the buffer up to a given
breakpoint,
and moves any remaining characters to the beginning of the next line.
If the \\{per\_cent} parameter is \\{true}, a \.{"\%"} is appended to the line
that is being output; in this case the breakpoint \|b should be strictly
less than \\{line\_length}. If the \\{per\_cent} parameter is \\{false},
trailing blanks are suppressed.
The characters emptied from the buffer form a new line of output;
if the \\{carryover} parameter is true, a \.{"\%"} in that line will be
carried over to the next line (so that \TeX\ will ignore the completion
of commented-out text).

\Y\P\4\&{procedure}\1\  \37$\\{flush\_buffer}(\|b:\\{eight\_bits};\,\35\\{per%
\_cent},\39\\{carryover}:\\{boolean})$;\C{outputs $\\{out\_buf}[1\to\|b]$,
where $\|b\L\\{out\_ptr}$}\6
\4\&{label} \37$\\{done},\39\\{found}$;\6
\4\&{var} \37$\|j,\39\|k$: \37$0\to\\{line\_length}$;\2\6
\&{begin} \37$\|j\K\|b$;\6
\&{if} $\R\\{per\_cent}$ \1\&{then}\C{remove trailing blanks}\6
\~ \1\&{loop}\ \&{begin} \37\&{if} $\|j=0$ \1\&{then}\5
\&{goto} \37\\{done};\2\6
\&{if} $\\{out\_buf}[\|j]\I\.{"\ "}$ \1\&{then}\5
\&{goto} \37\\{done};\2\6
$\\{decr}(\|j)$;\6
\&{end};\2\2\6
\4\\{done}: \37\&{for} $\|k\K1\mathrel{\&{to}}\|j$ \1\&{do}\5
$\\{write}(\\{tex\_file},\39\\{xchr}[\\{out\_buf}[\|k]])$;\2\6
\&{if} $\\{per\_cent}$ \1\&{then}\5
$\\{write}(\\{tex\_file},\39\\{xchr}[\.{"\%"}])$;\2\6
$\\{write\_ln}(\\{tex\_file})$;\5
$\\{incr}(\\{out\_line})$;\6
\&{if} $\\{carryover}$ \1\&{then}\6
\&{for} $\|k\K1\mathrel{\&{to}}\|j$ \1\&{do}\6
\&{if} $\\{out\_buf}[\|k]=\.{"\%"}$ \1\&{then}\6
\&{if} $(\|k=1)\V(\\{out\_buf}[\|k-1]\I\.{"\\"})$ \1\&{then}\C{comment mode
should be preserved}\6
\&{begin} \37$\\{out\_buf}[\|b]\K\.{"\%"}$;\5
$\\{decr}(\|b)$;\5
\&{goto} \37\\{found};\6
\&{end};\2\2\2\2\6
\4\\{found}: \37\&{if} $(\|b<\\{out\_ptr})$ \1\&{then}\6
\&{for} $\|k\K\|b+1\mathrel{\&{to}}\\{out\_ptr}$ \1\&{do}\5
$\\{out\_buf}[\|k-\|b]\K\\{out\_buf}[\|k]$;\2\2\6
$\\{out\_ptr}\K\\{out\_ptr}-\|b$;\6
\&{end};\par
\fi

\M123. When we are copying \TeX\ source material, we retain line breaks
that occur in the input, except that an empty line is not
output when the \TeX\ source line was nonempty. For example, a line
of the \TeX\ file that contains only an index cross-reference entry
will not be copied. The \\{finish\_line} routine is called just before
\\{get\_line} inputs a new line, and just after a line break token has
been emitted during the output of translated \PASCAL\ text.

\Y\P\4\&{procedure}\1\  \37\\{finish\_line};\C{do this at the end of a line}\6
\4\&{label} \37\\{exit};\6
\4\&{var} \37\|k: \37$0\to\\{buf\_size}$;\C{index into \\{buffer}}\2\6
\&{begin} \37\&{if} $\\{out\_ptr}>0$ \1\&{then}\5
$\\{flush\_buffer}(\\{out\_ptr},\39\\{false},\39\\{false})$\6
\4\&{else} \&{begin} \37\&{for} $\|k\K0\mathrel{\&{to}}\\{limit}$ \1\&{do}\6
\&{if} $(\\{buffer}[\|k]\I\.{"\ "})\W(\\{buffer}[\|k]\I\\{tab\_mark})$ \1%
\&{then}\5
\&{return};\2\2\6
$\\{flush\_buffer}(0,\39\\{false},\39\\{false})$;\6
\&{end};\2\6
\4\\{exit}: \37\&{end};\par
\fi

\M124. In particular, the \\{finish\_line} procedure is called near the very
beginning of phase two. We initialize the output variables in a slightly
tricky way so that the first line of the output file will be
`\.{\\input webmac}'.

\Y\P$\4\X10:Set initial values\X\mathrel{+}\S$\6
$\\{out\_ptr}\K1$;\5
$\\{out\_line}\K1$;\5
$\\{out\_buf}[1]\K\.{"c"}$;\5
$\\{write}(\\{tex\_file},\39\.{\'\\input\ webma\'})$;\par
\fi

\M125. When we wish to append the character \|c to the output buffer, we write
`$\\{out}(c)$'; this will cause the buffer to be emptied if it was already
full. Similarly, `$\\{out2}(c_1)(c_2)$' appends a pair of characters.
A line break will occur at a space or after a single-nonletter
\TeX\ control sequence.

\Y\P\D \37$\\{oot}(\#)\S$\6
\&{if} $\\{out\_ptr}=\\{line\_length}$ \1\&{then}\5
\\{break\_out};\2\6
$\\{incr}(\\{out\_ptr})$;\5
$\\{out\_buf}[\\{out\_ptr}]\K\#$;\par
\P\D \37$\\{oot1}(\#)\S\\{oot}(\#)$\ \&{end} \par
\P\D \37$\\{oot2}(\#)\S\\{oot}(\#)\,\\{oot1}$\par
\P\D \37$\\{oot3}(\#)\S\\{oot}(\#)\,\\{oot2}$\par
\P\D \37$\\{oot4}(\#)\S\\{oot}(\#)\,\\{oot3}$\par
\P\D \37$\\{oot5}(\#)\S\\{oot}(\#)\,\\{oot4}$\par
\P\D \37$\\{out}\S$\ \&{begin} \37\\{oot1}\par
\P\D \37$\\{out2}\S$\ \&{begin} \37\\{oot2}\par
\P\D \37$\\{out3}\S$\ \&{begin} \37\\{oot3}\par
\P\D \37$\\{out4}\S$\ \&{begin} \37\\{oot4}\par
\P\D \37$\\{out5}\S$\ \&{begin} \37\\{oot5}\par
\fi

\M126. The \\{break\_out} routine is called just before the output buffer is
about
to overflow. To make this routine a little faster, we initialize position
0 of the output buffer to `\.\\'; this character isn't really output.

\Y\P$\4\X10:Set initial values\X\mathrel{+}\S$\6
$\\{out\_buf}[0]\K\.{"\\"}$;\par
\fi

\M127. A long line is broken at a blank space or just before a backslash that
isn't
preceded by another backslash. In the latter case, a \.{"\%"} is output at
the break.

\Y\P\4\&{procedure}\1\  \37\\{break\_out};\C{finds a way to break the output
line}\6
\4\&{label} \37\\{exit};\6
\4\&{var} \37\|k: \37$0\to\\{line\_length}$;\C{index into \\{out\_buf}}\6
\|d: \37\\{ASCII\_code};\C{character from the buffer}\2\6
\&{begin} \37$\|k\K\\{out\_ptr}$;\6
\~ \1\&{loop}\ \&{begin} \37\&{if} $\|k=0$ \1\&{then}\5
\X128:Print warning message, break the line, \&{return}\X;\2\6
$\|d\K\\{out\_buf}[\|k]$;\6
\&{if} $\|d=\.{"\ "}$ \1\&{then}\6
\&{begin} \37$\\{flush\_buffer}(\|k,\39\\{false},\39\\{true})$;\5
\&{return};\6
\&{end};\2\6
\&{if} $(\|d=\.{"\\"})\W(\\{out\_buf}[\|k-1]\I\.{"\\"})$ \1\&{then}\C{in this
case $\|k>1$}\6
\&{begin} \37$\\{flush\_buffer}(\|k-1,\39\\{true},\39\\{true})$;\5
\&{return};\6
\&{end};\2\6
$\\{decr}(\|k)$;\6
\&{end};\2\6
\4\\{exit}: \37\&{end};\par
\fi

\M128. We get to this module only in unusual cases that the entire output line
consists of a string of backslashes followed by a string of nonblank
non-backslashes. In such cases it is almost always safe to break the
line by putting a \.{"\%"} just before the last character.

\Y\P$\4\X128:Print warning message, break the line, \&{return}\X\S$\6
\&{begin} \37$\\{print\_nl}(\.{\'!\ Line\ had\ to\ be\ broken\ (output\ l.\'},%
\39\\{out\_line}:1)$;\5
$\\{print\_ln}(\.{\'):\'})$;\6
\&{for} $\|k\K1\mathrel{\&{to}}\\{out\_ptr}-1$ \1\&{do}\5
$\\{print}(\\{xchr}[\\{out\_buf}[\|k]])$;\2\6
\\{new\_line};\5
\\{mark\_harmless};\5
$\\{flush\_buffer}(\\{out\_ptr}-1,\39\\{true},\39\\{true})$;\5
\&{return};\6
\&{end}\par
\U127.\fi

\M129. Here is a procedure that outputs a module number in decimal notation.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{dig}: \37\&{array} $[0\to4]$ \1\&{of}\5
$0\to9$;\C{digits to output}\2\par
\fi

\M130. The number to be converted by \\{out\_mod} is known to be less than
\\{def\_flag}, so it cannot have more than five decimal digits.  If
the module is changed, we output `\.{\\*}' just after the number.

\Y\P\4\&{procedure}\1\  \37$\\{out\_mod}(\|m:\\{integer})$;\C{output a module
number}\6
\4\&{var} \37\|k: \37$0\to5$;\C{index into \\{dig}}\6
\|a: \37\\{integer};\C{accumulator}\2\6
\&{begin} \37$\|k\K0$;\5
$\|a\K\|m$;\6
\1\&{repeat} \37$\\{dig}[\|k]\K\|a\mathbin{\&{mod}}10$;\5
$\|a\K\|a\mathbin{\&{div}}10$;\5
$\\{incr}(\|k)$;\6
\4\&{until}\5
$\|a=0$;\2\6
\1\&{repeat} \37$\\{decr}(\|k)$;\5
$\\{out}(\\{dig}[\|k]+\.{"0"})$;\6
\4\&{until}\5
$\|k=0$;\2\6
\&{if} $\\{changed\_module}[\|m]$ \1\&{then}\5
$\\{out2}(\.{"\\"})(\.{"*"})$;\2\6
\&{end};\par
\fi

\M131. The \\{out\_name} subroutine is used to output an identifier or index
entry, enclosing it in braces.

\Y\P\4\&{procedure}\1\  \37$\\{out\_name}(\|p:\\{name\_pointer})$;\C{outputs a
name}\6
\4\&{var} \37\|k: \37$0\to\\{max\_bytes}$;\C{index into \\{byte\_mem}}\6
\|w: \37$0\to\\{ww}-1$;\C{row of \\{byte\_mem}}\2\6
\&{begin} \37$\\{out}(\.{"\{"})$;\5
$\|w\K\|p\mathbin{\&{mod}}\\{ww}$;\6
\&{for} $\|k\K\\{byte\_start}[\|p]\mathrel{\&{to}}\\{byte\_start}[\|p+%
\\{ww}]-1$ \1\&{do}\6
\&{begin} \37\&{if} $\\{byte\_mem}[\|w,\39\|k]=\.{"\_"}$ \1\&{then}\5
$\\{out}(\.{"\\"})$;\2\6
$\\{out}(\\{byte\_mem}[\|w,\39\|k])$;\6
\&{end};\2\6
$\\{out}(\.{"\}"})$;\6
\&{end};\par
\fi

\N132.  Routines that copy \TeX\ material.
During phase two, we use the subroutines \\{copy\_limbo}, \\{copy\_TeX}, and
\\{copy\_comment} in place of the analogous \\{skip\_limbo}, \\{skip\_TeX}, and
\\{skip\_comment} that were used in phase one.

The \\{copy\_limbo} routine, for example, takes \TeX\ material that is not
part of any module and transcribes it almost verbatim to the output file.
No `\.{@}' signs should occur in such material except in `\.{@@}'
pairs; such pairs are replaced by singletons.

\Y\P\4\&{procedure}\1\  \37\\{copy\_limbo};\C{copy \TeX\ code until the next
module begins}\6
\4\&{label} \37\\{exit};\6
\4\&{var} \37\|c: \37\\{ASCII\_code};\C{character following \.{@} sign}\2\6
\&{begin} \37\~ \1\&{loop}\6
\&{if} $\\{loc}>\\{limit}$ \1\&{then}\6
\&{begin} \37\\{finish\_line};\5
\\{get\_line};\6
\&{if} $\\{input\_has\_ended}$ \1\&{then}\5
\&{return};\2\6
\&{end}\6
\4\&{else} \&{begin} \37$\\{buffer}[\\{limit}+1]\K\.{"@"}$;\5
\X133:Copy up to control code, \&{return} if finished\X;\6
\&{end};\2\2\6
\4\\{exit}: \37\&{end};\par
\fi

\M133. \P$\X133:Copy up to control code, \&{return} if finished\X\S$\6
\&{while} $\\{buffer}[\\{loc}]\I\.{"@"}$ \1\&{do}\6
\&{begin} \37$\\{out}(\\{buffer}[\\{loc}])$;\5
$\\{incr}(\\{loc})$;\6
\&{end};\2\6
\&{if} $\\{loc}\L\\{limit}$ \1\&{then}\6
\&{begin} \37$\\{loc}\K\\{loc}+2$;\5
$\|c\K\\{buffer}[\\{loc}-1]$;\6
\&{if} $(\|c=\.{"\ "})\V(\|c=\\{tab\_mark})\V(\|c=\.{"*"})$ \1\&{then}\5
\&{return};\2\6
\&{if} $(\|c\I\.{"z"})\W(\|c\I\.{"Z"})$ \1\&{then}\6
\&{begin} \37$\\{out}(\.{"@"})$;\6
\&{if} $\|c\I\.{"@"}$ \1\&{then}\5
$\\{err\_print}(\.{\'!\ Double\ @\ required\ outside\ of\ sections\'})$;\2\6
\&{end};\2\6
\&{end}\2\par
\U132.\fi

\M134. The \\{copy\_TeX} routine processes the \TeX\ code at the beginning of a
module; for example, the words you are now reading were copied in this
way. It returns the next control code or `\v' found in the input.

\Y\P\4\&{function}\1\  \37\\{copy\_TeX}: \37\\{eight\_bits};\C{copy pure \TeX\
material}\6
\4\&{label} \37\\{done};\6
\4\&{var} \37\|c: \37\\{eight\_bits};\C{control code found}\2\6
\&{begin} \37\~ \1\&{loop}\6
\&{begin} \37\&{if} $\\{loc}>\\{limit}$ \1\&{then}\6
\&{begin} \37\\{finish\_line};\5
\\{get\_line};\6
\&{if} $\\{input\_has\_ended}$ \1\&{then}\6
\&{begin} \37$\|c\K\\{new\_module}$;\5
\&{goto} \37\\{done};\6
\&{end};\2\6
\&{end};\2\6
$\\{buffer}[\\{limit}+1]\K\.{"@"}$;\5
\X135:Copy up to `\v' or control code, \&{goto} \\{done} if finished\X;\6
\&{end};\2\6
\4\\{done}: \37$\\{copy\_TeX}\K\|c$;\6
\&{end};\par
\fi

\M135. We don't copy spaces or tab marks into the beginning of a line. This
makes the test for empty lines in \\{finish\_line} work.

\Y\P$\4\X135:Copy up to `\v' or control code, \&{goto} \\{done} if finished\X%
\S$\6
\1\&{repeat} \37$\|c\K\\{buffer}[\\{loc}]$;\5
$\\{incr}(\\{loc})$;\6
\&{if} $\|c=\.{"|"}$ \1\&{then}\5
\&{goto} \37\\{done};\2\6
\&{if} $\|c\I\.{"@"}$ \1\&{then}\6
\&{begin} \37$\\{out}(\|c)$;\6
\&{if} $(\\{out\_ptr}=1)\W((\|c=\.{"\ "})\V(\|c=\\{tab\_mark}))$ \1\&{then}\5
$\\{decr}(\\{out\_ptr})$;\2\6
\&{end};\2\6
\4\&{until}\5
$\|c=\.{"@"}$;\2\6
\&{if} $\\{loc}\L\\{limit}$ \1\&{then}\6
\&{begin} \37$\|c\K\\{control\_code}(\\{buffer}[\\{loc}])$;\5
$\\{incr}(\\{loc})$;\5
\&{goto} \37\\{done};\6
\&{end}\2\par
\U134.\fi

\M136. The \\{copy\_comment} uses and returns a brace-balance value, following
the
conventions of \\{skip\_comment} above. Instead of copying the \TeX\ material
into the output buffer, this procedure copies it into the token memory.
The abbreviation $\\{app\_tok}(\|t)$ is used to append token \|t to the current
token list, and it also makes sure that it is possible to append at least
one further token without overflow.

\Y\P\D \37$\\{app\_tok}(\#)\S$\1\6
\&{begin} \37\&{if} $\\{tok\_ptr}+2>\\{max\_toks}$ \1\&{then}\5
$\\{overflow}(\.{\'token\'})$;\2\6
$\\{tok\_mem}[\\{tok\_ptr}]\K\#$;\5
$\\{incr}(\\{tok\_ptr})$;\6
\&{end}\2\par
\Y\P\4\&{function}\1\  \37$\\{copy\_comment}(\\{bal}:\\{eight\_bits})$: \37%
\\{eight\_bits};\C{copies \TeX\ code in   comments}\6
\4\&{label} \37\\{done};\6
\4\&{var} \37\|c: \37\\{ASCII\_code};\C{current character being copied}\2\6
\&{begin} \37\~ \1\&{loop}\6
\&{begin} \37\&{if} $\\{loc}>\\{limit}$ \1\&{then}\6
\&{begin} \37\\{get\_line};\6
\&{if} $\\{input\_has\_ended}$ \1\&{then}\6
\&{begin} \37$\\{err\_print}(\.{\'!\ Input\ ended\ in\ mid-comment\'})$;\5
$\\{loc}\K1$;\5
\X138:Clear \\{bal} and \&{goto} \\{done}\X;\6
\&{end};\2\6
\&{end};\2\6
$\|c\K\\{buffer}[\\{loc}]$;\5
$\\{incr}(\\{loc})$;\6
\&{if} $\|c=\.{"|"}$ \1\&{then}\5
\&{goto} \37\\{done};\2\6
$\\{app\_tok}(\|c)$;\5
\X137:Copy special things when $\|c=\.{"@"},\.{"\\"},\.{"\{"},\.{"\}"}$; %
\&{goto} \\{done} at end\X;\6
\&{end};\2\6
\4\\{done}: \37$\\{copy\_comment}\K\\{bal}$;\6
\&{end};\par
\fi

\M137. \P$\X137:Copy special things when $\|c=\.{"@"},\.{"\\"},\.{"\{"},\.{"%
\}"}$; \&{goto} \\{done} at end\X\S$\6
\&{if} $\|c=\.{"@"}$ \1\&{then}\6
\&{begin} \37$\\{incr}(\\{loc})$;\6
\&{if} $\\{buffer}[\\{loc}-1]\I\.{"@"}$ \1\&{then}\6
\&{begin} \37$\\{err\_print}(\.{\'!\ Illegal\ use\ of\ @\ in\ comment\'})$;\5
$\\{loc}\K\\{loc}-2$;\5
$\\{decr}(\\{tok\_ptr})$;\5
\X138:Clear \\{bal} and \&{goto} \\{done}\X;\6
\&{end};\2\6
\&{end}\6
\4\&{else} \&{if} $(\|c=\.{"\\"})\W(\\{buffer}[\\{loc}]\I\.{"@"})$ \1\&{then}\6
\&{begin} \37$\\{app\_tok}(\\{buffer}[\\{loc}])$;\5
$\\{incr}(\\{loc})$;\6
\&{end}\6
\4\&{else} \&{if} $\|c=\.{"\{"}$ \1\&{then}\5
$\\{incr}(\\{bal})$\6
\4\&{else} \&{if} $\|c=\.{"\}"}$ \1\&{then}\6
\&{begin} \37$\\{decr}(\\{bal})$;\6
\&{if} $\\{bal}=0$ \1\&{then}\5
\&{goto} \37\\{done};\2\6
\&{end}\2\2\2\2\par
\U136.\fi

\M138. When the comment has terminated abruptly due to an error, we output
enough right braces to keep \TeX\ happy.

\Y\P$\4\X138:Clear \\{bal} and \&{goto} \\{done}\X\S$\6
$\\{app\_tok}(\.{"\ "})$;\C{this is done in case the previous character was `\.%
\\'}\6
\1\&{repeat} \37$\\{app\_tok}(\.{"\}"})$;\5
$\\{decr}(\\{bal})$;\6
\4\&{until}\5
$\\{bal}=0$;\2\6
\&{goto} \37\\{done};\par
\Us136\ET137.\fi

\N139.  Parsing.
The most intricate part of \.{WEAVE} is its mechanism for converting
\PASCAL-like code into \TeX\ code, and we might as well plunge into this
aspect of the program now. A ``bottom up'' approach is used to parse the
\PASCAL-like material, since \.{WEAVE} must deal with fragmentary
constructions whose overall ``part of speech'' is not known.

At the lowest level, the input is represented as a sequence of entities
that we shall call {\it scraps}, where each scrap of information consists
of two parts, its {\it category} and its {\it translation}. The category
is essentially a syntactic class, and the translation is a token list that
represents \TeX\ code. Rules of syntax and semantics tell us how to
combine adjacent scraps into larger ones, and if we are lucky an entire
\PASCAL\ text that starts out as hundreds of small scraps will join
together into one gigantic scrap whose translation is the desired \TeX\
code. If we are unlucky, we will be left with several scraps that don't
combine; their translations will simply be output, one by one.

The combination rules are given as context-sensitive productions that are
applied from left to right. Suppose that we are currently working on the
sequence of scraps $s_1\,s_2\ldots s_n$. We try first to find the longest
production that applies to an initial substring $s_1\,s_2\ldots\,$; but if
no such productions exist, we find to find the longest production
applicable to the next substring $s_2\,s_3\ldots\,$; and if that fails, we
try to match $s_3\,s_4\ldots\,$, etc.

A production applies if the category codes have a given pattern. For
example, one of the productions is
$$\\{open}\;\\{math}\;\\{semi}\;\RA\;\\{open}\;\\{math}$$
and it means that three consecutive scraps whose respective categories are
\\{open}, \\{math}, and \\{semi} are con\-verted to two scraps whose categories
are \\{open} and \\{math}. This production also has an associated rule that
tells how to combine the translation parts:
$$\eqalign{O_2&=O_1\cr
M_2&=M_1\,S\,\.{\\,}\,\hbox{\\{opt}\thinspace\tt5}\cr}$$
This means that the \\{open} scrap has not changed, while the new \\{math}
scrap
has a translation $M_2$ composed of the translation $M_1$ of the original
\\{math} scrap followed by the translation \|S of the \\{semi} scrap followed
by `\.{\\,}' followed by `\\{opt}' followed by `\.5'. (In the \TeX\ file,
this will specify an additional thin space after the semicolon, followed
by an optional line break with penalty 50.) Translation rules use subscripts
to distinguish between translations of scraps whose categories have the
same initial letter; these subscripts are assigned from left to right.

$\.{WEAVE}$ also has the production rule
$$\\{semi}\;\RA\;\\{terminator}$$
(meaning that a semicolon can terminate a \PASCAL\ statement). Since
productions are applied from left to right, this rule will be activated
only if the \\{semi} is not preceded by scraps that match other productions;
in particular, a \\{semi} that is preceded by `\\{open} \\{math}' will have
disappeared because of the production above, and such semicolons do not
act as statement terminators.  This incidentally is how \.{WEAVE} is able
to treat semicolons in two distinctly different ways, the first of which
is intended for semicolons in the parameter list of a procedure
declaration.

The translation rule corresponding to $\\{semi}\;\RA\;\\{terminator}$ is
$$T=S$$
but we shall not mention translation rules in the common case that the
translation of the new scrap on the right-hand side is simply the
concatenation of the disappearing scraps on the left-hand side.

\fi

\M140. Here is a list of the category codes that scraps can have.

\Y\P\D \37$\\{simp}=1$\C{the translation can be used both in horizontal mode
and in math mode of \TeX}\par
\P\D \37$\\{math}=2$\C{the translation should be used only in \TeX\ math mode}%
\par
\P\D \37$\\{intro}=3$\C{a statement is expected to follow this, after a space
and   an optional break}\par
\P\D \37$\\{open}=4$\C{denotes an incomplete parenthesized quantity to be used
in   math mode}\par
\P\D \37$\\{beginning}=5$\C{denotes an incomplete compound statement to be used
in   horizontal mode}\par
\P\D \37$\\{close}=6$\C{ends a parenthesis or compound statement}\par
\P\D \37$\\{alpha}=7$\C{denotes the beginning of a clause}\par
\P\D \37$\\{omega}=8$\C{denotes the ending of a clause and possible comment
following}\par
\P\D \37$\\{semi}=9$\C{denotes a semicolon and possible comment following it}%
\par
\P\D \37$\\{terminator}=10$\C{something that ends a statement or declaration}%
\par
\P\D \37$\\{stmt}=11$\C{denotes a statement or declaration including its
terminator}\par
\P\D \37$\\{cond}=12$\C{precedes an \&{if} clause that might have a matching %
\&{else}}\par
\P\D \37$\\{clause}=13$\C{precedes a statement after which indentation ends}\par
\P\D \37$\\{colon}=14$\C{denotes a colon}\par
\P\D \37$\\{exp}=15$\C{stands for the E in a floating point constant}\par
\P\D \37$\\{proc}=16$\C{denotes a procedure or program or function heading}\par
\P\D \37$\\{case\_head}=17$\C{denotes a case statement or record heading}\par
\P\D \37$\\{record\_head}=18$\C{denotes a record heading without indentation}%
\par
\P\D \37$\\{var\_head}=19$\C{denotes a variable declaration heading}\par
\P\D \37$\\{elsie}=20$\C{\&{else}}\par
\P\D \37$\\{casey}=21$\C{\&{case}}\par
\P\D \37$\\{mod\_scrap}=22$\C{denotes a module name}\par
\Y\P\&{debug} \37\&{procedure}\1\  \37$\\{print\_cat}(\|c:\\{eight\_bits})$;%
\C{symbolic printout of a category}\2\6
\&{begin} \37\&{case} $\|c$ \1\&{of}\6
\4\\{simp}: \37$\\{print}(\.{\'simp\'})$;\6
\4\\{math}: \37$\\{print}(\.{\'math\'})$;\6
\4\\{intro}: \37$\\{print}(\.{\'intro\'})$;\6
\4\\{open}: \37$\\{print}(\.{\'open\'})$;\6
\4\\{beginning}: \37$\\{print}(\.{\'beginning\'})$;\6
\4\\{close}: \37$\\{print}(\.{\'close\'})$;\6
\4\\{alpha}: \37$\\{print}(\.{\'alpha\'})$;\6
\4\\{omega}: \37$\\{print}(\.{\'omega\'})$;\6
\4\\{semi}: \37$\\{print}(\.{\'semi\'})$;\6
\4\\{terminator}: \37$\\{print}(\.{\'terminator\'})$;\6
\4\\{stmt}: \37$\\{print}(\.{\'stmt\'})$;\6
\4\\{cond}: \37$\\{print}(\.{\'cond\'})$;\6
\4\\{clause}: \37$\\{print}(\.{\'clause\'})$;\6
\4\\{colon}: \37$\\{print}(\.{\'colon\'})$;\6
\4\\{exp}: \37$\\{print}(\.{\'exp\'})$;\6
\4\\{proc}: \37$\\{print}(\.{\'proc\'})$;\6
\4\\{case\_head}: \37$\\{print}(\.{\'casehead\'})$;\6
\4\\{record\_head}: \37$\\{print}(\.{\'recordhead\'})$;\6
\4\\{var\_head}: \37$\\{print}(\.{\'varhead\'})$;\6
\4\\{elsie}: \37$\\{print}(\.{\'elsie\'})$;\6
\4\\{casey}: \37$\\{print}(\.{\'casey\'})$;\6
\4\\{mod\_scrap}: \37$\\{print}(\.{\'module\'})$;\6
\4\&{othercases} \37$\\{print}(\.{\'UNKNOWN\'})$\2\6
\&{endcases};\6
\&{end};\6
\&{gubed}\par
\fi

\M141. The token lists for translated \TeX\ output contain some special control
symbols as well as ordinary characters. These control symbols are
interpreted by \.{WEAVE} before they are written to the output file.

\yskip\hang \\{break\_space} denotes an optional line break or an en space;

\yskip\hang \\{force} denotes a line break;

\yskip\hang \\{big\_force} denotes a line break with additional vertical space;

\yskip\hang \\{opt} denotes an optional line break (with the continuation
line indented two ems with respect to the normal starting position)---this
code is followed by an integer \|n, and the break will occur with penalty
$10n$;

\yskip\hang \\{backup} denotes a backspace of one em;

\yskip\hang \\{cancel} obliterates any \\{break\_space} or \\{force} or \\{big%
\_force}
tokens that immediately precede or follow it and also cancels any
\\{backup} tokens that follow it;

\yskip\hang \\{indent} causes future lines to be indented one more em;

\yskip\hang \\{outdent} causes future lines to be indented one less em.

\yskip\noindent All of these tokens are removed from the \TeX\ output that
comes from \PASCAL\ text between \pb\ signs; \\{break\_space} and \\{force} and
\\{big\_force} become single spaces in this mode. The translation of other
\PASCAL\ texts results in \TeX\ control sequences \.{\\1}, \.{\\2},
\.{\\3}, \.{\\4}, \.{\\5}, \.{\\6}, \.{\\7} corresponding respectively to
\\{indent}, \\{outdent}, \\{opt}, \\{backup}, \\{break\_space}, \\{force}, and
\\{big\_force}. However, a sequence of consecutive `\.\ ', \\{break\_space},
\\{force}, and/or \\{big\_force} tokens is first replaced by a single token
(the maximum of the given ones).

The tokens \\{math\_rel}, \\{math\_bin}, \\{math\_op} will be translated into
\.{\\mathrel\{}, \.{\\mathbin\{}, and \.{\\mathop\{}, respectively.
Other control sequences in the \TeX\ output will be `\.{\\\\\{}$\,\ldots\,$\.%
\}'
surrounding identifiers, `\.{\\\&\{}$\,\ldots\,$\.\}' surrounding
reserved words, `\.{\\.\{}$\,\ldots\,$\.\}' surrounding strings,
`\.{\\C\{}$\,\ldots\,$\.\}$\,$\\{force}' surrounding comments, and
`\.{\\X$n$:}$\,\ldots\,$\.{\\X}' surrounding module names, where
\|n is the module number.

\Y\P\D \37$\\{math\_bin}=\O{203}$\par
\P\D \37$\\{math\_rel}=\O{204}$\par
\P\D \37$\\{math\_op}=\O{205}$\par
\P\D \37$\\{big\_cancel}=\O{206}$\C{like \\{cancel}, also overrides spaces}\par
\P\D \37$\\{cancel}=\O{207}$\C{overrides \\{backup}, \\{break\_space}, %
\\{force}, \\{big\_force}}\par
\P\D \37$\\{indent}=\\{cancel}+1$\C{one more tab (\.{\\1})}\par
\P\D \37$\\{outdent}=\\{cancel}+2$\C{one less tab (\.{\\2})}\par
\P\D \37$\\{opt}=\\{cancel}+3$\C{optional break in mid-statement (\.{\\3})}\par
\P\D \37$\\{backup}=\\{cancel}+4$\C{stick out one unit to the left (\.{\\4})}%
\par
\P\D \37$\\{break\_space}=\\{cancel}+5$\C{optional break between statements (%
\.{\\5})}\par
\P\D \37$\\{force}=\\{cancel}+6$\C{forced break between statements (\.{\\6})}%
\par
\P\D \37$\\{big\_force}=\\{cancel}+7$\C{forced break with additional space (\.{%
\\7})}\par
\P\D \37$\\{end\_translation}=\\{big\_force}+1$\C{special sentinel token at end
of list}\par
\fi

\M142. The raw input is converted into scraps according to the following table,
which gives category codes followed by the translations. Sometimes a single
item of input produces more than one scrap.
\def\stars {\.{**}}%
(The symbol `\stars' stands for `\.{\\\&\{{\rm identifier}\}}',
i.e., the identifier itself treated as a reserved word. In a few cases the
category is given as `\\{comment}'; this is not an actual category code, it
means that the translation will be treated as a comment, as explained
below.)

\yskip\halign{\quad#\hfil&\quad#\hfil\cr
\.{<>}& \\{math}: \.{\\I}\cr
\.{<=}& \\{math}: \.{\\L}\cr
\.{>=}& \\{math}: \.{\\G}\cr
\.{:=}& \\{math}: \.{\\K}\cr
\.{==}& \\{math}: \.{\\S}\cr
\.{(*}& \\{math}: \.{\\B}\cr
\.{*)}& \\{math}: \.{\\T}\cr
\.{(.}& \\{open}: \.[\cr
\.{.)}& \\{close}: \.]\cr
\."$\,$string$\,$\."& \\{simp}: \.{\\.\{"{\rm$\,$modified string$\,$}"\}}\cr
\.\'$\,$string$\,$\.\'& \\{simp}: \.{\\.\{\\\'{\rm$\,$modified
string$\,$}\\\'\}}\cr
\.{@=}$\,$string$\,$\.{@>}& \\{simp}: \.{\\=\{{\rm$\,$modified string$\,$}\}}%
\cr
\#& \\{math}: \.{\\\#}\cr
\.\$& \\{math}: \.{\\\$}\cr
\.\_& \\{math}: \.{\\\_}\cr
\.\%& \\{math}: \.{\\\%}\cr
\.\^& \\{math}: \.{\\\^}\cr
\.(& \\{open}: \.(\cr
\.)& \\{close}: \.)\cr
\.[& \\{open}: \.[\cr
\.]& \\{close}: \.]\cr
\.*& \\{math}: \.{\\ast}\cr
\.,& \\{math}: \.,$\,\\{opt}\,$\.9\cr
\.{..}& \\{math}: \.{\\to}\cr
\..& \\{simp}: \..\cr
\.:& \\{colon}: \.:\cr
\.;& \\{semi}: \.;\cr
identifier& \\{simp}: \.{\\\\\{{\rm$\,$identifier$\,$}\}}\cr
\.E in constant& \\{exp}: \.{\\E\{}\cr
digit $d$& \\{simp}: $d$\cr
other character $c$& \\{math}: $c$\cr
\.{and}& \\{math}: \.{\\W}\cr
\.{array}& \\{alpha}: \stars\cr
\.{begin}& \\{beginning}: $\\{force}\,\stars\,\\{cancel}$\qquad \\{intro}: \cr
\.{case}& \\{casey}: \qquad \\{alpha}: $\\{force}\,\stars$\cr
\.{const}& \\{intro}: $\\{force}\,\\{backup}\,\stars$\cr
\.{div}& \\{math}: $\\{math\_bin}\,\stars\,\.\}$\cr
\.{do}& \\{omega}: \stars\cr
\.{downto}& \\{math}: $\\{math\_rel}\,\stars\,\.\}$\cr
\.{else}& \\{terminator}: \qquad \\{elsie}: $\\{force}\,\\{backup}\,\stars$\cr
\.{end}& \\{terminator}: \qquad \\{close}: $\\{force}\,\stars$\cr
\.{file}& \\{alpha}: \stars\cr
\.{for}& \\{alpha}: $\\{force}\,\stars$\cr
\.{function}& \\{proc}: $\\{force}\,\\{backup}\,\stars\,\\{cancel}$\qquad
 \\{intro}: $\\{indent}\,\.{\\\ }$\cr
\.{goto}& \\{intro}: \stars\cr
\.{if}& \\{cond}: \qquad \\{alpha}: $\\{force}\,\stars$\cr
\.{in}& \\{math}: \.{\\in}\cr
\.{label}& \\{intro}: $\\{force}\,\\{backup}\,\stars$\cr
\.{mod}& \\{math}: $\\{math\_bin}\,\stars\,\.\}$\cr
\.{nil}& \\{simp}: \stars\cr
\.{not}& \\{math}: \.{\\R}\cr
\.{of}& \\{omega}: \stars\cr
\.{or}& \\{math}: \.{\\V}\cr
\.{packed}& \\{intro}: \stars\cr
\.{procedure}& \\{proc}: $\\{force}\,\\{backup}\,\stars\,\\{cancel}$\qquad
 \\{intro}: $\\{indent}\,\.{\\\ }$\cr
\.{program}& \\{proc}: $\\{force}\,\\{backup}\,\stars\,\\{cancel}$\qquad
 \\{intro}: $\\{indent}\,\.{\\\ }$\cr
\.{record}& \\{record\_head}: \stars\qquad \\{intro}: \cr
\.{repeat}& \\{beginning}: $\\{force}\,\\{indent}\,\stars\,\\{cancel}$\qquad %
\\{intro}: \cr
\.{set}& \\{alpha}: \stars\cr
\.{then}& \\{omega}: \stars\cr
\.{to}& \\{math}: $\\{math\_rel}\,\stars\,\.\}$\cr
\.{type}& \\{intro}: $\\{force}\,\\{backup}\,\stars$\cr
\.{until}& \\{terminator}: \qquad \\{close}: $\\{force}\,\\{backup}\,\stars$%
\qquad
 \\{clause}: \cr
\.{var}& \\{var\_head}: $\\{force}\,\\{backup}\,\stars\,\\{cancel}$\qquad %
\\{intro}: \cr
\.{while}& \\{alpha}: $\\{force}\,\stars$\cr
\.{with}& \\{alpha}: $\\{force}\,\stars$\cr
\.{xclause}& \\{alpha}: $\\{force}\,\.{\\\~}$\qquad \\{omega}: \stars\cr
\.{@\'}$\,$const& \\{simp}: \.{\\O\{}\hbox{const}\.\}\cr
\.{@"}$\,$const& \\{simp}: \.{\\H\{}\hbox{const}\.\}\cr
\.{@\$}& \\{simp}: \.{\\)}\cr
\.{@\\}& \\{simp}: \.{\\]}\cr
\.{@,}& \\{math}: \.{\\,}\cr
\.{@t}$\,$stuff$\,$\.{@>}& \\{simp}: \.{\\hbox\{{\rm$\,$stuff$\,$}\}}\cr
\.{@<}$\,$module$\,$\.{@>}& \\{mod\_scrap}: \.{\\X$n$:{\rm$\,$module$\,$}\\X}%
\cr
\.{@\#}& \\{comment}: \\{big\_force}\cr
\.{@/}& \\{comment}: \\{force}\cr
\.{@\char'174}& \\{simp}: $\\{opt}\,\.0$\cr
\.{@+}& \\{comment}: $\\{big\_cancel}\,\.{\\\ }\,\\{big\_cancel}$\cr
\.{@;}& \\{semi}: \cr
\.{@\&}& \\{math}: \.{\\J}\cr
\.{@\{}& \\{math}: \.{\\B}\cr
\.{@\}}& \\{math}: \.{\\T}\cr}
\yskip\noindent When a string is output, certain characters are preceded by
`\.\\' signs so that they will print properly.

A comment in the input will be combined with the preceding
\\{omega} or \\{semi} scrap, or with the following \\{terminator} scrap, if
possible; otherwise it will be inserted as a separate \\{terminator} scrap.
An additional ``comment'' is effectively appended at the end of the
\PASCAL\ text, just before translation begins; this consists of a \\{cancel}
token in the case of \PASCAL\ text in \pb, otherwise it consists of a
\\{force} token.

From this table it is evident that \.{WEAVE} will parse a lot of non-\PASCAL\
programs. For example, the reserved words `\.{for}' and `\.{array}' are
treated in an identical way by \.{WEAVE} from a syntactic standpoint,
and semantically they are equivalent except that a forced line break occurs
just before `\&{for}'; \PASCAL\ programmers may well be surprised at this
similarity. The idea is to keep \.{WEAVE}'s rules as simple as possible,
consistent with doing a reasonable job on syntactically correct \PASCAL\
programs. The production rules below have been formulated in the same
spirit of ``almost anything goes.''

\fi

\M143. Here is a table of all the productions. The reader can best get a feel
for
how they work by trying them out by hand on small examples; no amount of
explanation will be as effective as watching the rules in action.
Parsing can also be watched by debugging with `\.{@2}'.

\def\[#1]{\quad$\dleft#1\dright$}
\def\sp{\.{\ }}
\yskip
\halign to\the\hsize{\hfil\it# &
#\hfil\hskip-200pt\tabskip 0pt plus 100pt&
#\hfil\tabskip0pt\cr
&Production categories\[\hbox{translations}]&Remarks\cr
\noalign{\yskip}
1&$\\{alpha}\,\\{math}\,\\{colon}$ $\RA$ $\\{alpha}\,\\{math}$&e.g.,  \&{case}
$\|v:\\{boolean}$ \&{of}\cr
2&$\\{alpha}\,\\{math}\,\\{omega}$ $\RA$ \\{clause}\[C=A\,\sp\,\.\$\,M\,\.\$\,%
\sp\,\\{indent}\,
O]&e.g.,  \&{while} $\|x>0$ \&{do}\cr
3&$\\{alpha}\,\\{omega}$ $\RA$ \\{clause}\[C=A\,\sp\,\\{indent}\,O]&e.g., %
\&{file} \&{of}\cr
4&$\\{alpha}\,\\{simp}$ $\RA$ $\\{alpha}\,\\{math}$&convert to math mode\cr
5&$\\{beginning}\,\\{close}\,(\\{terminator}\hbox{ or }\\{stmt})$ $\RA$ %
\\{stmt}&compound statement
ends\cr
6&$\\{beginning}\,\\{stmt}$ $\RA$ \\{beginning}\[B_2=B_1\,\\{break\_space}%
\,S]&compound
statement grows\cr
7&$\\{case\_head}\,\\{casey}\,\\{clause}$ $\RA$ \\{case\_head}\[C_4=C_1\,%
\\{outdent}\,C_2\,C_3]&
variant records\cr
8&$\\{case\_head}\,\\{close}\,\\{terminator}$ $\RA$ \\{stmt}\[S=C_1\,\\{cancel}%
\,\\{outdent}\,
C_2\,T]&end of case statement\cr
9&$\\{case\_head}\,\\{stmt}$ $\RA$ \\{case\_head}\[C_2=C_1\,\\{force}\,S]&case
statement
grows\cr
10&$\\{casey}\,\\{clause}$ $\RA$ \\{case\_head}&beginning of case statement\cr
11&$\\{clause}\,\\{stmt}$ $\RA$ \\{stmt}\[S_2=C\,\\{break\_space}\,S_1\,%
\\{cancel}\,\\{outdent}\,
\\{force}]&end of controlled statement\cr
12&$\\{cond}\,\\{clause}\,\\{stmt}\,\\{elsie}$ $\RA$ \\{clause}\[C_3=C_1\,C_2\,%
\\{break\_space}\,S\,
E\,\sp\,\\{cancel}]&complete conditional\cr
13&$\\{cond}\,\\{clause}\,\\{stmt}$ $\RA$ \\{stmt}\cr
&\qquad\[S_2=C_1\,C_2\,\\{break\_space}\,S_1\,
\\{cancel}\,\\{outdent}\,\\{force}]&incomplete conditional\cr
14&\\{elsie} $\RA$ \\{intro}&unmatched else\cr
15&$\\{exp}\,\\{math}\,\\{simp}$* $\RA$ \\{math}\[M_2=E\,M_1\,S\,\.\}]&signed
exponent\cr
16&$\\{exp}\,\\{simp}$* $\RA$ \\{math}\[M=E\,S\,\.\}]&unsigned exponent\cr
17&$\\{intro}\,\\{stmt}$ $\RA$ \\{stmt}\[S_2=I\,\sp\,\\{opt}\,\.7\,\\{cancel}%
\,S_1]&labeled
statement, etc.\cr
18&$\\{math}\,\\{close}$ $\RA$ $\\{stmt}\,\\{close}$\[S=\.\$\,M\,\.\$]&end of
field list\cr
19&$\\{math}\,\\{colon}$ $\RA$ \\{intro}\[I=\\{force}\,\\{backup}\,\.\$\,M\,\.%
\$\,C]&compound
label\cr
20&$\\{math}\,\\{math}$ $\RA$ \\{math}&simple concatenation\cr
21&$\\{math}\,\\{simp}$ $\RA$ \\{math}&simple concatenation\cr
22&$\\{math}\,\\{stmt}$ $\RA$ \\{stmt}\cr
&\qquad\[S_2=\.\$\,M\,\.\$\,\\{indent}\,\\{break\_space}\,
S_1\,\\{cancel}\,\\{outdent}\,\\{force}]&macro or type definition\cr
23&$\\{math}\,\\{terminator}$ $\RA$ \\{stmt}\[S=\.\$\,M\,\.\$\,T]&statement
involving
math\cr
24&$\\{mod\_scrap}\,(\\{terminator}\hbox{ or }\\{semi})$ $\RA$ \\{stmt}\[S=M\,T%
\,\\{force}]&module
like a statement\cr
25&\\{mod\_scrap} $\RA$ \\{simp}&module unlike a statement\cr
26&$\\{open}\,\\{case\_head}\,\\{close}$ $\RA$ \\{math}\[M=O\,\.\$\,\\{cancel}%
\,C_1\,
\\{cancel}\,\\{outdent}\,\.\$\,C_2]&case in field list\cr
27&$\\{open}\,\\{close}$ $\RA$ \\{math}\[M=O\,\.\\\,\.,\,C]&empty set $[\,]$\cr
28&$\\{open}\,\\{math}\,\\{case\_head}\,\\{close}$ $\RA$ \\{math}\cr
&\qquad\[M_2=O\,M_1\,\.\$\,\\{cancel}\,
C_1\,\\{cancel}\,\\{outdent}\,\.\$\,C_2]&case in field list\cr
29&$\\{open}\,\\{math}\,\\{close}$ $\RA$ \\{math}&parenthesized group\cr
30&$\\{open}\,\\{math}\,\\{colon}$ $\RA$ $\\{open}\,\\{math}$&colon in
parentheses\cr
31&$\\{open}\,\\{math}\,\\{proc}\,\\{intro}$ $\RA$ $\\{open}\,\\{math}$%
\[M_2=M_1\,\\{math\_op}\,\\{cancel}\,
P\,\.\}]& \&{procedure}\   in parentheses\cr
32&$\\{open}\,\\{math}\,\\{semi}$ $\RA$ $\\{open}\,\\{math}$\[M_2=M_1\,S\,\.%
\\\,\.,\,\\{opt}\,
\.5]&semicolon in parentheses\cr
33&$\\{open}\,\\{math}\,\\{var\_head}\,\\{intro}$ $\RA$ $\\{open}\,\\{math}$%
\[M_2=M_1\,\\{math\_op}\,
\\{cancel}\,V\,\.\}]& \&{var}  in parentheses\cr
34&$\\{open}\,\\{proc}\,\\{intro}$ $\RA$ $\\{open}\,\\{math}$\[M=\\{math\_op}\,%
\\{cancel}\,
P\,\.\}]& \&{procedure}\   in parentheses\cr
35&$\\{open}\,\\{simp}$ $\RA$ $\\{open}\,\\{math}$&convert to math mode\cr
36&$\\{open}\,\\{stmt}\,\\{close}$ $\RA$ \\{math}\[M=O\,\.\$\,\\{cancel}\,S\,%
\\{cancel}\,
\.\$\,C]&field list\cr
37&$\\{open}\,\\{var\_head}\,\\{intro}$ $\RA$ $\\{open}\,\\{math}$\[M=\\{math%
\_op}\,\\{cancel}\,V\,
\.\}]& \&{var}  in parentheses\cr
38&$\\{proc}\,\\{beginning}\,\\{close}\,\\{terminator}$ $\RA$ \\{stmt}\[S=P\,%
\\{cancel}\,
\\{outdent}\,B\,C\,T]&end of procedure declaration\cr
39&$\\{proc}\,\\{stmt}$ $\RA$ \\{proc}\[P_2=P_1\,\\{break\_space}\,S]&procedure
declaration
grows\cr
40&$\\{record\_head}\,\\{intro}\,\\{casey}$ $\RA$ \\{casey}\[C_2=R\,I\,\sp\,%
\\{cancel}\,C_1]&
\&{record case} $\ldots$\cr
41&\\{record\_head} $\RA$ \\{case\_head}\[C=\\{indent}\,R\,\\{cancel}]&other %
\&{record}
structures\cr
42&\\{semi} $\RA$ \\{terminator}&semicolon after statement\cr
43&$\\{simp}\,\\{close}$ $\RA$ $\\{stmt}\,\\{close}$&end of field list\cr
44&$\\{simp}\,\\{colon}$ $\RA$ \\{intro}\[I=\\{force}\,\\{backup}\,S\,C]&simple
label\cr
45&$\\{simp}\,\\{math}$ $\RA$ \\{math}&simple concatenation\cr
46&$\\{simp}\,\\{mod\_scrap}$ $\RA$ \\{mod\_scrap}&in emergencies\cr
47&$\\{simp}\,\\{simp}$ $\RA$ \\{simp}&simple concatenation\cr
48&$\\{simp}\,\\{terminator}$ $\RA$ \\{stmt}&simple statement\cr
49&$\\{stmt}\,\\{stmt}$ $\RA$ \\{stmt}\[S_3=S_1\,\\{break\_space}%
\,S_2]&adjacent
statements\cr
50&\\{terminator} $\RA$ \\{stmt}&empty statement\cr
51&$\\{var\_head}\,\\{beginning}$ $\RA$ $\\{stmt}\,\\{beginning}$&end of
variable
declarations\cr
52&$\\{var\_head}\,\\{math}\,\\{colon}$ $\RA$ $\\{var\_head}\,\\{intro}$\[I=\.%
\$\,M\,\.\$\,C]&
variable declaration\cr
53&$\\{var\_head}\,\\{simp}\,\\{colon}$ $\RA$ $\\{var\_head}\,%
\\{intro}$&variable declaration\cr
54&$\\{var\_head}\,\\{stmt}$ $\RA$ \\{var\_head}\[V_2=V_1\,\\{break\_space}%
\,S]&variable
declarations grow\cr}
\yskip\noindent
Translations are not specified here when they are simple concatenations
of the scraps that change. For example, the full translation of
`$\\{open}\,\\{math}\,\\{colon}$ $\RA$ $\\{open}\,\\{math}$' is $O_2=O_1$,
$M_2=M_1C$.

The notation `\\{simp}*', in the \\{exp}-related productions above,
stands for a \\{simp} scrap that isn't followed by another \\{simp}.

\fi

\N144.  Implementing the productions.
When \PASCAL\ text is to be processed with the grammar above, we put its
initial scraps $s_1\ldots s_n$ into two arrays $\\{cat}[1\to\|n]$ and $%
\\{trans}[1\to\|n]$.
The value of $\\{cat}[\|k]$ is simply a category code from the list above; the
value of $\\{trans}[\|k]$ is a text pointer, i.e., an index into \\{tok%
\_start}.
Our production rules have the nice property that the right-hand side is never
longer than the left-hand side. Therefore it is convenient to use sequential
allocation for the current sequence of scraps. Five pointers are used to
manage the parsing:

\yskip\hang \\{pp} (the parsing pointer) is such that we are trying to match
the category codes $\\{cat}[\\{pp}]\,\\{cat}[\\{pp}+1]$$\,\ldots\,$ to the
left-hand sides
of productions.

\yskip\hang \\{scrap\_base}, \\{lo\_ptr}, \\{hi\_ptr}, and \\{scrap\_ptr} are
such that
the current sequence of scraps appears in positions \\{scrap\_base} through
\\{lo\_ptr} and \\{hi\_ptr} through \\{scrap\_ptr}, inclusive, in the \\{cat}
and
\\{trans} arrays. Scraps located between \\{scrap\_base} and \\{lo\_ptr} have
been examined, while those in positions $\G\\{hi\_ptr}$ have not yet been
looked at by the parsing process.

\yskip\noindent Initially \\{scrap\_ptr} is set to the position of the final
scrap to be parsed, and it doesn't change its value. The parsing process
makes sure that $\\{lo\_ptr}\G\\{pp}+3$, since productions have as many as four
terms,
by moving scraps from \\{hi\_ptr} to \\{lo\_ptr}. If there are
fewer than $\\{pp}+3$ scraps left, the positions up to $\\{pp}+3$ are filled
with
blanks that will not match in any productions. Parsing stops when
$\\{pp}=\\{lo\_ptr}+1$ and $\\{hi\_ptr}=\\{scrap\_ptr}+1$.

The \\{trans} array elements are declared to be of type $0\to10239$ instead
of type \\{text\_pointer}, because the final sorting phase of \.{WEAVE}
uses this array to contain elements of type \\{name\_pointer}. Both
of these types are subranges of $0\to10239$.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{cat}: \37\&{array} $[0\to\\{max\_scraps}]$ \1\&{of}\5
\\{eight\_bits};\C{category codes of scraps}\2\6
\4\\{trans}: \37\&{array} $[0\to\\{max\_scraps}]$ \1\&{of}\5
$0\to10239$;\C{translation texts of scraps}\2\6
\4\\{pp}: \37$0\to\\{max\_scraps}$;\C{current position for reducing
productions}\6
\4\\{scrap\_base}: \37$0\to\\{max\_scraps}$;\C{beginning of the current scrap
sequence}\6
\4\\{scrap\_ptr}: \37$0\to\\{max\_scraps}$;\C{ending of the current scrap
sequence}\6
\4\\{lo\_ptr}: \37$0\to\\{max\_scraps}$;\C{last scrap that has been examined}\6
\4\\{hi\_ptr}: \37$0\to\\{max\_scraps}$;\C{first scrap that has not been
examined}\6
\&{stat} \37\\{max\_scr\_ptr}: \37$0\to\\{max\_scraps}$;\C{largest value
assumed by \\{scrap\_ptr}}\6
\&{tats}\par
\fi

\M145. \P$\X10:Set initial values\X\mathrel{+}\S$\6
$\\{scrap\_base}\K1$;\5
$\\{scrap\_ptr}\K0$;\6
\&{stat} \37$\\{max\_scr\_ptr}\K0$;\ \&{tats}\par
\fi

\M146. Token lists in \\{tok\_mem} are composed of the following kinds of
items for \TeX\ output.

\yskip\item{$\bullet$}ASCII codes and special codes like \\{force} and
\\{math\_rel} represent themselves;

\item{$\bullet$}$\\{id\_flag}+\|p$ represents \.{\\\\\{{\rm identifier $p$}\}};

\item{$\bullet$}$\\{res\_flag}+\|p$ represents \.{\\\&\{{\rm identifier $p$}%
\}};

\item{$\bullet$}$\\{mod\_flag}+\|p$ represents module name \|p;

\item{$\bullet$}$\\{tok\_flag}+\|p$ represents token list number \|p;

\item{$\bullet$}$\\{inner\_tok\_flag}+\|p$ represents token list number \|p, to
be
translated without line-break controls.

\Y\P\D \37$\\{id\_flag}=10240$\C{signifies an identifier}\par
\P\D \37$\\{res\_flag}=\\{id\_flag}+\\{id\_flag}$\C{signifies a reserved word}%
\par
\P\D \37$\\{mod\_flag}=\\{res\_flag}+\\{id\_flag}$\C{signifies a module name}%
\par
\P\D \37$\\{tok\_flag}\S\\{mod\_flag}+\\{id\_flag}$\C{signifies a token list}%
\par
\P\D \37$\\{inner\_tok\_flag}\S\\{tok\_flag}+\\{id\_flag}$\C{signifies a token
list in `\pb'}\Y\par
\P\D \37$\\{lbrace}\S\\{xchr}[\.{"\{"}]$\C{this avoids possible \PASCAL\
compiler confusion}\par
\P\D \37$\\{rbrace}\S\\{xchr}[\.{"\}"}]$\C{because these braces might occur
within comments}\par
\Y\P\&{debug} \37\&{procedure}\1\  \37$\\{print\_text}(\|p:\\{text\_pointer})$;%
\C{prints a token list}\6
\4\&{var} \37\|j: \37$0\to\\{max\_toks}$;\C{index into \\{tok\_mem}}\6
\|r: \37$0\to\\{id\_flag}-1$;\C{remainder of token after the flag has been
stripped off}\2\6
\&{begin} \37\&{if} $\|p\G\\{text\_ptr}$ \1\&{then}\5
$\\{print}(\.{\'BAD\'})$\6
\4\&{else} \&{for} $\|j\K\\{tok\_start}[\|p]\mathrel{\&{to}}\\{tok\_start}[%
\|p+1]-1$ \1\&{do}\6
\&{begin} \37$\|r\K\\{tok\_mem}[\|j]\mathbin{\&{mod}}\\{id\_flag}$;\6
\&{case} $\\{tok\_mem}[\|j]\mathbin{\&{div}}\\{id\_flag}$ \1\&{of}\6
\41: \37\&{begin} \37$\\{print}(\.{\'\\\\\'},\39\\{lbrace})$;\5
$\\{print\_id}(\|r)$;\5
$\\{print}(\\{rbrace})$;\6
\&{end};\C{\\{id\_flag}}\6
\42: \37\&{begin} \37$\\{print}(\.{\'\\\&\'},\39\\{lbrace})$;\5
$\\{print\_id}(\|r)$;\5
$\\{print}(\\{rbrace})$;\6
\&{end};\C{\\{res\_flag}}\6
\43: \37\&{begin} \37$\\{print}(\.{\'<\'})$;\5
$\\{print\_id}(\|r)$;\5
$\\{print}(\.{\'>\'})$;\6
\&{end};\C{\\{mod\_flag}}\6
\44: \37$\\{print}(\.{\'[[\'},\39\|r:1,\39\.{\']]\'})$;\C{\\{tok\_flag}}\6
\45: \37$\\{print}(\.{\'|[[\'},\39\|r:1,\39\.{\']]|\'})$;\C{\\{inner\_tok%
\_flag}}\6
\4\&{othercases} \37\X147:Print token \|r in symbolic form\X\2\6
\&{endcases};\6
\&{end};\2\2\6
\&{end};\6
\&{gubed}\par
\fi

\M147. \P$\X147:Print token \|r in symbolic form\X\S$\6
\&{case} $\|r$ \1\&{of}\6
\4\\{math\_bin}: \37$\\{print}(\.{\'\\mathbin\'},\39\\{lbrace})$;\6
\4\\{math\_rel}: \37$\\{print}(\.{\'\\mathrel\'},\39\\{lbrace})$;\6
\4\\{math\_op}: \37$\\{print}(\.{\'\\mathop\'},\39\\{lbrace})$;\6
\4\\{big\_cancel}: \37$\\{print}(\.{\'[ccancel]\'})$;\6
\4\\{cancel}: \37$\\{print}(\.{\'[cancel]\'})$;\6
\4\\{indent}: \37$\\{print}(\.{\'[indent]\'})$;\6
\4\\{outdent}: \37$\\{print}(\.{\'[outdent]\'})$;\6
\4\\{backup}: \37$\\{print}(\.{\'[backup]\'})$;\6
\4\\{opt}: \37$\\{print}(\.{\'[opt]\'})$;\6
\4\\{break\_space}: \37$\\{print}(\.{\'[break]\'})$;\6
\4\\{force}: \37$\\{print}(\.{\'[force]\'})$;\6
\4\\{big\_force}: \37$\\{print}(\.{\'[fforce]\'})$;\6
\4\\{end\_translation}: \37$\\{print}(\.{\'[quit]\'})$;\6
\4\&{othercases} \37$\\{print}(\\{xchr}[\|r])$\2\6
\&{endcases}\par
\U146.\fi

\M148. The production rules listed above are embedded directly into the %
\.{WEAVE}
program, since it is easier to do this than to write an interpretive system
that would handle production systems in general. Several macros are defined
here so that the program for each production is fairly short.

All of our productions conform to the general notion that some \|k
consecutive scraps starting at some position \|j are to be replaced by a
single scrap of some category \|c whose translation is composed from the
translations of the disappearing scraps. After this production has been
applied, the production pointer \\{pp} should change by an amount \|d. Such
a production can be represented by the quadruple $(j,k,c,d)$. For example,
the production `$\\{simp}\,\\{math}$ $\RA$ \\{math}' would be represented by
`$(\\{pp},2,\\{math},-1)$'; in this case the pointer $pp$ should decrease by 1
after the production has been applied, because some productions with
\\{math} in their second positions might now match, but no productions have
\\{math} in the third or fourth position of their left-hand sides. Note that
the value of \|d is determined by the whole collection of productions, not
by an individual one. Consider the further example
`$\\{var\_head}\,\\{math}\,\\{colon}$ $\RA$ $\\{var\_head}\,\\{intro}$', which
is represented by
`$(\\{pp}+1,2,\\{intro},+1)$'; the $+1$ here is deduced by looking at the
grammar and seeing that no matches could possibly occur at positions $\L\\{pp}$
after this production has been applied. The determination of \|d has been
done by hand in each case, based on the full set of productions but not on
the grammar of \PASCAL\ or on the rules for constructing the initial
scraps.

We also attach a serial number to each production, so that additional
information is available when debugging. For example, the program below
contains the statement `$\\{reduce}(\\{pp}+1,2,\\{intro},+1)(52)$' when it
implements
the production just mentioned.

Before calling \\{reduce}, the program should have appended the tokens of
the new translation to the \\{tok\_mem} array. We commonly want to append
copies of several existing translations, and macros are defined to
simplify these common cases. For example, $\\{app2}(\\{pp})$ will append the
translations of two consecutive scraps, $\\{trans}[\\{pp}]$ and $\\{trans}[%
\\{pp}+1]$, to
the current token list. If the entire new translation is formed in this
way, we write `$\\{squash}(j,k,c,d)$' instead of `$\\{reduce}(j,k,c,d)$'. For
example, `$\\{squash}(\\{pp},2,\\{math},-1)$' is an abbreviation for `$%
\\{app2}(\\{pp})$; $\\{reduce}(\\{pp},2,\\{math},-1)$'.

The code below is an exact translation of the production rules into
\PASCAL, using such macros, and the reader should have no difficulty
understanding the format by comparing the code with the symbolic
productions as they were listed earlier.

{\sl Caution:\/} The macros \\{app}, \\{app1}, \\{app2}, and \\{app3} are
sequences of statements that are not enclosed with  \&{begin}  and $  \&{end}
$,
because such delimiters would make the \PASCAL\ program much longer. This
means that it is necessary to write  \&{begin}  and   \&{end}  explicitly when
such
a macro is used as a single statement. Several mysterious bugs in the
original programming of \.{WEAVE} were caused by a failure to remember
this fact.  Next time the author will know better.

\Y\P\D \37$\\{production}(\#)\S$\1\6
\&{debug} \37$\\{prod}(\#)$\6
\&{gubed};\2\6
\&{goto} \37\\{found}\par
\P\D \37$\\{reduce}(\#)\S\\{red}(\#)$;\5
\\{production}\par
\P\D \37$\\{production\_end}(\#)\S$\1\6
\&{debug} \37$\\{prod}(\#)$\6
\&{gubed};\2\6
\&{goto} \37\\{found}; \6
\&{end} \par
\P\D $\\{squash}(\#)\S$ \6
\&{begin} \37$\\{sq}(\#)$;\5
\\{production\_end}\par
\P\D \37$\\{app}(\#)\S\\{tok\_mem}[\\{tok\_ptr}]\K\#$;\5
$\\{incr}(\\{tok\_ptr})$\C{this is like \\{app\_tok},   but it doesn't test for
overflow}\par
\P\D \37$\\{app1}(\#)\S\\{tok\_mem}[\\{tok\_ptr}]\K\\{tok\_flag}+\\{trans}[%
\#]$;\5
$\\{incr}(\\{tok\_ptr})$\par
\P\D \37$\\{app2}(\#)\S\\{app1}(\#)$;\5
$\\{app1}(\#+1)$\par
\P\D \37$\\{app3}(\#)\S\\{app2}(\#)$;\5
$\\{app1}(\#+2)$\par
\fi

\M149. Let us consider the big case statement for productions now, before
looking
at its context. We want to design the program so that this case statement
works, so we might as well not keep ourselves in suspense about exactly what
code needs to be provided with a proper environment.

The code here is more complicated than it need be, since some popular
\PASCAL\ compilers are unable to deal with procedures that contain a lot
of program text. The \\{translate} procedure, which incorporates the   \&{case}
statement here, would become too long for those compilers if we did
not do something to split the cases into parts. Therefore
a separate procedure called \\{five\_cases} has been introduced.
This auxiliary procedure contains approximately half of the program text
that \\{translate} would otherwise have had. There's also a procedure
called \\{alpha\_cases}, which turned out to be necessary because the best
two-way split wasn't good enough. The procedure could be split further
in an analogous manner, but the present scheme works on all compilers
known to the author.

\Y\P$\4\X149:Match a production at \\{pp}, or increase \\{pp} if there is no
match\X\S$\6
\&{if} $\\{cat}[\\{pp}]\L\\{alpha}$ \1\&{then}\6
\&{if} $\\{cat}[\\{pp}]<\\{alpha}$ \1\&{then}\5
\\{five\_cases}\ \&{else} \\{alpha\_cases}\2\6
\4\&{else} \&{begin} \37\&{case} $\\{cat}[\\{pp}]$ \1\&{of}\6
\4\\{case\_head}: \37\X153:Cases for \\{case\_head}\X;\6
\4\\{casey}: \37\X154:Cases for \\{casey}\X;\6
\4\\{clause}: \37\X155:Cases for \\{clause}\X;\6
\4\\{cond}: \37\X156:Cases for \\{cond}\X;\6
\4\\{elsie}: \37\X157:Cases for \\{elsie}\X;\6
\4\\{exp}: \37\X158:Cases for \\{exp}\X;\6
\4\\{mod\_scrap}: \37\X161:Cases for \\{mod\_scrap}\X;\6
\4\\{proc}: \37\X164:Cases for \\{proc}\X;\6
\4\\{record\_head}: \37\X165:Cases for \\{record\_head}\X;\6
\4\\{semi}: \37\X166:Cases for \\{semi}\X;\6
\4\\{stmt}: \37\X168:Cases for \\{stmt}\X;\6
\4\\{terminator}: \37\X169:Cases for \\{terminator}\X;\6
\4\\{var\_head}: \37\X170:Cases for \\{var\_head}\X;\6
\4\&{othercases} \37\\{do\_nothing}\2\6
\&{endcases};\6
$\\{incr}(\\{pp})$;\C{if no match was found, we move to the right}\6
\4\\{found}: \37\&{end}\2\par
\U175.\fi

\M150. Here are the procedures that need to be present for the reason just
explained.

\Y\P$\4\X150:Declaration of subprocedures for \\{translate}\X\S$\6
\4\&{procedure}\1\  \37\\{five\_cases};\C{handles almost half of the syntax}\6
\4\&{label} \37\\{found};\2\6
\&{begin} \37\&{case} $\\{cat}[\\{pp}]$ \1\&{of}\6
\4\\{beginning}: \37\X152:Cases for \\{beginning}\X;\6
\4\\{intro}: \37\X159:Cases for \\{intro}\X;\6
\4\\{math}: \37\X160:Cases for \\{math}\X;\6
\4\\{open}: \37\X162:Cases for \\{open}\X;\6
\4\\{simp}: \37\X167:Cases for \\{simp}\X;\6
\4\&{othercases} \37\\{do\_nothing}\2\6
\&{endcases};\6
$\\{incr}(\\{pp})$;\C{if no match was found, we move to the right}\6
\4\\{found}: \37\&{end};\7
\4\&{procedure}\1\  \37\\{alpha\_cases};\6
\4\&{label} \37\\{found};\2\6
\&{begin} \37\X151:Cases for \\{alpha}\X;\6
$\\{incr}(\\{pp})$;\C{if no match was found, we move to the right}\6
\4\\{found}: \37\&{end};\par
\U179.\fi

\M151. Now comes the code that tries to match each production starting
with a particular type of scrap. Whenever a match is discovered,
the \\{squash} or \\{reduce} macro will cause the appropriate action
to be performed, followed by \&{goto} \\{found}.

\Y\P$\4\X151:Cases for \\{alpha}\X\S$\6
\&{if} $\\{cat}[\\{pp}+1]=\\{math}$ \1\&{then}\6
\&{begin} \37\&{if} $\\{cat}[\\{pp}+2]=\\{colon}$ \1\&{then}\5
$\\{squash}(\\{pp}+1,\392,\39\\{math},\390)(1)$\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+2]=\\{omega}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\.{"\ "})$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app}(\.{"\ "})$;\5
$\\{app}(\\{indent})$;\5
$\\{app1}(\\{pp}+2)$;\5
$\\{reduce}(\\{pp},\393,\39\\{clause},\39-2)(2)$;\6
\&{end};\2\2\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{omega}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\.{"\ "})$;\5
$\\{app}(\\{indent})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\392,\39\\{clause},\39-2)(3)$;\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{simp}$ \1\&{then}\5
$\\{squash}(\\{pp}+1,\391,\39\\{math},\390)(4)$\2\2\2\par
\U150.\fi

\M152. \P$\X152:Cases for \\{beginning}\X\S$\6
\&{if} $\\{cat}[\\{pp}+1]=\\{close}$ \1\&{then}\6
\&{begin} \37\&{if} $(\\{cat}[\\{pp}+2]=\\{terminator})\V(\\{cat}[\\{pp}+2]=%
\\{stmt})$ \1\&{then}\5
$\\{squash}(\\{pp},\393,\39\\{stmt},\39-2)(5)$;\2\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{stmt}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\\{break\_space})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\392,\39\\{beginning},\39-1)(6)$;\6
\&{end}\2\2\par
\U150.\fi

\M153. \P$\X153:Cases for \\{case\_head}\X\S$\6
\&{if} $\\{cat}[\\{pp}+1]=\\{casey}$ \1\&{then}\6
\&{begin} \37\&{if} $\\{cat}[\\{pp}+2]=\\{clause}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\\{outdent})$;\5
$\\{app2}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\393,\39\\{case\_head},\390)(7)$;\6
\&{end};\2\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{close}$ \1\&{then}\6
\&{begin} \37\&{if} $\\{cat}[\\{pp}+2]=\\{terminator}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\\{cancel})$;\5
$\\{app}(\\{outdent})$;\5
$\\{app2}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\393,\39\\{stmt},\39-2)(8)$;\6
\&{end};\2\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{stmt}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\\{force})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\392,\39\\{case\_head},\390)(9)$;\6
\&{end}\2\2\2\par
\U149.\fi

\M154. \P$\X154:Cases for \\{casey}\X\S$\6
\&{if} $\\{cat}[\\{pp}+1]=\\{clause}$ \1\&{then}\5
$\\{squash}(\\{pp},\392,\39\\{case\_head},\390)(10)$\2\par
\U149.\fi

\M155. \P$\X155:Cases for \\{clause}\X\S$\6
\&{if} $\\{cat}[\\{pp}+1]=\\{stmt}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\\{break\_space})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{app}(\\{cancel})$;\5
$\\{app}(\\{outdent})$;\5
$\\{app}(\\{force})$;\5
$\\{reduce}(\\{pp},\392,\39\\{stmt},\39-2)(11)$;\6
\&{end}\2\par
\U149.\fi

\M156. \P$\X156:Cases for \\{cond}\X\S$\6
\&{if} $(\\{cat}[\\{pp}+1]=\\{clause})\W(\\{cat}[\\{pp}+2]=\\{stmt})$ \1%
\&{then}\6
\&{if} $\\{cat}[\\{pp}+3]=\\{elsie}$ \1\&{then}\6
\&{begin} \37$\\{app2}(\\{pp})$;\5
$\\{app}(\\{break\_space})$;\5
$\\{app2}(\\{pp}+2)$;\5
$\\{app}(\.{"\ "})$;\5
$\\{app}(\\{cancel})$;\5
$\\{reduce}(\\{pp},\394,\39\\{clause},\39-2)(12)$;\6
\&{end}\6
\4\&{else} \&{begin} \37$\\{app2}(\\{pp})$;\5
$\\{app}(\\{break\_space})$;\5
$\\{app1}(\\{pp}+2)$;\5
$\\{app}(\\{cancel})$;\5
$\\{app}(\\{outdent})$;\5
$\\{app}(\\{force})$;\5
$\\{reduce}(\\{pp},\393,\39\\{stmt},\39-2)(13)$;\6
\&{end}\2\2\par
\U149.\fi

\M157. \P$\X157:Cases for \\{elsie}\X\S$\6
$\\{squash}(\\{pp},\391,\39\\{intro},\39-3)(14)$\par
\U149.\fi

\M158. \P$\X158:Cases for \\{exp}\X\S$\6
\&{if} $\\{cat}[\\{pp}+1]=\\{math}$ \1\&{then}\6
\&{begin} \37\&{if} $\\{cat}[\\{pp}+2]=\\{simp}$ \1\&{then}\6
\&{if} $\\{cat}[\\{pp}+3]\I\\{simp}$ \1\&{then}\6
\&{begin} \37$\\{app3}(\\{pp})$;\5
$\\{app}(\.{"\}"})$;\5
$\\{reduce}(\\{pp},\393,\39\\{math},\39-1)(15)$;\6
\&{end};\2\2\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{simp}$ \1\&{then}\6
\&{if} $\\{cat}[\\{pp}+2]\I\\{simp}$ \1\&{then}\6
\&{begin} \37$\\{app2}(\\{pp})$;\5
$\\{app}(\.{"\}"})$;\5
$\\{reduce}(\\{pp},\392,\39\\{math},\39-1)(16)$;\6
\&{end}\2\2\2\par
\U149.\fi

\M159. \P$\X159:Cases for \\{intro}\X\S$\6
\&{if} $\\{cat}[\\{pp}+1]=\\{stmt}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\.{"\ "})$;\5
$\\{app}(\\{opt})$;\5
$\\{app}(\.{"7"})$;\5
$\\{app}(\\{cancel})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\392,\39\\{stmt},\39-2)(17)$;\6
\&{end}\2\par
\U150.\fi

\M160. \P$\X160:Cases for \\{math}\X\S$\6
\&{if} $\\{cat}[\\{pp}+1]=\\{close}$ \1\&{then}\6
\&{begin} \37$\\{app}(\.{"\$"})$;\5
$\\{app1}(\\{pp})$;\5
$\\{app}(\.{"\$"})$;\5
$\\{reduce}(\\{pp},\391,\39\\{stmt},\39-2)(18)$;\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{colon}$ \1\&{then}\6
\&{begin} \37$\\{app}(\\{force})$;\5
$\\{app}(\\{backup})$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app1}(\\{pp})$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\392,\39\\{intro},\39-3)(19)$;\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{math}$ \1\&{then}\5
$\\{squash}(\\{pp},\392,\39\\{math},\39-1)(20)$\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{simp}$ \1\&{then}\5
$\\{squash}(\\{pp},\392,\39\\{math},\39-1)(21)$\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{stmt}$ \1\&{then}\6
\&{begin} \37$\\{app}(\.{"\$"})$;\5
$\\{app1}(\\{pp})$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app}(\\{indent})$;\5
$\\{app}(\\{break\_space})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{app}(\\{cancel})$;\5
$\\{app}(\\{outdent})$;\5
$\\{app}(\\{force})$;\5
$\\{reduce}(\\{pp},\392,\39\\{stmt},\39-2)(22)$;\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{terminator}$ \1\&{then}\6
\&{begin} \37$\\{app}(\.{"\$"})$;\5
$\\{app1}(\\{pp})$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\392,\39\\{stmt},\39-2)(23)$;\6
\&{end}\2\2\2\2\2\2\par
\U150.\fi

\M161. \P$\X161:Cases for \\{mod\_scrap}\X\S$\6
\&{if} $(\\{cat}[\\{pp}+1]=\\{terminator})\V(\\{cat}[\\{pp}+1]=\\{semi})$ \1%
\&{then}\6
\&{begin} \37$\\{app2}(\\{pp})$;\5
$\\{app}(\\{force})$;\5
$\\{reduce}(\\{pp},\392,\39\\{stmt},\39-2)(24)$;\6
\&{end}\6
\4\&{else} $\\{squash}(\\{pp},\391,\39\\{simp},\39-2)(25)$\2\par
\U149.\fi

\M162. \P$\X162:Cases for \\{open}\X\S$\6
\&{if} $(\\{cat}[\\{pp}+1]=\\{case\_head})\W(\\{cat}[\\{pp}+2]=\\{close})$ \1%
\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app}(\\{cancel})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{app}(\\{cancel})$;\5
$\\{app}(\\{outdent})$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app1}(\\{pp}+2)$;\5
$\\{reduce}(\\{pp},\393,\39\\{math},\39-1)(26)$;\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{close}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\.{"\\"})$;\5
$\\{app}(\.{","})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\392,\39\\{math},\39-1)(27)$;\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{math}$ \1\&{then}\5
\X163:Cases for $\\{open}\,\\{math}$\X\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{proc}$ \1\&{then}\6
\&{begin} \37\&{if} $\\{cat}[\\{pp}+2]=\\{intro}$ \1\&{then}\6
\&{begin} \37$\\{app}(\\{math\_op})$;\5
$\\{app}(\\{cancel})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{app}(\.{"\}"})$;\5
$\\{reduce}(\\{pp}+1,\392,\39\\{math},\390)(34)$;\6
\&{end};\2\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{simp}$ \1\&{then}\5
$\\{squash}(\\{pp}+1,\391,\39\\{math},\390)(35)$\6
\4\&{else} \&{if} $(\\{cat}[\\{pp}+1]=\\{stmt})\W(\\{cat}[\\{pp}+2]=\\{close})$
\1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app}(\\{cancel})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{app}(\\{cancel})$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app1}(\\{pp}+2)$;\5
$\\{reduce}(\\{pp},\393,\39\\{math},\39-1)(36)$;\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{var\_head}$ \1\&{then}\6
\&{begin} \37\&{if} $\\{cat}[\\{pp}+2]=\\{intro}$ \1\&{then}\6
\&{begin} \37$\\{app}(\\{math\_op})$;\5
$\\{app}(\\{cancel})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{app}(\.{"\}"})$;\5
$\\{reduce}(\\{pp}+1,\392,\39\\{math},\390)(37)$;\6
\&{end};\2\6
\&{end}\2\2\2\2\2\2\2\par
\U150.\fi

\M163. \P$\X163:Cases for $\\{open}\,\\{math}$\X\S$\6
\&{begin} \37\&{if} $(\\{cat}[\\{pp}+2]=\\{case\_head})\W(\\{cat}[\\{pp}+3]=%
\\{close})$ \1\&{then}\6
\&{begin} \37$\\{app2}(\\{pp})$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app}(\\{cancel})$;\5
$\\{app1}(\\{pp}+2)$;\5
$\\{app}(\\{cancel})$;\5
$\\{app}(\\{outdent})$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app1}(\\{pp}+3)$;\5
$\\{reduce}(\\{pp},\394,\39\\{math},\39-1)(28)$;\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+2]=\\{close}$ \1\&{then}\5
$\\{squash}(\\{pp},\393,\39\\{math},\39-1)(29)$\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+2]=\\{colon}$ \1\&{then}\5
$\\{squash}(\\{pp}+1,\392,\39\\{math},\390)(30)$\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+2]=\\{proc}$ \1\&{then}\6
\&{begin} \37\&{if} $\\{cat}[\\{pp}+3]=\\{intro}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp}+1)$;\5
$\\{app}(\\{math\_op})$;\5
$\\{app}(\\{cancel})$;\5
$\\{app1}(\\{pp}+2)$;\5
$\\{app}(\.{"\}"})$;\5
$\\{reduce}(\\{pp}+1,\393,\39\\{math},\390)(31)$;\6
\&{end};\2\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+2]=\\{semi}$ \1\&{then}\6
\&{begin} \37$\\{app2}(\\{pp}+1)$;\5
$\\{app}(\.{"\\"})$;\5
$\\{app}(\.{","})$;\5
$\\{app}(\\{opt})$;\5
$\\{app}(\.{"5"})$;\5
$\\{reduce}(\\{pp}+1,\392,\39\\{math},\390)(32)$;\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+2]=\\{var\_head}$ \1\&{then}\6
\&{begin} \37\&{if} $\\{cat}[\\{pp}+3]=\\{intro}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp}+1)$;\5
$\\{app}(\\{math\_op})$;\5
$\\{app}(\\{cancel})$;\5
$\\{app1}(\\{pp}+2)$;\5
$\\{app}(\.{"\}"})$;\5
$\\{reduce}(\\{pp}+1,\393,\39\\{math},\390)(31)$;\6
\&{end};\2\6
\&{end};\2\2\2\2\2\2\6
\&{end}\par
\U162.\fi

\M164. \P$\X164:Cases for \\{proc}\X\S$\6
\&{if} $\\{cat}[\\{pp}+1]=\\{beginning}$ \1\&{then}\6
\&{begin} \37\&{if} $(\\{cat}[\\{pp}+2]=\\{close})\W(\\{cat}[\\{pp}+3]=%
\\{terminator})$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\\{cancel})$;\5
$\\{app}(\\{outdent})$;\5
$\\{app3}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\394,\39\\{stmt},\39-2)(38)$;\6
\&{end};\2\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{stmt}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\\{break\_space})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\392,\39\\{proc},\39-2)(39)$;\6
\&{end}\2\2\par
\U149.\fi

\M165. \P$\X165:Cases for \\{record\_head}\X\S$\6
\&{if} $(\\{cat}[\\{pp}+1]=\\{intro})\W(\\{cat}[\\{pp}+2]=\\{casey})$ \1%
\&{then}\6
\&{begin} \37$\\{app2}(\\{pp})$;\5
$\\{app}(\.{"\ "})$;\5
$\\{app}(\\{cancel})$;\5
$\\{app1}(\\{pp}+2)$;\5
$\\{reduce}(\\{pp},\393,\39\\{casey},\39-2)(40)$;\6
\&{end}\6
\4\&{else} \&{begin} \37$\\{app}(\\{indent})$;\5
$\\{app1}(\\{pp})$;\5
$\\{app}(\\{cancel})$;\5
$\\{reduce}(\\{pp},\391,\39\\{case\_head},\390)(41)$;\6
\&{end}\2\par
\U149.\fi

\M166. \P$\X166:Cases for \\{semi}\X\S$\6
$\\{squash}(\\{pp},\391,\39\\{terminator},\39-3)(42)$\par
\U149.\fi

\M167. \P$\X167:Cases for \\{simp}\X\S$\6
\&{if} $\\{cat}[\\{pp}+1]=\\{close}$ \1\&{then}\5
$\\{squash}(\\{pp},\391,\39\\{stmt},\39-2)(43)$\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{colon}$ \1\&{then}\6
\&{begin} \37$\\{app}(\\{force})$;\5
$\\{app}(\\{backup})$;\5
$\\{app2}(\\{pp})$;\5
$\\{reduce}(\\{pp},\392,\39\\{intro},\39-3)(44)$;\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{math}$ \1\&{then}\5
$\\{squash}(\\{pp},\392,\39\\{math},\39-1)(45)$\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{mod\_scrap}$ \1\&{then}\5
$\\{squash}(\\{pp},\392,\39\\{mod\_scrap},\390)(46)$\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{simp}$ \1\&{then}\5
$\\{squash}(\\{pp},\392,\39\\{simp},\39-2)(47)$\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{terminator}$ \1\&{then}\5
$\\{squash}(\\{pp},\392,\39\\{stmt},\39-2)(48)$\2\2\2\2\2\2\par
\U150.\fi

\M168. \P$\X168:Cases for \\{stmt}\X\S$\6
\&{if} $\\{cat}[\\{pp}+1]=\\{stmt}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\\{break\_space})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\392,\39\\{stmt},\39-2)(49)$;\6
\&{end}\2\par
\U149.\fi

\M169. \P$\X169:Cases for \\{terminator}\X\S$\6
$\\{squash}(\\{pp},\391,\39\\{stmt},\39-2)(50)$\par
\U149.\fi

\M170. \P$\X170:Cases for \\{var\_head}\X\S$\6
\&{if} $\\{cat}[\\{pp}+1]=\\{beginning}$ \1\&{then}\5
$\\{squash}(\\{pp},\391,\39\\{stmt},\39-2)(51)$\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{math}$ \1\&{then}\6
\&{begin} \37\&{if} $\\{cat}[\\{pp}+2]=\\{colon}$ \1\&{then}\6
\&{begin} \37$\\{app}(\.{"\$"})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{app}(\.{"\$"})$;\5
$\\{app1}(\\{pp}+2)$;\5
$\\{reduce}(\\{pp}+1,\392,\39\\{intro},\39+1)(52)$;\6
\&{end};\2\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{simp}$ \1\&{then}\6
\&{begin} \37\&{if} $\\{cat}[\\{pp}+2]=\\{colon}$ \1\&{then}\5
$\\{squash}(\\{pp}+1,\392,\39\\{intro},\39+1)(53)$;\2\6
\&{end}\6
\4\&{else} \&{if} $\\{cat}[\\{pp}+1]=\\{stmt}$ \1\&{then}\6
\&{begin} \37$\\{app1}(\\{pp})$;\5
$\\{app}(\\{break\_space})$;\5
$\\{app1}(\\{pp}+1)$;\5
$\\{reduce}(\\{pp},\392,\39\\{var\_head},\39-2)(54)$;\6
\&{end}\2\2\2\2\par
\U149.\fi

\M171. The `\\{freeze\_text}' macro is used to give official status to a token
list.
Before saying \\{freeze\_text}, items are appended to the current token list,
and we know that the eventual number of this token list will be the current
value of \\{text\_ptr}. But no list of that number really exists as yet,
because no ending point for the current list has been
stored in the \\{tok\_start} array. After saying \\{freeze\_text}, the
old current token list becomes legitimate, and its number is the current
value of $\\{text\_ptr}-1$ since \\{text\_ptr} has been increased. The new
current token list is empty and ready to be appended to.
Note that \\{freeze\_text} does not check to see that \\{text\_ptr} hasn't
gotten
too large, since it is assumed that this test was done beforehand.

\Y\P\D \37$\\{freeze\_text}\S\\{incr}(\\{text\_ptr})$;\5
$\\{tok\_start}[\\{text\_ptr}]\K\\{tok\_ptr}$\par
\fi

\M172. The `\\{reduce}' macro used in our code for productions actually calls
on
a procedure named `\\{red}', which makes the appropriate changes to the
scrap list.

\Y\P\4\&{procedure}\1\  \37$\\{red}(\|j:\\{sixteen\_bits};\,\35\|k:\\{eight%
\_bits};\,\35\|c:\\{eight\_bits};\,\35\|d:\\{integer})$;\6
\4\&{var} \37\|i: \37$0\to\\{max\_scraps}$;\C{index into scrap memory}\2\6
\&{begin} \37$\\{cat}[\|j]\K\|c$;\5
$\\{trans}[\|j]\K\\{text\_ptr}$;\5
\\{freeze\_text};\6
\&{if} $\|k>1$ \1\&{then}\6
\&{begin} \37\&{for} $\|i\K\|j+\|k\mathrel{\&{to}}\\{lo\_ptr}$ \1\&{do}\6
\&{begin} \37$\\{cat}[\|i-\|k+1]\K\\{cat}[\|i]$;\5
$\\{trans}[\|i-\|k+1]\K\\{trans}[\|i]$;\6
\&{end};\2\6
$\\{lo\_ptr}\K\\{lo\_ptr}-\|k+1$;\6
\&{end};\2\6
\X173:Change \\{pp} to $\max(\\{scrap\_base},$\\{pp}+\|d$)$\X;\6
\&{end};\par
\fi

\M173. \P$\X173:Change \\{pp} to $\max(\\{scrap\_base},$\\{pp}+\|d$)$\X\S$\6
\&{if} $\\{pp}+\|d\G\\{scrap\_base}$ \1\&{then}\5
$\\{pp}\K\\{pp}+\|d$\6
\4\&{else} $\\{pp}\K\\{scrap\_base}$\2\par
\Us172\ET174.\fi

\M174. Similarly, the `\\{squash}' macro invokes a procedure called `\\{sq}'.
This
procedure takes advantage of the simplification that occurs when $\|k=1$.

\Y\P\4\&{procedure}\1\  \37$\\{sq}(\|j:\\{sixteen\_bits};\,\35\|k:\\{eight%
\_bits};\,\35\|c:\\{eight\_bits};\,\35\|d:\\{integer})$;\6
\4\&{var} \37\|i: \37$0\to\\{max\_scraps}$;\C{index into scrap memory}\2\6
\&{begin} \37\&{if} $\|k=1$ \1\&{then}\6
\&{begin} \37$\\{cat}[\|j]\K\|c$;\5
\X173:Change \\{pp} to $\max(\\{scrap\_base},$\\{pp}+\|d$)$\X;\6
\&{end}\6
\4\&{else} \&{begin} \37\&{for} $\|i\K\|j\mathrel{\&{to}}\|j+\|k-1$ \1\&{do}\6
\&{begin} \37$\\{app1}(\|i)$;\6
\&{end};\2\6
$\\{red}(\|j,\39\|k,\39\|c,\39\|d)$;\6
\&{end};\2\6
\&{end};\par
\fi

\M175. Here now is the code that applies productions as long as possible. It
requires two local labels (\\{found} and \\{done}), as well as a local
variable (\|i).

\Y\P$\4\X175:Reduce the scraps using the productions until no more rules apply%
\X\S$\6
\~ \1\&{loop}\ \&{begin} \37\X176:Make sure the entries $\\{cat}[\\{pp}\to(%
\\{pp}+3)]$ are defined\X;\6
\&{if} $(\\{tok\_ptr}+8>\\{max\_toks})\V(\\{text\_ptr}+4>\\{max\_texts})$ \1%
\&{then}\6
\&{begin} \37\&{stat} \37\&{if} $\\{tok\_ptr}>\\{max\_tok\_ptr}$ \1\&{then}\5
$\\{max\_tok\_ptr}\K\\{tok\_ptr}$;\2\6
\&{if} $\\{text\_ptr}>\\{max\_txt\_ptr}$ \1\&{then}\5
$\\{max\_txt\_ptr}\K\\{text\_ptr}$;\2\6
\&{tats}\6
$\\{overflow}(\.{\'token/text\'})$;\6
\&{end};\2\6
\&{if} $\\{pp}>\\{lo\_ptr}$ \1\&{then}\5
\&{goto} \37\\{done};\2\6
\X149:Match a production at \\{pp}, or increase \\{pp} if there is no match\X;\6
\&{end};\2\6
\4\\{done}: \37\par
\U179.\fi

\M176. If we get to the end of the scrap list, category codes equal to zero are
stored, since zero does not match anything in a production.

\Y\P$\4\X176:Make sure the entries $\\{cat}[\\{pp}\to(\\{pp}+3)]$ are defined\X%
\S$\6
\&{if} $\\{lo\_ptr}<\\{pp}+3$ \1\&{then}\6
\&{begin} \37\1\&{repeat} \37\&{if} $\\{hi\_ptr}\L\\{scrap\_ptr}$ \1\&{then}\6
\&{begin} \37$\\{incr}(\\{lo\_ptr})$;\6
$\\{cat}[\\{lo\_ptr}]\K\\{cat}[\\{hi\_ptr}]$;\5
$\\{trans}[\\{lo\_ptr}]\K\\{trans}[\\{hi\_ptr}]$;\6
$\\{incr}(\\{hi\_ptr})$;\6
\&{end};\2\6
\4\&{until}\5
$(\\{hi\_ptr}>\\{scrap\_ptr})\V(\\{lo\_ptr}=\\{pp}+3)$;\2\6
\&{for} $\|i\K\\{lo\_ptr}+1\mathrel{\&{to}}\\{pp}+3$ \1\&{do}\5
$\\{cat}[\|i]\K0$;\2\6
\&{end}\2\par
\U175.\fi

\M177. If \.{WEAVE} is being run in debugging mode, the production numbers and
current stack categories will be printed out when \\{tracing} is set to 2;
a sequence of two or more irreducible scraps will be printed out when
\\{tracing} is set to 1.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\&{debug} \37\\{tracing}: \37$0\to2$;\C{can be used to show parsing details}\6
\&{gubed}\par
\fi

\M178. The \\{prod} procedure is called in debugging mode just after \\{reduce}
or
\\{squash}; its parameter is the number of the production that has just
been applied.

\Y\P\&{debug} \37\&{procedure}\1\  \37$\\{prod}(\|n:\\{eight\_bits})$;\C{shows
current categories}\6
\4\&{var} \37\|k: \37$1\to\\{max\_scraps}$;\C{index into \\{cat}}\2\6
\&{begin} \37\&{if} $\\{tracing}=2$ \1\&{then}\6
\&{begin} \37$\\{print\_nl}(\|n:1,\39\.{\':\'})$;\6
\&{for} $\|k\K\\{scrap\_base}\mathrel{\&{to}}\\{lo\_ptr}$ \1\&{do}\6
\&{begin} \37\&{if} $\|k=\\{pp}$ \1\&{then}\5
$\\{print}(\.{\'*\'})$\ \&{else} $\\{print}(\.{\'\ \'})$;\2\6
$\\{print\_cat}(\\{cat}[\|k])$;\6
\&{end};\2\6
\&{if} $\\{hi\_ptr}\L\\{scrap\_ptr}$ \1\&{then}\5
$\\{print}(\.{\'...\'})$;\C{indicate that more is coming}\2\6
\&{end};\2\6
\&{end};\6
\&{gubed}\par
\fi

\M179. The \\{translate} function assumes that scraps have been stored in
positions \\{scrap\_base} through \\{scrap\_ptr} of \\{cat} and \\{trans}. It
appends a \\{terminator} scrap and begins to apply productions as much as
possible. The result is a token list containing the translation of
the given sequence of scraps.

After calling \\{translate}, we will have $\\{text\_ptr}+3\L\\{max\_texts}$ and
$\\{tok\_ptr}+6\L\\{max\_toks}$, so it will be possible to create up to three
token
lists with up to six tokens without checking for overflow. Before calling
\\{translate}, we should have $\\{text\_ptr}<\\{max\_texts}$ and $\\{scrap%
\_ptr}<\\{max\_scraps}$,
since \\{translate} might add a new text and a new scrap before it checks
for overflow.

\Y\P\X150:Declaration of subprocedures for \\{translate}\X\6
\4\&{function}\1\  \37\\{translate}: \37\\{text\_pointer};\C{converts a
sequence of scraps}\6
\4\&{label} \37$\\{done},\39\\{found}$;\6
\4\&{var} \37\|i: \37$1\to\\{max\_scraps}$;\C{index into \\{cat}}\6
\|j: \37$0\to\\{max\_scraps}$;\C{runs through final scraps}\6
\|k: \37$0\to\\{long\_buf\_size}$;\C{index into \\{buffer}}\2\6
\&{begin} \37$\\{pp}\K\\{scrap\_base}$;\5
$\\{lo\_ptr}\K\\{pp}-1$;\5
$\\{hi\_ptr}\K\\{pp}$;\5
\X182:If tracing, print an indication of where we are\X;\6
\X175:Reduce the scraps using the productions until no more rules apply\X;\6
\&{if} $(\\{lo\_ptr}=\\{scrap\_base})\W(\\{cat}[\\{lo\_ptr}]\I\\{math})$ \1%
\&{then}\5
$\\{translate}\K\\{trans}[\\{lo\_ptr}]$\6
\4\&{else} \X180:Combine the irreducible scraps that remain\X;\2\6
\&{end};\par
\fi

\M180. If the initial sequence of scraps does not reduce to a single scrap,
we concatenate the translations of all remaining scraps, separated by
blank spaces, with dollar signs surrounding the translations of \\{math}
scraps.

\Y\P$\4\X180:Combine the irreducible scraps that remain\X\S$\6
\&{begin} \37\X181:If semi-tracing, show the irreducible scraps\X;\6
\&{for} $\|j\K\\{scrap\_base}\mathrel{\&{to}}\\{lo\_ptr}$ \1\&{do}\6
\&{begin} \37\&{if} $\|j\I\\{scrap\_base}$ \1\&{then}\6
\&{begin} \37$\\{app}(\.{"\ "})$;\6
\&{end};\2\6
\&{if} $\\{cat}[\|j]=\\{math}$ \1\&{then}\6
\&{begin} \37$\\{app}(\.{"\$"})$;\6
\&{end};\2\6
$\\{app1}(\|j)$;\6
\&{if} $\\{cat}[\|j]=\\{math}$ \1\&{then}\6
\&{begin} \37$\\{app}(\.{"\$"})$;\6
\&{end};\2\6
\&{if} $\\{tok\_ptr}+6>\\{max\_toks}$ \1\&{then}\5
$\\{overflow}(\.{\'token\'})$;\2\6
\&{end};\2\6
\\{freeze\_text};\5
$\\{translate}\K\\{text\_ptr}-1$;\6
\&{end}\par
\U179.\fi

\M181. \P$\X181:If semi-tracing, show the irreducible scraps\X\S$\6
\&{debug} \37\&{if} $(\\{lo\_ptr}>\\{scrap\_base})\W(\\{tracing}=1)$ \1\&{then}%
\6
\&{begin} \37$\\{print\_nl}(\.{\'Irreducible\ scrap\ sequence\ in\ section\ %
\'},\39\\{module\_count}:1)$;\5
$\\{print\_ln}(\.{\':\'})$;\5
\\{mark\_harmless};\6
\&{for} $\|j\K\\{scrap\_base}\mathrel{\&{to}}\\{lo\_ptr}$ \1\&{do}\6
\&{begin} \37$\\{print}(\.{\'\ \'})$;\5
$\\{print\_cat}(\\{cat}[\|j])$;\6
\&{end};\2\6
\&{end};\2\6
\&{gubed}\par
\U180.\fi

\M182. \P$\X182:If tracing, print an indication of where we are\X\S$\6
\&{debug} \37\&{if} $\\{tracing}=2$ \1\&{then}\6
\&{begin} \37$\\{print\_nl}(\.{\'Tracing\ after\ l.\'},\39\\{line}:1,\39\.{\':%
\'})$;\5
\\{mark\_harmless};\6
\&{if} $\\{loc}>50$ \1\&{then}\6
\&{begin} \37$\\{print}(\.{\'...\'})$;\6
\&{for} $\|k\K\\{loc}-50\mathrel{\&{to}}\\{loc}$ \1\&{do}\5
$\\{print}(\\{xchr}[\\{buffer}[\|k-1]])$;\2\6
\&{end}\6
\4\&{else} \&{for} $\|k\K1\mathrel{\&{to}}\\{loc}$ \1\&{do}\5
$\\{print}(\\{xchr}[\\{buffer}[\|k-1]])$;\2\2\6
\&{end}\2\6
\&{gubed}\par
\U179.\fi

\N183.  Initializing the scraps.
If we are going to use the powerful production mechanism just developed, we
must get the scraps set up in the first place, given a \PASCAL\ text. A table
of the initial scraps corresponding to \PASCAL\ tokens appeared above in the
section on parsing; our goal now is to implement that table. We shall do this
by implementing a subroutine called \\{Pascal\_parse} that is analogous to the
\\{Pascal\_xref} routine used during phase one.

Like \\{Pascal\_xref}, the \\{Pascal\_parse} procedure starts with the current
value of \\{next\_control} and it uses the operation $\\{next\_control}\K\\{get%
\_next}$
repeatedly to read \PASCAL\ text until encountering the next `\v' or
`\.\{', or until $\\{next\_control}\G\\{format}$. The scraps corresponding to
what
it reads are appended into the \\{cat} and \\{trans} arrays, and \\{scrap\_ptr}
is advanced.

Like \\{prod}, this procedure has to split into pieces so that each
part is short enough to be handled by \PASCAL\ compilers that discriminate
against long subroutines. This time there are two split-off routines,
called \\{easy\_cases} and \\{sub\_cases}.

After studying \\{Pascal\_parse}, we will look at the sub-procedures
\\{app\_comment}, \\{app\_octal}, and \\{app\_hex} that are used in some of its
branches.

\Y\P\X195:Declaration of the \\{app\_comment} procedure\X\6
\X196:Declaration of the \\{app\_octal} and \\{app\_hex} procedures\X\6
\X186:Declaration of the \\{easy\_cases} procedure\X\6
\X192:Declaration of the \\{sub\_cases} procedure\X\6
\4\&{procedure}\1\  \37\\{Pascal\_parse};\C{creates scraps from \PASCAL\
tokens}\6
\4\&{label} \37$\\{reswitch},\39\\{exit}$;\6
\4\&{var} \37\|j: \37$0\to\\{long\_buf\_size}$;\C{index into \\{buffer}}\6
\|p: \37\\{name\_pointer};\C{identifier designator}\2\6
\&{begin} \37\&{while} $\\{next\_control}<\\{format}$ \1\&{do}\6
\&{begin} \37\X185:Append the scrap appropriate to \\{next\_control}\X;\6
$\\{next\_control}\K\\{get\_next}$;\6
\&{if} $(\\{next\_control}=\.{"|"})\V(\\{next\_control}=\.{"\{"})$ \1\&{then}\5
\&{return};\2\6
\&{end};\2\6
\4\\{exit}: \37\&{end};\par
\fi

\M184. The macros defined here are helpful abbreviations for the operations
needed when generating the scraps. A scrap of category \|c whose
translation has three tokens $t_1$, $t_2$, $t_3$ is generated by
\\{sc3}$(t_1)(t_2)(t_3)(c)$, etc.

\Y\P\D \37$\\{s0}(\#)\S\\{incr}(\\{scrap\_ptr})$;\5
$\\{cat}[\\{scrap\_ptr}]\K\#$;\5
$\\{trans}[\\{scrap\_ptr}]\K\\{text\_ptr}$;\5
\\{freeze\_text}; \6
\&{end} \par
\P\D \37$\\{s1}(\#)\S\\{app}(\#)$;\5
\\{s0}\par
\P\D \37$\\{s2}(\#)\S\\{app}(\#)$;\5
\\{s1}\par
\P\D \37$\\{s3}(\#)\S\\{app}(\#)$;\5
\\{s2}\par
\P\D \37$\\{s4}(\#)\S\\{app}(\#)$;\5
\\{s3}\par
\P\D \37$\\{sc4}\S$\ \&{begin} \37\\{s4}\par
\P\D \37$\\{sc3}\S$\ \&{begin} \37\\{s3}\par
\P\D \37$\\{sc2}\S$\ \&{begin} \37\\{s2}\par
\P\D \37$\\{sc1}\S$\ \&{begin} \37\\{s1}\par
\P\D \37$\\{sc0}(\#)\S$\1\6
\&{begin} \37$\\{incr}(\\{scrap\_ptr})$;\5
$\\{cat}[\\{scrap\_ptr}]\K\#$;\5
$\\{trans}[\\{scrap\_ptr}]\K0$;\6
\&{end}\2\par
\P\D \37$\\{comment\_scrap}(\#)\S$\1\6
\&{begin} \37$\\{app}(\#)$;\5
\\{app\_comment};\6
\&{end}\2\par
\fi

\M185. \P$\X185:Append the scrap appropriate to \\{next\_control}\X\S$\6
\X187:Make sure that there is room for at least four more scraps, six more
tokens, and four more texts\X;\6
\4\\{reswitch}: \37\&{case} $\\{next\_control}$ \1\&{of}\6
\4$\\{string},\39\\{verbatim}$: \37\X189:Append a \(string scrap\X;\6
\4\\{identifier}: \37\X191:Append an identifier scrap\X;\6
\4\\{TeX\_string}: \37\X190:Append a \TeX\ string scrap\X;\6
\4\&{othercases} \37\\{easy\_cases}\2\6
\&{endcases}\par
\U183.\fi

\M186. The \\{easy\_cases} each result in straightforward scraps.

\Y\P$\4\X186:Declaration of the \\{easy\_cases} procedure\X\S$\6
\4\&{procedure}\1\  \37\\{easy\_cases};\C{a subprocedure of \\{Pascal\_parse}}%
\2\6
\&{begin} \37\&{case} $\\{next\_control}$ \1\&{of}\6
\4\\{set\_element\_sign}: \37$\\{sc3}(\.{"\\"})(\.{"i"})(\.{"n"})(\\{math})$;\6
\4\\{double\_dot}: \37$\\{sc3}(\.{"\\"})(\.{"t"})(\.{"o"})(\\{math})$;\6
\4$\.{"\#"},\39\.{"\$"},\39\.{"\%"},\39\.{"\^"},\39\.{"\_"}$: \37$\\{sc2}(\.{"%
\\"})(\\{next\_control})(\\{math})$;\6
\4$\\{ignore},\39\.{"|"},\39\\{xref\_roman},\39\\{xref\_wildcard},\39\\{xref%
\_typewriter}$: \37\\{do\_nothing};\6
\4$\.{"("},\39\.{"["}$: \37$\\{sc1}(\\{next\_control})(\\{open})$;\6
\4$\.{")"},\39\.{"]"}$: \37$\\{sc1}(\\{next\_control})(\\{close})$;\6
\4\.{"*"}: \37$\\{sc4}(\.{"\\"})(\.{"a"})(\.{"s"})(\.{"t"})(\\{math})$;\6
\4\.{","}: \37$\\{sc3}(\.{","})(\\{opt})(\.{"9"})(\\{math})$;\6
\4$\.{"."},\39\.{"0"},\39\.{"1"},\39\.{"2"},\39\.{"3"},\39\.{"4"},\39\.{"5"},%
\39\.{"6"},\39\.{"7"},\39\.{"8"},\39\.{"9"}$: \37$\\{sc1}(\\{next\_control})(%
\\{simp})$;\6
\4\.{";"}: \37$\\{sc1}(\.{";"})(\\{semi})$;\6
\4\.{":"}: \37$\\{sc1}(\.{":"})(\\{colon})$;\6
\hbox{\4}\X188:Cases involving nonstandard ASCII characters\X\6
\4\\{exponent}: \37$\\{sc3}(\.{"\\"})(\.{"E"})(\.{"\{"})(\\{exp})$;\6
\4\\{begin\_comment}: \37$\\{sc2}(\.{"\\"})(\.{"B"})(\\{math})$;\6
\4\\{end\_comment}: \37$\\{sc2}(\.{"\\"})(\.{"T"})(\\{math})$;\6
\4\\{octal}: \37\\{app\_octal};\6
\4\\{hex}: \37\\{app\_hex};\6
\4\\{check\_sum}: \37$\\{sc2}(\.{"\\"})(\.{")"})(\\{simp})$;\6
\4\\{force\_line}: \37$\\{sc2}(\.{"\\"})(\.{"]"})(\\{simp})$;\6
\4\\{thin\_space}: \37$\\{sc2}(\.{"\\"})(\.{","})(\\{math})$;\6
\4\\{math\_break}: \37$\\{sc2}(\\{opt})(\.{"0"})(\\{simp})$;\6
\4\\{line\_break}: \37$\\{comment\_scrap}(\\{force})$;\6
\4\\{big\_line\_break}: \37$\\{comment\_scrap}(\\{big\_force})$;\6
\4\\{no\_line\_break}: \37\&{begin} \37$\\{app}(\\{big\_cancel})$;\5
$\\{app}(\.{"\\"})$;\5
$\\{app}(\.{"\ "})$;\5
$\\{comment\_scrap}(\\{big\_cancel})$;\6
\&{end};\6
\4\\{pseudo\_semi}: \37$\\{sc0}(\\{semi})$;\6
\4\\{join}: \37$\\{sc2}(\.{"\\"})(\.{"J"})(\\{math})$;\6
\4\&{othercases} \37$\\{sc1}(\\{next\_control})(\\{math})$\2\6
\&{endcases};\6
\&{end};\par
\U183.\fi

\M187. \P$\X187:Make sure that there is room for at least four more scraps, six
more tokens, and four more texts\X\S$\6
\&{if} $(\\{scrap\_ptr}+4>\\{max\_scraps})\V(\\{tok\_ptr}+6>\\{max\_toks})\V(%
\\{text\_ptr}+4>\\{max\_texts})$ \1\&{then}\6
\&{begin} \37\&{stat} \37\&{if} $\\{scrap\_ptr}>\\{max\_scr\_ptr}$ \1\&{then}\5
$\\{max\_scr\_ptr}\K\\{scrap\_ptr}$;\2\6
\&{if} $\\{tok\_ptr}>\\{max\_tok\_ptr}$ \1\&{then}\5
$\\{max\_tok\_ptr}\K\\{tok\_ptr}$;\2\6
\&{if} $\\{text\_ptr}>\\{max\_txt\_ptr}$ \1\&{then}\5
$\\{max\_txt\_ptr}\K\\{text\_ptr}$;\2\6
\&{tats}\6
$\\{overflow}(\.{\'scrap/token/text\'})$;\6
\&{end}\2\par
\U185.\fi

\M188. Some nonstandard ASCII characters may have entered \.{WEAVE} by means of
standard ones. They are converted to \TeX\ control sequences so that it is
possible to keep \.{WEAVE} from stepping beyond standard ASCII.

\Y\P$\4\X188:Cases involving nonstandard ASCII characters\X\S$\6
\4\\{not\_equal}: \37$\\{sc2}(\.{"\\"})(\.{"I"})(\\{math})$;\6
\4\\{less\_or\_equal}: \37$\\{sc2}(\.{"\\"})(\.{"L"})(\\{math})$;\6
\4\\{greater\_or\_equal}: \37$\\{sc2}(\.{"\\"})(\.{"G"})(\\{math})$;\6
\4\\{equivalence\_sign}: \37$\\{sc2}(\.{"\\"})(\.{"S"})(\\{math})$;\6
\4\\{and\_sign}: \37$\\{sc2}(\.{"\\"})(\.{"W"})(\\{math})$;\6
\4\\{or\_sign}: \37$\\{sc2}(\.{"\\"})(\.{"V"})(\\{math})$;\6
\4\\{not\_sign}: \37$\\{sc2}(\.{"\\"})(\.{"R"})(\\{math})$;\6
\4\\{left\_arrow}: \37$\\{sc2}(\.{"\\"})(\.{"K"})(\\{math})$;\par
\U186.\fi

\M189. The following code must use \\{app\_tok} instead of \\{app} in order to
protect against overflow. Note that $\\{tok\_ptr}+1\L\\{max\_toks}$ after %
\\{app\_tok}
has been used, so another \\{app} is legitimate before testing again.

Many of the special characters in a string must be prefixed by `\.\\' so that
\TeX\ will print them properly.

\Y\P$\4\X189:Append a \(string scrap\X\S$\6
\&{begin} \37$\\{app}(\.{"\\"})$;\6
\&{if} $\\{next\_control}=\\{verbatim}$ \1\&{then}\6
\&{begin} \37$\\{app}(\.{"="})$;\6
\&{end}\6
\4\&{else} \&{begin} \37$\\{app}(\.{"."})$;\6
\&{end};\2\6
$\\{app}(\.{"\{"})$;\5
$\|j\K\\{id\_first}$;\6
\&{while} $\|j<\\{id\_loc}$ \1\&{do}\6
\&{begin} \37\&{case} $\\{buffer}[\|j]$ \1\&{of}\6
\4$\.{"\ "},\39\.{"\\"},\39\.{"\#"},\39\.{"\%"},\39\.{"\$"},\39\.{"\^"},\39\.{"%
\'"},\39\.{"\`"},\39\.{"\{"},\39\.{"\}"},\39\.{"\~"},\39\.{"\&"},\39\.{"\_"}$: %
\37\&{begin} \37$\\{app}(\.{"\\"})$;\6
\&{end};\6
\4\.{"@"}: \37\&{if} $\\{buffer}[\|j+1]=\.{"@"}$ \1\&{then}\5
$\\{incr}(\|j)$\6
\4\&{else} $\\{err\_print}(\.{\'!\ Double\ @\ should\ be\ used\ in\ strings%
\'})$;\2\6
\4\&{othercases} \37\\{do\_nothing}\2\6
\&{endcases};\6
$\\{app\_tok}(\\{buffer}[\|j])$;\5
$\\{incr}(\|j)$;\6
\&{end};\2\6
$\\{sc1}(\.{"\}"})(\\{simp})$;\6
\&{end}\par
\U185.\fi

\M190. \P$\X190:Append a \TeX\ string scrap\X\S$\6
\&{begin} \37$\\{app}(\.{"\\"})$;\5
$\\{app}(\.{"h"})$;\5
$\\{app}(\.{"b"})$;\5
$\\{app}(\.{"o"})$;\5
$\\{app}(\.{"x"})$;\5
$\\{app}(\.{"\{"})$;\6
\&{for} $\|j\K\\{id\_first}\mathrel{\&{to}}\\{id\_loc}-1$ \1\&{do}\5
$\\{app\_tok}(\\{buffer}[\|j])$;\2\6
$\\{sc1}(\.{"\}"})(\\{simp})$;\6
\&{end}\par
\U185.\fi

\M191. \P$\X191:Append an identifier scrap\X\S$\6
\&{begin} \37$\|p\K\\{id\_lookup}(\\{normal})$;\6
\&{case} $\\{ilk}[\|p]$ \1\&{of}\6
\4$\\{normal},\39\\{array\_like},\39\\{const\_like},\39\\{div\_like},\39\\{do%
\_like},\39\\{for\_like},\39\\{goto\_like},\39\\{nil\_like},\39\\{to\_like}$: %
\37$\\{sub\_cases}(\|p)$;\6
\hbox{\4}\X193:Cases that generate more than one scrap\X\6
\4\&{othercases} \37\&{begin} \37$\\{next\_control}\K\\{ilk}[\|p]-\\{char%
\_like}$;\5
\&{goto} \37\\{reswitch};\6
\&{end}\C{\&{and}, \&{in}, \&{not}, \&{or}}\2\6
\&{endcases};\6
\&{end}\par
\U185.\fi

\M192. The \\{sub\_cases} also result in straightforward scraps.

\Y\P$\4\X192:Declaration of the \\{sub\_cases} procedure\X\S$\6
\4\&{procedure}\1\  \37$\\{sub\_cases}(\|p:\\{name\_pointer})$;\C{a
subprocedure of \\{Pascal\_parse}}\2\6
\&{begin} \37\&{case} $\\{ilk}[\|p]$ \1\&{of}\6
\4\\{normal}: \37$\\{sc1}(\\{id\_flag}+\|p)(\\{simp})$;\C{not a reserved word}\6
\4\\{array\_like}: \37$\\{sc1}(\\{res\_flag}+\|p)(\\{alpha})$;\C{\&{array}, %
\&{file}, \&{set}}\6
\4\\{const\_like}: \37$\\{sc3}(\\{force})(\\{backup})(\\{res\_flag}+\|p)(%
\\{intro})$;\C{\&{const}, \&{label}, \&{type}}\6
\4\\{div\_like}: \37$\\{sc3}(\\{math\_bin})(\\{res\_flag}+\|p)(\.{"\}"})(%
\\{math})$;\C{\&{div}, \&{mod}}\6
\4\\{do\_like}: \37$\\{sc1}(\\{res\_flag}+\|p)(\\{omega})$;\C{\&{do}, \&{of}, %
\&{then}}\6
\4\\{for\_like}: \37$\\{sc2}(\\{force})(\\{res\_flag}+\|p)(\\{alpha})$;\C{%
\&{for}, \&{while}, \&{with}}\6
\4\\{goto\_like}: \37$\\{sc1}(\\{res\_flag}+\|p)(\\{intro})$;\C{\&{goto}, %
\&{packed}}\6
\4\\{nil\_like}: \37$\\{sc1}(\\{res\_flag}+\|p)(\\{simp})$;\C{\&{nil}}\6
\4\\{to\_like}: \37$\\{sc3}(\\{math\_rel})(\\{res\_flag}+\|p)(\.{"\}"})(%
\\{math})$;\C{\&{downto}, \&{to}}\2\6
\&{end};\6
\&{end};\par
\U183.\fi

\M193. \P$\X193:Cases that generate more than one scrap\X\S$\6
\4\\{begin\_like}: \37\&{begin} \37$\\{sc3}(\\{force})(\\{res\_flag}+\|p)(%
\\{cancel})(\\{beginning})$;\5
$\\{sc0}(\\{intro})$;\6
\&{end};\C{\&{begin}}\6
\4\\{case\_like}: \37\&{begin} \37$\\{sc0}(\\{casey})$;\5
$\\{sc2}(\\{force})(\\{res\_flag}+\|p)(\\{alpha})$;\6
\&{end};\C{\&{case}}\6
\4\\{else\_like}: \37\&{begin} \37\X194:Append \\{terminator} if not already
present\X;\6
$\\{sc3}(\\{force})(\\{backup})(\\{res\_flag}+\|p)(\\{elsie})$;\6
\&{end};\C{\&{else}}\6
\4\\{end\_like}: \37\&{begin} \37\X194:Append \\{terminator} if not already
present\X;\6
$\\{sc2}(\\{force})(\\{res\_flag}+\|p)(\\{close})$;\6
\&{end};\C{\&{end}}\6
\4\\{if\_like}: \37\&{begin} \37$\\{sc0}(\\{cond})$;\5
$\\{sc2}(\\{force})(\\{res\_flag}+\|p)(\\{alpha})$;\6
\&{end};\C{\&{if}}\6
\4\\{loop\_like}: \37\&{begin} \37$\\{sc3}(\\{force})(\.{"\\"})(\.{"\~"})(%
\\{alpha})$;\5
$\\{sc1}(\\{res\_flag}+\|p)(\\{omega})$;\6
\&{end};\C{\&{xclause}}\6
\4\\{proc\_like}: \37\&{begin} \37$\\{sc4}(\\{force})(\\{backup})(\\{res%
\_flag}+\|p)(\\{cancel})(\\{proc})$;\5
$\\{sc3}(\\{indent})(\.{"\\"})(\.{"\ "})(\\{intro})$;\6
\&{end};\C{\&{function}, \&{procedure}, \&{program}}\6
\4\\{record\_like}: \37\&{begin} \37$\\{sc1}(\\{res\_flag}+\|p)(\\{record%
\_head})$;\5
$\\{sc0}(\\{intro})$;\6
\&{end};\C{\&{record}}\6
\4\\{repeat\_like}: \37\&{begin} \37$\\{sc4}(\\{force})(\\{indent})(\\{res%
\_flag}+\|p)(\\{cancel})(\\{beginning})$;\5
$\\{sc0}(\\{intro})$;\6
\&{end};\C{\&{repeat}}\6
\4\\{until\_like}: \37\&{begin} \37\X194:Append \\{terminator} if not already
present\X;\6
$\\{sc3}(\\{force})(\\{backup})(\\{res\_flag}+\|p)(\\{close})$;\5
$\\{sc0}(\\{clause})$;\6
\&{end};\C{\&{until}}\6
\4\\{var\_like}: \37\&{begin} \37$\\{sc4}(\\{force})(\\{backup})(\\{res\_flag}+%
\|p)(\\{cancel})(\\{var\_head})$;\5
$\\{sc0}(\\{intro})$;\6
\&{end};\C{\&{var}}\par
\U191.\fi

\M194. If a comment or semicolon appears before the reserved words \&{end},
\&{else}, or \&{until}, the \\{semi} or \\{terminator} scrap that is already
present overrides the \\{terminator} scrap belonging to this reserved word.

\Y\P$\4\X194:Append \\{terminator} if not already present\X\S$\6
\&{if} $(\\{scrap\_ptr}<\\{scrap\_base})\V((\\{cat}[\\{scrap\_ptr}]\I%
\\{terminator})\W(\\{cat}[\\{scrap\_ptr}]\I\\{semi}))$ \1\&{then}\5
$\\{sc0}(\\{terminator})$\2\par
\Us193, 193\ETs193.\fi

\M195. A comment is incorporated into the previous scrap if that scrap is of
type
\\{omega} or \\{semi} or \\{terminator}. (These three categories have
consecutive
category codes.) Otherwise the comment is entered as a separate scrap
of type \\{terminator}, and it will combine with a \\{terminator} scrap that
immediately follows~it.

The \\{app\_comment} procedure takes care of placing a comment at the end of
the
current scrap list. When \\{app\_comment} is called, we assume that the current
token list is the translation of the comment involved.

\Y\P$\4\X195:Declaration of the \\{app\_comment} procedure\X\S$\6
\4\&{procedure}\1\  \37\\{app\_comment};\C{append a comment to the scrap list}%
\2\6
\&{begin} \37\\{freeze\_text};\6
\&{if} $(\\{scrap\_ptr}<\\{scrap\_base})\V(\\{cat}[\\{scrap\_ptr}]<\\{omega})%
\V(\\{cat}[\\{scrap\_ptr}]>\\{terminator})$ \1\&{then}\5
$\\{sc0}(\\{terminator})$\6
\4\&{else} \&{begin} \37$\\{app1}(\\{scrap\_ptr})$;\C{$\\{cat}[\\{scrap\_ptr}]$
is     \\{omega} or \\{semi} or \\{terminator}}\6
\&{end};\2\6
$\\{app}(\\{text\_ptr}-1+\\{tok\_flag})$;\5
$\\{trans}[\\{scrap\_ptr}]\K\\{text\_ptr}$;\5
\\{freeze\_text};\6
\&{end};\par
\U183.\fi

\M196. We are now finished with \\{Pascal\_parse}, except for two relatively
trivial subprocedures that convert constants into tokens.

\Y\P$\4\X196:Declaration of the \\{app\_octal} and \\{app\_hex} procedures\X\S$%
\6
\4\&{procedure}\1\  \37\\{app\_octal};\2\6
\&{begin} \37$\\{app}(\.{"\\"})$;\5
$\\{app}(\.{"O"})$;\5
$\\{app}(\.{"\{"})$;\6
\&{while} $(\\{buffer}[\\{loc}]\G\.{"0"})\W(\\{buffer}[\\{loc}]\L\.{"7"})$ \1%
\&{do}\6
\&{begin} \37$\\{app\_tok}(\\{buffer}[\\{loc}])$;\5
$\\{incr}(\\{loc})$;\6
\&{end};\2\6
$\\{sc1}(\.{"\}"})(\\{simp})$;\6
\&{end};\7
\4\&{procedure}\1\  \37\\{app\_hex};\2\6
\&{begin} \37$\\{app}(\.{"\\"})$;\5
$\\{app}(\.{"H"})$;\5
$\\{app}(\.{"\{"})$;\6
\&{while} $((\\{buffer}[\\{loc}]\G\.{"0"})\W(\\{buffer}[\\{loc}]\L\.{"9"}))\V%
\30((\\{buffer}[\\{loc}]\G\.{"A"})\W(\\{buffer}[\\{loc}]\L\.{"F"}))$ \1\&{do}\6
\&{begin} \37$\\{app\_tok}(\\{buffer}[\\{loc}])$;\5
$\\{incr}(\\{loc})$;\6
\&{end};\2\6
$\\{sc1}(\.{"\}"})(\\{simp})$;\6
\&{end};\par
\U183.\fi

\M197. When the `\v' that introduces \PASCAL\ text is sensed, a call on
\\{Pascal\_translate} will return a pointer to the \TeX\ translation of
that text. If scraps exist in the \\{cat} and \\{trans} arrays, they are
unaffected by this translation process.

\Y\P\4\&{function}\1\  \37\\{Pascal\_translate}: \37\\{text\_pointer};\6
\4\&{var} \37\|p: \37\\{text\_pointer};\C{points to the translation}\6
\\{save\_base}: \37$0\to\\{max\_scraps}$;\C{holds original value of \\{scrap%
\_base}}\2\6
\&{begin} \37$\\{save\_base}\K\\{scrap\_base}$;\5
$\\{scrap\_base}\K\\{scrap\_ptr}+1$;\5
\\{Pascal\_parse};\C{get the scraps together}\6
\&{if} $\\{next\_control}\I\.{"|"}$ \1\&{then}\5
$\\{err\_print}(\.{\'!\ Missing\ "|"\ after\ Pascal\ text\'})$;\2\6
$\\{app\_tok}(\\{cancel})$;\5
\\{app\_comment};\C{place a \\{cancel} token as a final ``comment''}\6
$\|p\K\\{translate}$;\C{make the translation}\6
\&{stat} \37\&{if} $\\{scrap\_ptr}>\\{max\_scr\_ptr}$ \1\&{then}\5
$\\{max\_scr\_ptr}\K\\{scrap\_ptr}$;\2\ \&{tats}\6
$\\{scrap\_ptr}\K\\{scrap\_base}-1$;\5
$\\{scrap\_base}\K\\{save\_base}$;\C{scrap the scraps}\6
$\\{Pascal\_translate}\K\|p$;\6
\&{end};\par
\fi

\M198. The \\{outer\_parse} routine is to \\{Pascal\_parse} as \\{outer\_xref}
is to \\{Pascal\_xref}: It constructs a sequence of scraps for \PASCAL\ text
until $\\{next\_control}\G\\{format}$. Thus, it takes care of embedded
comments.

\Y\P\4\&{procedure}\1\  \37\\{outer\_parse};\C{makes scraps from \PASCAL\
tokens and comments}\6
\4\&{var} \37\\{bal}: \37\\{eight\_bits};\C{brace level in comment}\6
$\|p,\39\|q$: \37\\{text\_pointer};\C{partial comments}\2\6
\&{begin} \37\&{while} $\\{next\_control}<\\{format}$ \1\&{do}\6
\&{if} $\\{next\_control}\I\.{"\{"}$ \1\&{then}\5
\\{Pascal\_parse}\6
\4\&{else} \&{begin} \37\X199:Make sure that there is room for at least seven
more tokens, three more texts, and one more scrap\X;\6
$\\{app}(\.{"\\"})$;\5
$\\{app}(\.{"C"})$;\5
$\\{app}(\.{"\{"})$;\5
$\\{bal}\K\\{copy\_comment}(1)$;\5
$\\{next\_control}\K\.{"|"}$;\6
\&{while} $\\{bal}>0$ \1\&{do}\6
\&{begin} \37$\|p\K\\{text\_ptr}$;\5
\\{freeze\_text};\5
$\|q\K\\{Pascal\_translate}$;\C{at this point we have $\\{tok\_ptr}+6\L\\{max%
\_toks}$}\6
$\\{app}(\\{tok\_flag}+\|p)$;\5
$\\{app}(\\{inner\_tok\_flag}+\|q)$;\6
\&{if} $\\{next\_control}=\.{"|"}$ \1\&{then}\5
$\\{bal}\K\\{copy\_comment}(\\{bal})$\6
\4\&{else} $\\{bal}\K0$;\C{an error has been reported}\2\6
\&{end};\2\6
$\\{app}(\\{force})$;\5
\\{app\_comment};\C{the full comment becomes a scrap}\6
\&{end};\2\2\6
\&{end};\par
\fi

\M199. \P$\X199:Make sure that there is room for at least seven more tokens,
three more texts, and one more scrap\X\S$\6
\&{if} $(\\{tok\_ptr}+7>\\{max\_toks})\V(\\{text\_ptr}+3>\\{max\_texts})\V(%
\\{scrap\_ptr}\G\\{max\_scraps})$ \1\&{then}\6
\&{begin} \37\&{stat} \37\&{if} $\\{scrap\_ptr}>\\{max\_scr\_ptr}$ \1\&{then}\5
$\\{max\_scr\_ptr}\K\\{scrap\_ptr}$;\2\6
\&{if} $\\{tok\_ptr}>\\{max\_tok\_ptr}$ \1\&{then}\5
$\\{max\_tok\_ptr}\K\\{tok\_ptr}$;\2\6
\&{if} $\\{text\_ptr}>\\{max\_txt\_ptr}$ \1\&{then}\5
$\\{max\_txt\_ptr}\K\\{text\_ptr}$;\2\6
\&{tats}\6
$\\{overflow}(\.{\'token/text/scrap\'})$;\6
\&{end}\2\par
\U198.\fi

\N200.  Output of tokens.
So far our programs have only built up multi-layered token lists in
\.{WEAVE}'s internal memory; we have to figure out how to get them into
the desired final form. The job of converting token lists to characters in
the \TeX\ output file is not difficult, although it is an implicitly
recursive process. Four main considerations had to be kept in mind when
this part of \.{WEAVE} was designed.  (a) There are two modes of output:
\\{outer} mode, which translates tokens like \\{force} into line-breaking
control sequences, and \\{inner} mode, which ignores them except that blank
spaces take the place of line breaks. (b) The \\{cancel} instruction applies
to adjacent token or tokens that are output, and this cuts across levels
of recursion since `\\{cancel}' occurs at the beginning or end of a token
list on one level. (c) The \TeX\ output file will be semi-readable if line
breaks are inserted after the result of tokens like \\{break\_space} and
\\{force}.  (d) The final line break should be suppressed, and there should
be no \\{force} token output immediately after `\.{\\Y\\P}'.

\fi

\M201. The output process uses a stack to keep track of what is going on at
different ``levels'' as the token lists are being written out. Entries on
this stack have three parts:

\yskip\hang \\{end\_field} is the \\{tok\_mem} location where the token list of
a
particular level will end;

\yskip\hang \\{tok\_field} is the \\{tok\_mem} location from which the next
token
on a particular level will be read;

\yskip\hang \\{mode\_field} is the current mode, either \\{inner} or \\{outer}.

\yskip\noindent The current values of these quantities are referred to
quite frequently, so they are stored in a separate place instead of in the
\\{stack} array. We call the current values \\{cur\_end}, \\{cur\_tok}, and
\\{cur\_mode}.

The global variable \\{stack\_ptr} tells how many levels of output are
currently in progress. The end of output occurs when an \\{end\_translation}
token is found, so the stack is never empty except when we first begin the
output process.

\Y\P\D \37$\\{inner}=0$\C{value of \\{mode} for \PASCAL\ texts within \TeX\
texts}\par
\P\D \37$\\{outer}=1$\C{value of \\{mode} for \PASCAL\ texts in modules}\par
\Y\P$\4\X11:Types in the outer block\X\mathrel{+}\S$\6
$\\{mode}=\\{inner}\to\\{outer}$;\6
$\\{output\_state}=$\1\5
\1\&{record} \37\\{end\_field}: \37\\{sixteen\_bits};\C{ending location of
token list}\6
\4\\{tok\_field}: \37\\{sixteen\_bits};\C{present location within token list}\6
\4\\{mode\_field}: \37\\{mode};\C{interpretation of control tokens}\2\6
\&{end};\2\par
\fi

\M202. \P\D \37$\\{cur\_end}\S\\{cur\_state}.\\{end\_field}$\C{current ending
location in \\{tok\_mem}}\par
\P\D \37$\\{cur\_tok}\S\\{cur\_state}.\\{tok\_field}$\C{location of next output
token in \\{tok\_mem}}\par
\P\D \37$\\{cur\_mode}\S\\{cur\_state}.\\{mode\_field}$\C{current mode of
interpretation}\par
\P\D \37$\\{init\_stack}\S\\{stack\_ptr}\K0$;\5
$\\{cur\_mode}\K\\{outer}$\C{do this to initialize the stack}\par
\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{cur\_state}: \37\\{output\_state};\C{\\{cur\_end}, \\{cur\_tok}, \\{cur%
\_mode}}\6
\4\\{stack}: \37\&{array} $[1\to\\{stack\_size}]$ \1\&{of}\5
\\{output\_state};\C{info for non-current levels}\2\6
\4\\{stack\_ptr}: \37$0\to\\{stack\_size}$;\C{first unused location in the
output state stack}\6
\&{stat} \37\\{max\_stack\_ptr}: \37$0\to\\{stack\_size}$;\C{largest value
assumed by \\{stack\_ptr}}\6
\&{tats}\par
\fi

\M203. \P$\X10:Set initial values\X\mathrel{+}\S$\6
\&{stat} \37$\\{max\_stack\_ptr}\K0$;\ \&{tats}\par
\fi

\M204. To insert token-list \|p into the output, the \\{push\_level} subroutine
is called; it saves the old level of output and gets a new one going.
The value of \\{cur\_mode} is not changed.

\Y\P\4\&{procedure}\1\  \37$\\{push\_level}(\|p:\\{text\_pointer})$;\C{suspends
the current level}\2\6
\&{begin} \37\&{if} $\\{stack\_ptr}=\\{stack\_size}$ \1\&{then}\5
$\\{overflow}(\.{\'stack\'})$\6
\4\&{else} \&{begin} \37\&{if} $\\{stack\_ptr}>0$ \1\&{then}\5
$\\{stack}[\\{stack\_ptr}]\K\\{cur\_state}$;\C{save \\{cur\_end}$\,\ldots\,$%
\\{cur\_mode}}\2\6
$\\{incr}(\\{stack\_ptr})$;\6
\&{stat} \37\&{if} $\\{stack\_ptr}>\\{max\_stack\_ptr}$ \1\&{then}\5
$\\{max\_stack\_ptr}\K\\{stack\_ptr}$;\2\ \&{tats}\6
$\\{cur\_tok}\K\\{tok\_start}[\|p]$;\5
$\\{cur\_end}\K\\{tok\_start}[\|p+1]$;\6
\&{end};\2\6
\&{end};\par
\fi

\M205. Conversely, the \\{pop\_level} routine restores the conditions that were
in
force when the current level was begun. This subroutine will never be
called when $\\{stack\_ptr}=1$. It is so simple, we declare it as a macro:

\Y\P\D \37$\\{pop\_level}\S$\1\6
\&{begin} \37$\\{decr}(\\{stack\_ptr})$;\5
$\\{cur\_state}\K\\{stack}[\\{stack\_ptr}]$;\6
\&{end}\C{do this when \\{cur\_tok} reaches \\{cur\_end}}\2\par
\fi

\M206. The \\{get\_output} function returns the next byte of output that is not
a
reference to a token list. It returns the values \\{identifier} or \\{res%
\_word}
or \\{mod\_name} if the next token is to be an identifier (typeset in
italics), a reserved word (typeset in boldface) or a module name (typeset
by a complex routine that might generate additional levels of output).
In these cases \\{cur\_name} points to the identifier or module name in
question.

\Y\P\D \37$\\{res\_word}=\O{201}$\C{returned by \\{get\_output} for reserved
words}\par
\P\D \37$\\{mod\_name}=\O{200}$\C{returned by \\{get\_output} for module names}%
\par
\Y\P\4\&{function}\1\  \37\\{get\_output}: \37\\{eight\_bits};\C{returns the
next token of output}\6
\4\&{label} \37\\{restart};\6
\4\&{var} \37\|a: \37\\{sixteen\_bits};\C{current item read from \\{tok\_mem}}%
\2\6
\&{begin} \37\\{restart}: \37\&{while} $\\{cur\_tok}=\\{cur\_end}$ \1\&{do}\5
\\{pop\_level};\2\6
$\|a\K\\{tok\_mem}[\\{cur\_tok}]$;\5
$\\{incr}(\\{cur\_tok})$;\6
\&{if} $\|a\G\O{400}$ \1\&{then}\6
\&{begin} \37$\\{cur\_name}\K\|a\mathbin{\&{mod}}\\{id\_flag}$;\6
\&{case} $\|a\mathbin{\&{div}}\\{id\_flag}$ \1\&{of}\6
\42: \37$\|a\K\\{res\_word}$;\C{$\|a=\\{res\_flag}+\\{cur\_name}$}\6
\43: \37$\|a\K\\{mod\_name}$;\C{$\|a=\\{mod\_flag}+\\{cur\_name}$}\6
\44: \37\&{begin} \37$\\{push\_level}(\\{cur\_name})$;\5
\&{goto} \37\\{restart};\6
\&{end};\C{$\|a=\\{tok\_flag}+\\{cur\_name}$}\6
\45: \37\&{begin} \37$\\{push\_level}(\\{cur\_name})$;\5
$\\{cur\_mode}\K\\{inner}$;\5
\&{goto} \37\\{restart};\6
\&{end};\C{$\|a=\\{inner\_tok\_flag}+\\{cur\_name}$}\6
\4\&{othercases} \37$\|a\K\\{identifier}$\C{$\|a=\\{id\_flag}+\\{cur\_name}$}\2%
\6
\&{endcases};\6
\&{end};\2\6
\&{debug} \37\&{if} $\\{trouble\_shooting}$ \1\&{then}\5
\\{debug\_help};\ \2\6
\&{gubed}\6
$\\{get\_output}\K\|a$;\6
\&{end};\par
\fi

\M207. The real work associated with token output is done by \\{make\_output}.
This procedure appends an \\{end\_translation} token to the current token list,
and then it repeatedly calls \\{get\_output} and feeds characters to the output
buffer until reaching the \\{end\_translation} sentinel. It is possible for
\\{make\_output} to
be called recursively, since a module name may include embedded \PASCAL\
text; however, the depth of recursion never exceeds one level, since
module names cannot be inside of module names.

A procedure called \\{output\_Pascal} does the scanning, translation, and
output of \PASCAL\ text within `\pb' brackets, and this procedure uses
\\{make\_output} to output the current token list. Thus, the recursive call
of \\{make\_output} actually occurs when \\{make\_output} calls \\{output%
\_Pascal}
while outputting the name of a module.

\Y\P\4\&{procedure}\1\  \37\\{make\_output};\5
\\{forward};\5
\hbox{\2}\7
\4\&{procedure}\1\  \37\\{output\_Pascal};\C{outputs the current token list}\6
\4\&{var} \37$\\{save\_tok\_ptr},\39\\{save\_text\_ptr},\39\\{save\_next%
\_control}$: \37\\{sixteen\_bits};\C{values to be restored}\6
\|p: \37\\{text\_pointer};\C{translation of the \PASCAL\ text}\2\6
\&{begin} \37$\\{save\_tok\_ptr}\K\\{tok\_ptr}$;\5
$\\{save\_text\_ptr}\K\\{text\_ptr}$;\5
$\\{save\_next\_control}\K\\{next\_control}$;\5
$\\{next\_control}\K\.{"|"}$;\5
$\|p\K\\{Pascal\_translate}$;\5
$\\{app}(\|p+\\{inner\_tok\_flag})$;\5
\\{make\_output};\C{output the list}\6
\&{stat} \37\&{if} $\\{text\_ptr}>\\{max\_txt\_ptr}$ \1\&{then}\5
$\\{max\_txt\_ptr}\K\\{text\_ptr}$;\2\6
\&{if} $\\{tok\_ptr}>\\{max\_tok\_ptr}$ \1\&{then}\5
$\\{max\_tok\_ptr}\K\\{tok\_ptr}$;\2\ \&{tats}\6
$\\{text\_ptr}\K\\{save\_text\_ptr}$;\5
$\\{tok\_ptr}\K\\{save\_tok\_ptr}$;\C{forget the tokens}\6
$\\{next\_control}\K\\{save\_next\_control}$;\C{restore \\{next\_control} to
original state}\6
\&{end};\par
\fi

\M208. Here is \.{WEAVE}'s major output handler.

\Y\P\4\&{procedure}\1\  \37\\{make\_output};\C{outputs the equivalents of
tokens}\6
\4\&{label} \37$\\{reswitch},\39\\{exit},\39\\{found}$;\6
\4\&{var} \37\|a: \37\\{eight\_bits};\C{current output byte}\6
\|b: \37\\{eight\_bits};\C{next output byte}\6
$\|k,\39\\{k\_limit}$: \37$0\to\\{max\_bytes}$;\C{indices into \\{byte\_mem}}\6
\|w: \37$0\to\\{ww}-1$;\C{row of \\{byte\_mem}}\6
\|j: \37$0\to\\{long\_buf\_size}$;\C{index into \\{buffer}}\6
\\{string\_delimiter}: \37\\{ASCII\_code};\C{first and last character of
string being copied}\6
$\\{save\_loc},\39\\{save\_limit}$: \37$0\to\\{long\_buf\_size}$;\C{\\{loc} and
\\{limit} to be restored}\6
\\{cur\_mod\_name}: \37\\{name\_pointer};\C{name of module being output}\6
\\{save\_mode}: \37\\{mode};\C{value of \\{cur\_mode} before a sequence of
breaks}\2\6
\&{begin} \37$\\{app}(\\{end\_translation})$;\C{append a sentinel}\6
\\{freeze\_text};\5
$\\{push\_level}(\\{text\_ptr}-1)$;\6
\~ \1\&{loop}\ \&{begin} \37$\|a\K\\{get\_output}$;\6
\4\\{reswitch}: \37\&{case} $\|a$ \1\&{of}\6
\4\\{end\_translation}: \37\&{return};\6
\4$\\{identifier},\39\\{res\_word}$: \37\X209:Output an identifier\X;\6
\4\\{mod\_name}: \37\X213:Output a module name\X;\6
\4$\\{math\_bin},\39\\{math\_op},\39\\{math\_rel}$: \37\X210:Output a \.{%
\\math} operator\X;\6
\4\\{cancel}: \37\&{begin} \37\1\&{repeat} \37$\|a\K\\{get\_output}$;\6
\4\&{until}\5
$(\|a<\\{backup})\V(\|a>\\{big\_force})$;\2\6
\&{goto} \37\\{reswitch};\6
\&{end};\6
\4\\{big\_cancel}: \37\&{begin} \37\1\&{repeat} \37$\|a\K\\{get\_output}$;\6
\4\&{until}\5
$((\|a<\\{backup})\W(\|a\I\.{"\ "}))\V(\|a>\\{big\_force})$;\2\6
\&{goto} \37\\{reswitch};\6
\&{end};\6
\4$\\{indent},\39\\{outdent},\39\\{opt},\39\\{backup},\39\\{break\_space},\39%
\\{force},\39\\{big\_force}$: \37\X211:Output a \(control, look ahead in case
of line breaks, possibly \&{goto} \\{reswitch}\X;\6
\4\&{othercases} \37$\\{out}(\|a)$\C{otherwise \|a is an ASCII character}\2\6
\&{endcases};\6
\&{end};\2\6
\4\\{exit}: \37\&{end};\par
\fi

\M209. An identifier of length one does not have to be enclosed in braces, and
it
looks slightly better if set in a math-italic font instead of a (slightly
narrower) text-italic font. Thus we output `\.{\\\char'174a}' but
`\.{\\\\\{aa\}}'.

\Y\P$\4\X209:Output an identifier\X\S$\6
\&{begin} \37$\\{out}(\.{"\\"})$;\6
\&{if} $\|a=\\{identifier}$ \1\&{then}\6
\&{if} $\\{length}(\\{cur\_name})=1$ \1\&{then}\5
$\\{out}(\.{"|"})$\6
\4\&{else} $\\{out}(\.{"\\"})$\2\6
\4\&{else} $\\{out}(\.{"\&"})$;\C{$\|a=\\{res\_word}$}\2\6
\&{if} $\\{length}(\\{cur\_name})=1$ \1\&{then}\5
$\\{out}(\\{byte\_mem}[\\{cur\_name}\mathbin{\&{mod}}\\{ww},\39\\{byte\_start}[%
\\{cur\_name}]])$\6
\4\&{else} $\\{out\_name}(\\{cur\_name})$;\2\6
\&{end}\par
\U208.\fi

\M210. \P$\X210:Output a \.{\\math} operator\X\S$\6
\&{begin} \37$\\{out5}(\.{"\\"})(\.{"m"})(\.{"a"})(\.{"t"})(\.{"h"})$;\6
\&{if} $\|a=\\{math\_bin}$ \1\&{then}\5
$\\{out3}(\.{"b"})(\.{"i"})(\.{"n"})$\6
\4\&{else} \&{if} $\|a=\\{math\_rel}$ \1\&{then}\5
$\\{out3}(\.{"r"})(\.{"e"})(\.{"l"})$\6
\4\&{else} $\\{out2}(\.{"o"})(\.{"p"})$;\2\2\6
$\\{out}(\.{"\{"})$;\6
\&{end}\par
\U208.\fi

\M211. The current mode does not affect the behavior of \.{WEAVE}'s output
routine
except when we are outputting control tokens.

\Y\P$\4\X211:Output a \(control, look ahead in case of line breaks, possibly %
\&{goto} \\{reswitch}\X\S$\6
\&{if} $\|a<\\{break\_space}$ \1\&{then}\6
\&{begin} \37\&{if} $\\{cur\_mode}=\\{outer}$ \1\&{then}\6
\&{begin} \37$\\{out2}(\.{"\\"})(\|a-\\{cancel}+\.{"0"})$;\6
\&{if} $\|a=\\{opt}$ \1\&{then}\5
$\\{out}(\\{get\_output})$\C{\\{opt} is followed by a digit}\2\6
\&{end}\6
\4\&{else} \&{if} $\|a=\\{opt}$ \1\&{then}\5
$\|b\K\\{get\_output}$\C{ignore digit following \\{opt}}\2\2\6
\&{end}\6
\4\&{else} \X212:Look ahead for strongest line break, \&{goto} \\{reswitch}\X\2%
\par
\U208.\fi

\M212. If several of the tokens \\{break\_space}, \\{force}, \\{big\_force}
occur in a
row, possibly mixed with blank spaces (which are ignored),
the largest one is used. A line break also occurs in the output file,
except at the very end of the translation. The very first line break
is suppressed (i.e., a line break that follows `\.{\\Y\\P}').

\Y\P$\4\X212:Look ahead for strongest line break, \&{goto} \\{reswitch}\X\S$\6
\&{begin} \37$\|b\K\|a$;\5
$\\{save\_mode}\K\\{cur\_mode}$;\6
\~ \1\&{loop}\ \&{begin} \37$\|a\K\\{get\_output}$;\6
\&{if} $(\|a=\\{cancel})\V(\|a=\\{big\_cancel})$ \1\&{then}\5
\&{goto} \37\\{reswitch};\C{\\{cancel} overrides everything}\2\6
\&{if} $((\|a\I\.{"\ "})\W(\|a<\\{break\_space}))\V(\|a>\\{big\_force})$ \1%
\&{then}\6
\&{begin} \37\&{if} $\\{save\_mode}=\\{outer}$ \1\&{then}\6
\&{begin} \37\&{if} $\\{out\_ptr}>3$ \1\&{then}\6
\&{if} $(\\{out\_buf}[\\{out\_ptr}]=\.{"P"})\W(\\{out\_buf}[\\{out\_ptr}-1]=%
\.{"\\"})\W(\\{out\_buf}[\\{out\_ptr}-2]=\.{"Y"})\W(\\{out\_buf}[\\{out%
\_ptr}-3]=\.{"\\"})$ \1\&{then}\5
\&{goto} \37\\{reswitch};\2\2\6
$\\{out2}(\.{"\\"})(\|b-\\{cancel}+\.{"0"})$;\6
\&{if} $\|a\I\\{end\_translation}$ \1\&{then}\5
\\{finish\_line};\2\6
\&{end}\6
\4\&{else} \&{if} $(\|a\I\\{end\_translation})\W(\\{cur\_mode}=\\{inner})$ \1%
\&{then}\5
$\\{out}(\.{"\ "})$;\2\2\6
\&{goto} \37\\{reswitch};\6
\&{end};\2\6
\&{if} $\|a>\|b$ \1\&{then}\5
$\|b\K\|a$;\C{if $\|a=\.{"\ "}$ we have $\|a<\|b$}\2\6
\&{end};\2\6
\&{end}\par
\U211.\fi

\M213. The remaining part of \\{make\_output} is somewhat more complicated.
When we
output a module name, we may need to enter the parsing and translation
routines, since the name may contain \PASCAL\ code embedded in
\pb\ constructions. This \PASCAL\ code is placed at the end of the active
input buffer and the translation process uses the end of the active
\\{tok\_mem} area.

\Y\P$\4\X213:Output a module name\X\S$\6
\&{begin} \37$\\{out2}(\.{"\\"})(\.{"X"})$;\5
$\\{cur\_xref}\K\\{xref}[\\{cur\_name}]$;\6
\&{if} $\\{num}(\\{cur\_xref})\G\\{def\_flag}$ \1\&{then}\6
\&{begin} \37$\\{out\_mod}(\\{num}(\\{cur\_xref})-\\{def\_flag})$;\6
\&{if} $\\{phase\_three}$ \1\&{then}\6
\&{begin} \37$\\{cur\_xref}\K\\{xlink}(\\{cur\_xref})$;\6
\&{while} $\\{num}(\\{cur\_xref})\G\\{def\_flag}$ \1\&{do}\6
\&{begin} \37$\\{out2}(\.{","})(\.{"\ "})$;\5
$\\{out\_mod}(\\{num}(\\{cur\_xref})-\\{def\_flag})$;\5
$\\{cur\_xref}\K\\{xlink}(\\{cur\_xref})$;\6
\&{end};\2\6
\&{end};\2\6
\&{end}\6
\4\&{else} $\\{out}(\.{"0"})$;\C{output the module number, or zero if it was
undefined}\2\6
$\\{out}(\.{":"})$;\5
\X214:Output the text of the module name\X;\6
$\\{out2}(\.{"\\"})(\.{"X"})$;\6
\&{end}\par
\U208.\fi

\M214. \P$\X214:Output the text of the module name\X\S$\6
$\|k\K\\{byte\_start}[\\{cur\_name}]$;\5
$\|w\K\\{cur\_name}\mathbin{\&{mod}}\\{ww}$;\5
$\\{k\_limit}\K\\{byte\_start}[\\{cur\_name}+\\{ww}]$;\5
$\\{cur\_mod\_name}\K\\{cur\_name}$;\6
\&{while} $\|k<\\{k\_limit}$ \1\&{do}\6
\&{begin} \37$\|b\K\\{byte\_mem}[\|w,\39\|k]$;\5
$\\{incr}(\|k)$;\6
\&{if} $\|b=\.{"@"}$ \1\&{then}\5
\X215:Skip next character, give error if not `\.{@}'\X;\2\6
\&{if} $\|b\I\.{"|"}$ \1\&{then}\5
$\\{out}(\|b)$\6
\4\&{else} \&{begin} \37\X216:Copy the \PASCAL\ text into $\\{buffer}[(%
\\{limit}+1)\to\|j]$\X;\6
$\\{save\_loc}\K\\{loc}$;\5
$\\{save\_limit}\K\\{limit}$;\5
$\\{loc}\K\\{limit}+2$;\5
$\\{limit}\K\|j+1$;\5
$\\{buffer}[\\{limit}]\K\.{"|"}$;\5
\\{output\_Pascal};\5
$\\{loc}\K\\{save\_loc}$;\5
$\\{limit}\K\\{save\_limit}$;\6
\&{end};\2\6
\&{end}\2\par
\U213.\fi

\M215. \P$\X215:Skip next character, give error if not `\.{@}'\X\S$\6
\&{begin} \37\&{if} $\\{byte\_mem}[\|w,\39\|k]\I\.{"@"}$ \1\&{then}\6
\&{begin} \37$\\{print\_nl}(\.{\'!\ Illegal\ control\ code\ in\ section\ name:%
\'})$;\5
$\\{print\_nl}(\.{\'<\'})$;\5
$\\{print\_id}(\\{cur\_mod\_name})$;\5
$\\{print}(\.{\'>\ \'})$;\5
\\{mark\_error};\6
\&{end};\2\6
$\\{incr}(\|k)$;\6
\&{end}\par
\U214.\fi

\M216. The \PASCAL\ text enclosed in \pb\ should not contain `\v' characters,
except within strings. We put a `\v' at the front of the buffer, so that an
error message that displays the whole buffer will look a little bit sensible.
The variable \\{string\_delimiter} is zero outside of strings, otherwise it
equals the delimiter that began the string being copied.

\Y\P$\4\X216:Copy the \PASCAL\ text into $\\{buffer}[(\\{limit}+1)\to\|j]$\X\S$%
\6
$\|j\K\\{limit}+1$;\5
$\\{buffer}[\|j]\K\.{"|"}$;\5
$\\{string\_delimiter}\K0$;\6
\~ \1\&{loop}\ \&{begin} \37\&{if} $\|k\G\\{k\_limit}$ \1\&{then}\6
\&{begin} \37$\\{print\_nl}(\.{\'!\ Pascal\ text\ in\ section\ name\ didn\'}\.{%
\'t\ end:\'})$;\5
$\\{print\_nl}(\.{\'<\'})$;\5
$\\{print\_id}(\\{cur\_mod\_name})$;\5
$\\{print}(\.{\'>\ \'})$;\5
\\{mark\_error};\5
\&{goto} \37\\{found};\6
\&{end};\2\6
$\|b\K\\{byte\_mem}[\|w,\39\|k]$;\5
$\\{incr}(\|k)$;\6
\&{if} $\|b=\.{"@"}$ \1\&{then}\5
\X217:Copy a control code into the buffer\X\6
\4\&{else} \&{begin} \37\&{if} $(\|b=\.{""}\.{""})\V(\|b=\.{"\'"})$ \1\&{then}\6
\&{if} $\\{string\_delimiter}=0$ \1\&{then}\5
$\\{string\_delimiter}\K\|b$\6
\4\&{else} \&{if} $\\{string\_delimiter}=\|b$ \1\&{then}\5
$\\{string\_delimiter}\K0$;\2\2\2\6
\&{if} $(\|b\I\.{"|"})\V(\\{string\_delimiter}\I0)$ \1\&{then}\6
\&{begin} \37\&{if} $\|j>\\{long\_buf\_size}-3$ \1\&{then}\5
$\\{overflow}(\.{\'buffer\'})$;\2\6
$\\{incr}(\|j)$;\5
$\\{buffer}[\|j]\K\|b$;\6
\&{end}\6
\4\&{else} \&{goto} \37\\{found};\2\6
\&{end};\2\6
\&{end};\2\6
\4\\{found}: \37\par
\U214.\fi

\M217. \P$\X217:Copy a control code into the buffer\X\S$\6
\&{begin} \37\&{if} $\|j>\\{long\_buf\_size}-4$ \1\&{then}\5
$\\{overflow}(\.{\'buffer\'})$;\2\6
$\\{buffer}[\|j+1]\K\.{"@"}$;\5
$\\{buffer}[\|j+2]\K\\{byte\_mem}[\|w,\39\|k]$;\5
$\|j\K\|j+2$;\5
$\\{incr}(\|k)$;\6
\&{end}\par
\U216.\fi

\N218.  Phase two processing.
We have assembled enough pieces of the puzzle in order to be ready to specify
the processing in \.{WEAVE}'s main pass over the source file. Phase two
is analogous to phase one, except that more work is involved because we must
actually output the \TeX\ material instead of merely looking at the
\.{WEB} specifications.

\Y\P$\4\X218:Phase II: Read all the text again and translate it to \TeX\ form\X%
\S$\6
\\{reset\_input};\5
$\\{print\_nl}(\.{\'Writing\ the\ output\ file...\'})$;\5
$\\{module\_count}\K0$;\5
\\{copy\_limbo};\5
\\{finish\_line};\5
$\\{flush\_buffer}(0,\39\\{false},\39\\{false})$;\C{insert a blank line, it
looks nice}\6
\&{while} $\R\\{input\_has\_ended}$ \1\&{do}\5
\X220:Translate the \(current module\X\2\par
\U261.\fi

\M219. The output file will contain the control sequence \.{\\Y} between
non-null
sections of a module, e.g., between the \TeX\ and definition parts if both
are nonempty. This puts a little white space between the parts when they are
printed. However, we don't want \.{\\Y} to occur between two definitions
within a single module. The variables \\{out\_line} or \\{out\_ptr} will
change if a section is non-null, so the following macros `\\{save\_position}'
and `\\{emit\_space\_if\_needed}' are able to handle the situation:

\Y\P\D \37$\\{save\_position}\S\\{save\_line}\K\\{out\_line}$;\5
$\\{save\_place}\K\\{out\_ptr}$\par
\P\D \37$\\{emit\_space\_if\_needed}\S$\1\6
\&{if} $(\\{save\_line}\I\\{out\_line})\V(\\{save\_place}\I\\{out\_ptr})$ \1%
\&{then}\5
$\\{out2}(\.{"\\"})(\.{"Y"})$\2\2\par
\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{save\_line}: \37\\{integer};\C{former value of \\{out\_line}}\6
\4\\{save\_place}: \37\\{sixteen\_bits};\C{former value of \\{out\_ptr}}\par
\fi

\M220. \P$\X220:Translate the \(current module\X\S$\6
\&{begin} \37$\\{incr}(\\{module\_count})$;\6
\X221:Output the code for the beginning of a new module\X;\6
\\{save\_position};\6
\X222:Translate the \TeX\ part of the current module\X;\6
\X225:Translate the \(definition part of the current module\X;\6
\X230:Translate the \PASCAL\ part of the current module\X;\6
\X233:Show cross references to this module\X;\6
\X238:Output the code for the end of a module\X;\6
\&{end}\par
\U218.\fi

\M221. Modules beginning with the \.{WEB} control sequence `\.{@\ }' start in
the
output with the \TeX\ control sequence `\.{\\M}', followed by the module
number. Similarly, `\.{@*}' modules lead to the control sequence `\.{\\N}'.
If this is a changed module, we put \.{*} just before the module number.

\Y\P$\4\X221:Output the code for the beginning of a new module\X\S$\6
$\\{out}(\.{"\\"})$;\6
\&{if} $\\{buffer}[\\{loc}-1]\I\.{"*"}$ \1\&{then}\5
$\\{out}(\.{"M"})$\6
\4\&{else} \&{begin} \37$\\{out}(\.{"N"})$;\5
$\\{print}(\.{\'*\'},\39\\{module\_count}:1)$;\5
\\{update\_terminal};\C{print a progress report}\6
\&{end};\2\6
$\\{out\_mod}(\\{module\_count})$;\5
$\\{out2}(\.{"."})(\.{"\ "})$\par
\U220.\fi

\M222. In the \TeX\ part of a module, we simply copy the source text, except
that
index entries are not copied and \PASCAL\ text within \pb\ is translated.

\Y\P$\4\X222:Translate the \TeX\ part of the current module\X\S$\6
\1\&{repeat} \37$\\{next\_control}\K\\{copy\_TeX}$;\6
\&{case} $\\{next\_control}$ \1\&{of}\6
\4\.{"|"}: \37\&{begin} \37\\{init\_stack};\5
\\{output\_Pascal};\6
\&{end};\6
\4\.{"@"}: \37$\\{out}(\.{"@"})$;\6
\4\\{octal}: \37\X223:Translate an octal constant appearing in \TeX\ text\X;\6
\4\\{hex}: \37\X224:Translate a hexadecimal constant appearing in \TeX\ text\X;%
\6
\4$\\{TeX\_string},\39\\{xref\_roman},\39\\{xref\_wildcard},\39\\{xref%
\_typewriter},\39\\{module\_name}$: \37\&{begin} \37$\\{loc}\K\\{loc}-2$;\5
$\\{next\_control}\K\\{get\_next}$;\C{skip to \.{@>}}\6
\&{if} $\\{next\_control}=\\{TeX\_string}$ \1\&{then}\5
$\\{err\_print}(\.{\'!\ TeX\ string\ should\ be\ in\ Pascal\ text\ only\'})$;\2%
\6
\&{end};\6
\4$\\{begin\_comment},\39\\{end\_comment},\39\\{check\_sum},\39\\{thin\_space},%
\39\\{math\_break},\39\\{line\_break},\39\\{big\_line\_break},\39\\{no\_line%
\_break},\39\\{join},\39\\{pseudo\_semi}$: \37$\\{err\_print}(\.{\'!\ You\ can%
\'}\.{\'t\ do\ that\ in\ TeX\ text\'})$;\6
\4\&{othercases} \37\\{do\_nothing}\2\6
\&{endcases};\6
\4\&{until}\5
$\\{next\_control}\G\\{format}$\2\par
\U220.\fi

\M223. \P$\X223:Translate an octal constant appearing in \TeX\ text\X\S$\6
\&{begin} \37$\\{out3}(\.{"\\"})(\.{"O"})(\.{"\{"})$;\6
\&{while} $(\\{buffer}[\\{loc}]\G\.{"0"})\W(\\{buffer}[\\{loc}]\L\.{"7"})$ \1%
\&{do}\6
\&{begin} \37$\\{out}(\\{buffer}[\\{loc}])$;\5
$\\{incr}(\\{loc})$;\6
\&{end};\C{since $\\{buffer}[\\{limit}]=\.{"\ "}$, this loop will end}\2\6
$\\{out}(\.{"\}"})$;\6
\&{end}\par
\U222.\fi

\M224. \P$\X224:Translate a hexadecimal constant appearing in \TeX\ text\X\S$\6
\&{begin} \37$\\{out3}(\.{"\\"})(\.{"H"})(\.{"\{"})$;\6
\&{while} $((\\{buffer}[\\{loc}]\G\.{"0"})\W(\\{buffer}[\\{loc}]\L\.{"9"}))\V%
\30((\\{buffer}[\\{loc}]\G\.{"A"})\W(\\{buffer}[\\{loc}]\L\.{"F"}))$ \1\&{do}\6
\&{begin} \37$\\{out}(\\{buffer}[\\{loc}])$;\5
$\\{incr}(\\{loc})$;\6
\&{end};\2\6
$\\{out}(\.{"\}"})$;\6
\&{end}\par
\U222.\fi

\M225. When we get to the following code we have $\\{next\_control}\G%
\\{format}$, and
the token memory is in its initial empty state.

\Y\P$\4\X225:Translate the \(definition part of the current module\X\S$\6
\&{if} $\\{next\_control}\L\\{definition}$ \1\&{then}\C{definition part
non-empty}\6
\&{begin} \37\\{emit\_space\_if\_needed};\5
\\{save\_position};\6
\&{end};\2\6
\&{while} $\\{next\_control}\L\\{definition}$ \1\&{do}\C{\\{format} or %
\\{definition}}\6
\&{begin} \37\\{init\_stack};\6
\&{if} $\\{next\_control}=\\{definition}$ \1\&{then}\5
\X227:Start a macro definition\X\6
\4\&{else} \X228:Start a format definition\X;\2\6
\\{outer\_parse};\5
\\{finish\_Pascal};\6
\&{end}\2\par
\U220.\fi

\M226. The \\{finish\_Pascal} procedure outputs the translation of the current
scraps, preceded by the control sequence `\.{\\P}' and followed by the
control sequence `\.{\\par}'. It also restores the token and scrap
memories to their initial empty state.

A \\{force} token is appended to the current scraps before translation
takes place, so that the translation will normally end with \.{\\6} or
\.{\\7} (the \TeX\ macros for \\{force} and \\{big\_force}). This \.{\\6} or
\.{\\7} is replaced by the concluding \.{\\par} or by \.{\\Y\\par}.

\Y\P\4\&{procedure}\1\  \37\\{finish\_Pascal};\C{finishes a definition or a %
\PASCAL\ part}\6
\4\&{var} \37\|p: \37\\{text\_pointer};\C{translation of the scraps}\2\6
\&{begin} \37$\\{out2}(\.{"\\"})(\.{"P"})$;\5
$\\{app\_tok}(\\{force})$;\5
\\{app\_comment};\5
$\|p\K\\{translate}$;\5
$\\{app}(\|p+\\{tok\_flag})$;\5
\\{make\_output};\C{output the list}\6
\&{if} $\\{out\_ptr}>1$ \1\&{then}\6
\&{if} $\\{out\_buf}[\\{out\_ptr}-1]=\.{"\\"}$ \1\&{then}\6
\&{if} $\\{out\_buf}[\\{out\_ptr}]=\.{"6"}$ \1\&{then}\5
$\\{out\_ptr}\K\\{out\_ptr}-2$\6
\4\&{else} \&{if} $\\{out\_buf}[\\{out\_ptr}]=\.{"7"}$ \1\&{then}\5
$\\{out\_buf}[\\{out\_ptr}]\K\.{"Y"}$;\2\2\2\2\6
$\\{out4}(\.{"\\"})(\.{"p"})(\.{"a"})(\.{"r"})$;\5
\\{finish\_line};\6
\&{stat} \37\&{if} $\\{text\_ptr}>\\{max\_txt\_ptr}$ \1\&{then}\5
$\\{max\_txt\_ptr}\K\\{text\_ptr}$;\2\6
\&{if} $\\{tok\_ptr}>\\{max\_tok\_ptr}$ \1\&{then}\5
$\\{max\_tok\_ptr}\K\\{tok\_ptr}$;\2\6
\&{if} $\\{scrap\_ptr}>\\{max\_scr\_ptr}$ \1\&{then}\5
$\\{max\_scr\_ptr}\K\\{scrap\_ptr}$;\2\6
\&{tats}\6
$\\{tok\_ptr}\K1$;\5
$\\{text\_ptr}\K1$;\5
$\\{scrap\_ptr}\K0$;\C{forget the tokens and the scraps}\6
\&{end};\par
\fi

\M227. \P$\X227:Start a macro definition\X\S$\6
\&{begin} \37$\\{sc2}(\.{"\\"})(\.{"D"})(\\{intro})$;\C{this will produce `%
\&{define }'}\6
$\\{next\_control}\K\\{get\_next}$;\6
\&{if} $\\{next\_control}\I\\{identifier}$ \1\&{then}\5
$\\{err\_print}(\.{\'!\ Improper\ macro\ definition\'})$\6
\4\&{else} $\\{sc1}(\\{id\_flag}+\\{id\_lookup}(\\{normal}))(\\{math})$;\2\6
$\\{next\_control}\K\\{get\_next}$;\6
\&{end}\par
\U225.\fi

\M228. \P$\X228:Start a format definition\X\S$\6
\&{begin} \37$\\{sc2}(\.{"\\"})(\.{"F"})(\\{intro})$;\C{this will produce `%
\&{format }'}\6
$\\{next\_control}\K\\{get\_next}$;\6
\&{if} $\\{next\_control}=\\{identifier}$ \1\&{then}\6
\&{begin} \37$\\{sc1}(\\{id\_flag}+\\{id\_lookup}(\\{normal}))(\\{math})$;\5
$\\{next\_control}\K\\{get\_next}$;\6
\&{if} $\\{next\_control}=\\{equivalence\_sign}$ \1\&{then}\6
\&{begin} \37$\\{sc2}(\.{"\\"})(\.{"S"})(\\{math})$;\C{output an equivalence
sign}\6
$\\{next\_control}\K\\{get\_next}$;\6
\&{if} $\\{next\_control}=\\{identifier}$ \1\&{then}\6
\&{begin} \37$\\{sc1}(\\{id\_flag}+\\{id\_lookup}(\\{normal}))(\\{math})$;\5
$\\{sc0}(\\{semi})$;\C{insert an invisible semicolon}\6
$\\{next\_control}\K\\{get\_next}$;\6
\&{end};\2\6
\&{end};\2\6
\&{end};\2\6
\&{if} $\\{scrap\_ptr}\I5$ \1\&{then}\5
$\\{err\_print}(\.{\'!\ Improper\ format\ definition\'})$;\2\6
\&{end}\par
\U225.\fi

\M229. Finally, when the \TeX\ and definition parts have been treated, we have
$\\{next\_control}\G\\{begin\_Pascal}$. We will make the global variable %
\\{this\_module}
point to the current module name, if it has a name.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{this\_module}: \37\\{name\_pointer};\C{the current module name, or zero}%
\par
\fi

\M230. \P$\X230:Translate the \PASCAL\ part of the current module\X\S$\6
$\\{this\_module}\K0$;\6
\&{if} $\\{next\_control}\L\\{module\_name}$ \1\&{then}\6
\&{begin} \37\\{emit\_space\_if\_needed};\5
\\{init\_stack};\6
\&{if} $\\{next\_control}=\\{begin\_Pascal}$ \1\&{then}\5
$\\{next\_control}\K\\{get\_next}$\6
\4\&{else} \&{begin} \37$\\{this\_module}\K\\{cur\_module}$;\5
\X231:Check that $=$ or $\S$ follows this module name, and emit the scraps to
start the module definition\X;\6
\&{end};\2\6
\&{while} $\\{next\_control}\L\\{module\_name}$ \1\&{do}\6
\&{begin} \37\\{outer\_parse};\5
\X232:Emit the scrap for a module name if present\X;\6
\&{end};\2\6
\\{finish\_Pascal};\6
\&{end}\2\par
\U220.\fi

\M231. \P$\X231:Check that $=$ or $\S$ follows this module name, and emit the
scraps to start the module definition\X\S$\6
\1\&{repeat} \37$\\{next\_control}\K\\{get\_next}$;\6
\4\&{until}\5
$\\{next\_control}\I\.{"+"}$;\C{allow optional `\.{+=}'}\2\6
\&{if} $(\\{next\_control}\I\.{"="})\W(\\{next\_control}\I\\{equivalence%
\_sign})$ \1\&{then}\5
$\\{err\_print}(\.{\'!\ You\ need\ an\ =\ sign\ after\ the\ section\ name\'})$\6
\4\&{else} $\\{next\_control}\K\\{get\_next}$;\2\6
\&{if} $\\{out\_ptr}>1$ \1\&{then}\6
\&{if} $(\\{out\_buf}[\\{out\_ptr}]=\.{"Y"})\W(\\{out\_buf}[\\{out\_ptr}-1]=%
\.{"\\"})$ \1\&{then}\6
\&{begin} \37$\\{app}(\\{backup})$;\C{the module name will be flush left}\6
\&{end};\2\2\6
$\\{sc1}(\\{mod\_flag}+\\{this\_module})(\\{mod\_scrap})$;\5
$\\{cur\_xref}\K\\{xref}[\\{this\_module}]$;\6
\&{if} $\\{num}(\\{cur\_xref})\I\\{module\_count}+\\{def\_flag}$ \1\&{then}\6
\&{begin} \37$\\{sc3}(\\{math\_rel})(\.{"+"})(\.{"\}"})(\\{math})$;\C{module
name is multiply defined}\6
$\\{this\_module}\K0$;\C{so we won't give cross-reference info here}\6
\&{end};\2\6
$\\{sc2}(\.{"\\"})(\.{"S"})(\\{math})$;\C{output an equivalence sign}\6
$\\{sc1}(\\{force})(\\{semi})$;\C{this forces a line break unless `\.{@+}'
follows}\par
\U230.\fi

\M232. \P$\X232:Emit the scrap for a module name if present\X\S$\6
\&{if} $\\{next\_control}<\\{module\_name}$ \1\&{then}\6
\&{begin} \37$\\{err\_print}(\.{\'!\ You\ can\'}\.{\'t\ do\ that\ in\ Pascal\
text\'})$;\5
$\\{next\_control}\K\\{get\_next}$;\6
\&{end}\6
\4\&{else} \&{if} $\\{next\_control}=\\{module\_name}$ \1\&{then}\6
\&{begin} \37$\\{sc1}(\\{mod\_flag}+\\{cur\_module})(\\{mod\_scrap})$;\5
$\\{next\_control}\K\\{get\_next}$;\6
\&{end}\2\2\par
\U230.\fi

\M233. Cross references relating to a named module are given after the module
ends.

\Y\P$\4\X233:Show cross references to this module\X\S$\6
\&{if} $\\{this\_module}>0$ \1\&{then}\6
\&{begin} \37\X235:Rearrange the list pointed to by \\{cur\_xref}\X;\6
$\\{footnote}(\\{def\_flag})$;\5
$\\{footnote}(0)$;\6
\&{end}\2\par
\U220.\fi

\M234. To rearrange the order of the linked list of cross references, we need
four more variables that point to cross reference entries.  We'll end up
with a list pointed to by \\{cur\_xref}.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4$\\{next\_xref},\39\\{this\_xref},\39\\{first\_xref},\39\\{mid\_xref}$: \37%
\\{xref\_number};\C{pointer variables for rearranging a list}\par
\fi

\M235. We want to rearrange the cross reference list so that all the entries
with
\\{def\_flag} come first, in ascending order; then come all the other
entries, in ascending order.  There may be no entries in either one or both
of these categories.

\Y\P$\4\X235:Rearrange the list pointed to by \\{cur\_xref}\X\S$\6
$\\{first\_xref}\K\\{xref}[\\{this\_module}]$;\5
$\\{this\_xref}\K\\{xlink}(\\{first\_xref})$;\C{bypass current module number}\6
\&{if} $\\{num}(\\{this\_xref})>\\{def\_flag}$ \1\&{then}\6
\&{begin} \37$\\{mid\_xref}\K\\{this\_xref}$;\5
$\\{cur\_xref}\K0$;\C{this value doesn't matter}\6
\1\&{repeat} \37$\\{next\_xref}\K\\{xlink}(\\{this\_xref})$;\5
$\\{xlink}(\\{this\_xref})\K\\{cur\_xref}$;\5
$\\{cur\_xref}\K\\{this\_xref}$;\5
$\\{this\_xref}\K\\{next\_xref}$;\6
\4\&{until}\5
$\\{num}(\\{this\_xref})\L\\{def\_flag}$;\2\6
$\\{xlink}(\\{first\_xref})\K\\{cur\_xref}$;\6
\&{end}\6
\4\&{else} $\\{mid\_xref}\K0$;\C{first list null}\2\6
$\\{cur\_xref}\K0$;\6
\&{while} $\\{this\_xref}\I0$ \1\&{do}\6
\&{begin} \37$\\{next\_xref}\K\\{xlink}(\\{this\_xref})$;\5
$\\{xlink}(\\{this\_xref})\K\\{cur\_xref}$;\5
$\\{cur\_xref}\K\\{this\_xref}$;\5
$\\{this\_xref}\K\\{next\_xref}$;\6
\&{end};\2\6
\&{if} $\\{mid\_xref}>0$ \1\&{then}\5
$\\{xlink}(\\{mid\_xref})\K\\{cur\_xref}$\6
\4\&{else} $\\{xlink}(\\{first\_xref})\K\\{cur\_xref}$;\2\6
$\\{cur\_xref}\K\\{xlink}(\\{first\_xref})$\par
\U233.\fi

\M236. The \\{footnote} procedure gives cross reference information about
multiply defined module names (if the \\{flag} parameter is \\{def\_flag}), or
about
the uses of a module name (if the \\{flag} parameter is zero). It assumes that
\\{cur\_xref} points to the first cross-reference entry of interest, and it
leaves \\{cur\_xref} pointing to the first element not printed.  Typical
outputs:
`\.{\\A101.}'; `\.{\\Us370\\ET1009.}'; `\.{\\As8, 27\\*, 51\\ETs64.}'.

\Y\P\4\&{procedure}\1\  \37$\\{footnote}(\\{flag}:\\{sixteen\_bits})$;%
\C{outputs module cross-references}\6
\4\&{label} \37$\\{done},\39\\{exit}$;\6
\4\&{var} \37\|q: \37\\{xref\_number};\C{cross-reference pointer variable}\2\6
\&{begin} \37\&{if} $\\{num}(\\{cur\_xref})\L\\{flag}$ \1\&{then}\5
\&{return};\2\6
\\{finish\_line};\5
$\\{out}(\.{"\\"})$;\6
\&{if} $\\{flag}=0$ \1\&{then}\5
$\\{out}(\.{"U"})$\ \&{else} $\\{out}(\.{"A"})$;\2\6
\X237:Output all the module numbers on the reference list \\{cur\_xref}\X;\6
$\\{out}(\.{"."})$;\6
\4\\{exit}: \37\&{end};\par
\fi

\M237. The following code distinguishes three cases, according as the number
of cross references is one, two, or more than two. Variable \|q points
to the first cross reference, and the last link is a zero.

\Y\P$\4\X237:Output all the module numbers on the reference list \\{cur\_xref}%
\X\S$\6
$\|q\K\\{cur\_xref}$;\6
\&{if} $\\{num}(\\{xlink}(\|q))>\\{flag}$ \1\&{then}\5
$\\{out}(\.{"s"})$;\C{plural}\2\6
\~ \1\&{loop}\ \&{begin} \37$\\{out\_mod}(\\{num}(\\{cur\_xref})-\\{flag})$;\5
$\\{cur\_xref}\K\\{xlink}(\\{cur\_xref})$;\C{point to the next cross reference
to output}\6
\&{if} $\\{num}(\\{cur\_xref})\L\\{flag}$ \1\&{then}\5
\&{goto} \37\\{done};\2\6
\&{if} $\\{num}(\\{xlink}(\\{cur\_xref}))>\\{flag}$ \1\&{then}\5
$\\{out2}(\.{","})(\.{"\ "})$\C{not the last}\6
\4\&{else} \&{begin} \37$\\{out3}(\.{"\\"})(\.{"E"})(\.{"T"})$;\C{the last}\6
\&{if} $\\{cur\_xref}\I\\{xlink}(\|q)$ \1\&{then}\5
$\\{out}(\.{"s"})$;\C{the last of more than two}\2\6
\&{end};\2\6
\&{end};\2\6
\4\\{done}: \37\par
\U236.\fi

\M238. \P$\X238:Output the code for the end of a module\X\S$\6
$\\{out3}(\.{"\\"})(\.{"f"})(\.{"i"})$;\5
\\{finish\_line};\5
$\\{flush\_buffer}(0,\39\\{false},\39\\{false})$;\C{insert a blank line, it
looks nice}\par
\U220.\fi

\N239.  Phase three processing.
We are nearly finished! \.{WEAVE}'s only remaining task is to write out the
index, after sorting the identifiers and index entries.

\Y\P$\4\X239:Phase III: Output the cross-reference index\X\S$\6
$\\{phase\_three}\K\\{true}$;\5
$\\{print\_nl}(\.{\'Writing\ the\ index...\'})$;\6
\&{if} $\\{change\_exists}$ \1\&{then}\6
\&{begin} \37\\{finish\_line};\5
\X241:Tell about changed modules\X;\6
\&{end};\2\6
\\{finish\_line};\5
$\\{out4}(\.{"\\"})(\.{"i"})(\.{"n"})(\.{"x"})$;\5
\\{finish\_line};\5
\X243:Do the first pass of sorting\X;\6
\X250:Sort and output the index\X;\6
$\\{out4}(\.{"\\"})(\.{"f"})(\.{"i"})(\.{"n"})$;\5
\\{finish\_line};\5
\X257:Output all the module names\X;\6
$\\{out4}(\.{"\\"})(\.{"c"})(\.{"o"})(\.{"n"})$;\5
\\{finish\_line};\5
$\\{print}(\.{\'Done.\'})$;\par
\U261.\fi

\M240. Just before the index comes a list of all the changed modules, including
the index module itself.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{k\_module}: \37$0\to\\{max\_modules}$;\C{runs through the modules}\par
\fi

\M241. \P$\X241:Tell about changed modules\X\S$\6
\&{begin} \37\C{remember that the index is already marked as changed}\6
$\\{k\_module}\K1$;\5
$\\{out4}(\.{"\\"})(\.{"c"})(\.{"h"})(\.{"\ "})$;\6
\&{while} $\\{k\_module}<\\{module\_count}$ \1\&{do}\6
\&{begin} \37\&{if} $\\{changed\_module}[\\{k\_module}]$ \1\&{then}\6
\&{begin} \37$\\{out\_mod}(\\{k\_module})$;\5
$\\{out2}(\.{","})(\.{"\ "})$;\6
\&{end};\2\6
$\\{incr}(\\{k\_module})$;\6
\&{end};\2\6
$\\{out\_mod}(\\{k\_module})$;\5
$\\{out}(\.{"."})$;\6
\&{end}\par
\U239.\fi

\M242. A left-to-right radix sorting method is used, since this makes it easy
to
adjust the collating sequence and since the running time will be at worst
proportional to the total length of all entries in the index. We put the
identifiers into 230 different lists based on their first characters.
(Uppercase letters are put into the same list as the corresponding lowercase
letters, since we want to have `$t<\\{TeX}<\&{to}$'.) The
list for character \|c begins at location $\\{bucket}[\|c]$ and continues
through
the \\{blink} array.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{bucket}: \37\&{array} $[\\{ASCII\_code}]$ \1\&{of}\5
\\{name\_pointer};\2\6
\4\\{next\_name}: \37\\{name\_pointer};\C{successor of \\{cur\_name} when
sorting}\6
\4\|c: \37\\{ASCII\_code};\C{index into \\{bucket}}\6
\4\|h: \37$0\to\\{hash\_size}$;\C{index into \\{hash}}\6
\4\\{blink}: \37\&{array} $[0\to\\{max\_names}]$ \1\&{of}\5
\\{sixteen\_bits};\C{links in the buckets}\2\par
\fi

\M243. To begin the sorting, we go through all the hash lists and put each
entry
having a nonempty cross-reference list into the proper bucket.

\Y\P$\4\X243:Do the first pass of sorting\X\S$\6
\&{for} $\|c\K0\mathrel{\&{to}}255$ \1\&{do}\5
$\\{bucket}[\|c]\K0$;\2\6
\&{for} $\|h\K0\mathrel{\&{to}}\\{hash\_size}-1$ \1\&{do}\6
\&{begin} \37$\\{next\_name}\K\\{hash}[\|h]$;\6
\&{while} $\\{next\_name}\I0$ \1\&{do}\6
\&{begin} \37$\\{cur\_name}\K\\{next\_name}$;\5
$\\{next\_name}\K\\{link}[\\{cur\_name}]$;\6
\&{if} $\\{xref}[\\{cur\_name}]\I0$ \1\&{then}\6
\&{begin} \37$\|c\K\\{byte\_mem}[\\{cur\_name}\mathbin{\&{mod}}\\{ww},\39%
\\{byte\_start}[\\{cur\_name}]]$;\6
\&{if} $(\|c\L\.{"Z"})\W(\|c\G\.{"A"})$ \1\&{then}\5
$\|c\K\|c+\O{40}$;\2\6
$\\{blink}[\\{cur\_name}]\K\\{bucket}[\|c]$;\5
$\\{bucket}[\|c]\K\\{cur\_name}$;\6
\&{end};\2\6
\&{end};\2\6
\&{end}\2\par
\U239.\fi

\M244. During the sorting phase we shall use the \\{cat} and \\{trans} arrays
from
\.{WEAVE}'s parsing algorithm and rename them \\{depth} and \\{head}. They now
represent a stack of identifier lists for all the index entries that have
not yet been output. The variable \\{sort\_ptr} tells how many such lists are
present; the lists are output in reverse order (first \\{sort\_ptr}, then
$\\{sort\_ptr}-1$, etc.). The \|jth list starts at $\\{head}[\|j]$, and if the
first
\|k characters of all entries on this list are known to be equal we have
$\\{depth}[\|j]=\|k$.

\Y\P\D \37$\\{depth}\S\\{cat}$\C{reclaims memory that is no longer needed for
parsing}\par
\P\D \37$\\{head}\S\\{trans}$\C{ditto}\par
\P\D \37$\\{sort\_ptr}\S\\{scrap\_ptr}$\C{ditto}\par
\P\D \37$\\{max\_sorts}\S\\{max\_scraps}$\C{ditto}\par
\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{cur\_depth}: \37\\{eight\_bits};\C{depth of current buckets}\6
\4\\{cur\_byte}: \37$0\to\\{max\_bytes}$;\C{index into \\{byte\_mem}}\6
\4\\{cur\_bank}: \37$0\to\\{ww}-1$;\C{row of \\{byte\_mem}}\6
\4\\{cur\_val}: \37\\{sixteen\_bits};\C{current cross reference number}\6
\&{stat} \37\\{max\_sort\_ptr}: \37$0\to\\{max\_sorts}$;\ \&{tats}\C{largest
value of \\{sort\_ptr}}\par
\fi

\M245. \P$\X10:Set initial values\X\mathrel{+}\S$\6
\&{stat} \37$\\{max\_sort\_ptr}\K0$;\ \&{tats}\par
\fi

\M246. The desired alphabetic order is specified by the \\{collate} array;
namely,
$\\{collate}[0]<\\{collate}[1]<\hbox{$\cdots$}<\\{collate}[229]$.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\4\\{collate}: \37\&{array} $[0\to229]$ \1\&{of}\5
\\{ASCII\_code};\C{collation order}\2\par
\fi

\M247. \P$\X16:Local variables for initialization\X\mathrel{+}\S$\6
\4\|c: \37\\{ASCII\_code};\C{used to initialize \\{collate}}\par
\fi

\M248. We use the order $\hbox{null}<\.\ <\hbox{other characters}<\.\_<
\.A=\.a<\cdots<\.Z=\.z<\.0<\cdots<\.9.$

\Y\P$\4\X10:Set initial values\X\mathrel{+}\S$\6
$\\{collate}[0]\K0$;\5
$\\{collate}[1]\K\.{"\ "}$;\6
\&{for} $\|c\K1\mathrel{\&{to}}\.{"\ "}-1$ \1\&{do}\5
$\\{collate}[\|c+1]\K\|c$;\2\6
\&{for} $\|c\K\.{"\ "}+1\mathrel{\&{to}}\.{"0"}-1$ \1\&{do}\5
$\\{collate}[\|c]\K\|c$;\2\6
\&{for} $\|c\K\.{"9"}+1\mathrel{\&{to}}\.{"A"}-1$ \1\&{do}\5
$\\{collate}[\|c-10]\K\|c$;\2\6
\&{for} $\|c\K\.{"Z"}+1\mathrel{\&{to}}\.{"\_"}-1$ \1\&{do}\5
$\\{collate}[\|c-36]\K\|c$;\2\6
$\\{collate}[\.{"\_"}-36]\K\.{"\_"}+1$;\6
\&{for} $\|c\K\.{"z"}+1\mathrel{\&{to}}255$ \1\&{do}\5
$\\{collate}[\|c-63]\K\|c$;\2\6
$\\{collate}[193]\K\.{"\_"}$;\6
\&{for} $\|c\K\.{"a"}\mathrel{\&{to}}\.{"z"}$ \1\&{do}\5
$\\{collate}[\|c-\.{"a"}+194]\K\|c$;\2\6
\&{for} $\|c\K\.{"0"}\mathrel{\&{to}}\.{"9"}$ \1\&{do}\5
$\\{collate}[\|c-\.{"0"}+220]\K\|c$;\2\par
\fi

\M249. Procedure \\{unbucket} goes through the buckets and adds nonempty lists
to the stack, using the collating sequence specified in the \\{collate} array.
The parameter to \\{unbucket} tells the current depth in the buckets.
Any two sequences that agree in their first 255 character positions are
regarded as identical.

\Y\P\D \37$\\{infinity}=255$\C{$\infty$ (approximately)}\par
\Y\P\4\&{procedure}\1\  \37$\\{unbucket}(\|d:\\{eight\_bits})$;\C{empties
buckets having depth \|d}\6
\4\&{var} \37\|c: \37\\{ASCII\_code};\C{index into \\{bucket}}\2\6
\&{begin} \37\&{for} $\|c\K229\mathrel{\&{downto}}0$ \1\&{do}\6
\&{if} $\\{bucket}[\\{collate}[\|c]]>0$ \1\&{then}\6
\&{begin} \37\&{if} $\\{sort\_ptr}>\\{max\_sorts}$ \1\&{then}\5
$\\{overflow}(\.{\'sorting\'})$;\2\6
$\\{incr}(\\{sort\_ptr})$;\6
\&{stat} \37\&{if} $\\{sort\_ptr}>\\{max\_sort\_ptr}$ \1\&{then}\5
$\\{max\_sort\_ptr}\K\\{sort\_ptr}$;\2\ \&{tats}\6
\&{if} $\|c=0$ \1\&{then}\5
$\\{depth}[\\{sort\_ptr}]\K\\{infinity}$\6
\4\&{else} $\\{depth}[\\{sort\_ptr}]\K\|d$;\2\6
$\\{head}[\\{sort\_ptr}]\K\\{bucket}[\\{collate}[\|c]]$;\5
$\\{bucket}[\\{collate}[\|c]]\K0$;\6
\&{end};\2\2\6
\&{end};\par
\fi

\M250. \P$\X250:Sort and output the index\X\S$\6
$\\{sort\_ptr}\K0$;\5
$\\{unbucket}(1)$;\6
\&{while} $\\{sort\_ptr}>0$ \1\&{do}\6
\&{begin} \37$\\{cur\_depth}\K\\{cat}[\\{sort\_ptr}]$;\6
\&{if} $(\\{blink}[\\{head}[\\{sort\_ptr}]]=0)\V(\\{cur\_depth}=\\{infinity})$ %
\1\&{then}\5
\X252:Output index entries for the list at \\{sort\_ptr}\X\6
\4\&{else} \X251:Split the list at \\{sort\_ptr} into further lists\X;\2\6
\&{end}\2\par
\U239.\fi

\M251. \P$\X251:Split the list at \\{sort\_ptr} into further lists\X\S$\6
\&{begin} \37$\\{next\_name}\K\\{head}[\\{sort\_ptr}]$;\6
\1\&{repeat} \37$\\{cur\_name}\K\\{next\_name}$;\5
$\\{next\_name}\K\\{blink}[\\{cur\_name}]$;\5
$\\{cur\_byte}\K\\{byte\_start}[\\{cur\_name}]+\\{cur\_depth}$;\5
$\\{cur\_bank}\K\\{cur\_name}\mathbin{\&{mod}}\\{ww}$;\6
\&{if} $\\{cur\_byte}=\\{byte\_start}[\\{cur\_name}+\\{ww}]$ \1\&{then}\5
$\|c\K0$\C{we hit the end of the name}\6
\4\&{else} \&{begin} \37$\|c\K\\{byte\_mem}[\\{cur\_bank},\39\\{cur\_byte}]$;\6
\&{if} $(\|c\L\.{"Z"})\W(\|c\G\.{"A"})$ \1\&{then}\5
$\|c\K\|c+\O{40}$;\2\6
\&{end};\2\6
$\\{blink}[\\{cur\_name}]\K\\{bucket}[\|c]$;\5
$\\{bucket}[\|c]\K\\{cur\_name}$;\6
\4\&{until}\5
$\\{next\_name}=0$;\2\6
$\\{decr}(\\{sort\_ptr})$;\5
$\\{unbucket}(\\{cur\_depth}+1)$;\6
\&{end}\par
\U250.\fi

\M252. \P$\X252:Output index entries for the list at \\{sort\_ptr}\X\S$\6
\&{begin} \37$\\{cur\_name}\K\\{head}[\\{sort\_ptr}]$;\6
\&{debug} \37\&{if} $\\{trouble\_shooting}$ \1\&{then}\5
\\{debug\_help};\2\ \&{gubed}\6
\1\&{repeat} \37$\\{out2}(\.{"\\"})(\.{":"})$;\5
\X253:Output the name at \\{cur\_name}\X;\6
\X254:Output the cross-references at \\{cur\_name}\X;\6
$\\{cur\_name}\K\\{blink}[\\{cur\_name}]$;\6
\4\&{until}\5
$\\{cur\_name}=0$;\2\6
$\\{decr}(\\{sort\_ptr})$;\6
\&{end}\par
\U250.\fi

\M253. \P$\X253:Output the name at \\{cur\_name}\X\S$\6
\&{case} $\\{ilk}[\\{cur\_name}]$ \1\&{of}\6
\4\\{normal}: \37\&{if} $\\{length}(\\{cur\_name})=1$ \1\&{then}\5
$\\{out2}(\.{"\\"})(\.{"|"})$\ \&{else} $\\{out2}(\.{"\\"})(\.{"\\"})$;\2\6
\4\\{roman}: \37\\{do\_nothing};\6
\4\\{wildcard}: \37$\\{out2}(\.{"\\"})(\.{"9"})$;\6
\4\\{typewriter}: \37$\\{out2}(\.{"\\"})(\.{"."})$;\6
\4\&{othercases} \37$\\{out2}(\.{"\\"})(\.{"\&"})$\2\6
\&{endcases};\6
$\\{out\_name}(\\{cur\_name})$\par
\U252.\fi

\M254. Section numbers that are to be underlined are enclosed in
`\.{\\[}$\,\ldots\,$\.]'.

\Y\P$\4\X254:Output the cross-references at \\{cur\_name}\X\S$\6
\X255:Invert the cross-reference list at \\{cur\_name}, making \\{cur\_xref}
the head\X;\6
\1\&{repeat} \37$\\{out2}(\.{","})(\.{"\ "})$;\5
$\\{cur\_val}\K\\{num}(\\{cur\_xref})$;\6
\&{if} $\\{cur\_val}<\\{def\_flag}$ \1\&{then}\5
$\\{out\_mod}(\\{cur\_val})$\6
\4\&{else} \&{begin} \37$\\{out2}(\.{"\\"})(\.{"["})$;\5
$\\{out\_mod}(\\{cur\_val}-\\{def\_flag})$;\5
$\\{out}(\.{"]"})$;\6
\&{end};\2\6
$\\{cur\_xref}\K\\{xlink}(\\{cur\_xref})$;\6
\4\&{until}\5
$\\{cur\_xref}=0$;\2\6
$\\{out}(\.{"."})$;\5
\\{finish\_line}\par
\U252.\fi

\M255. List inversion is best thought of as popping elements off one stack and
pushing them onto another. In this case \\{cur\_xref} will be the head of
the stack that we push things onto.

\Y\P$\4\X255:Invert the cross-reference list at \\{cur\_name}, making \\{cur%
\_xref} the head\X\S$\6
$\\{this\_xref}\K\\{xref}[\\{cur\_name}]$;\5
$\\{cur\_xref}\K0$;\6
\1\&{repeat} \37$\\{next\_xref}\K\\{xlink}(\\{this\_xref})$;\5
$\\{xlink}(\\{this\_xref})\K\\{cur\_xref}$;\5
$\\{cur\_xref}\K\\{this\_xref}$;\5
$\\{this\_xref}\K\\{next\_xref}$;\6
\4\&{until}\5
$\\{this\_xref}=0$\2\par
\U254.\fi

\M256. The following recursive procedure walks through the tree of module names
and
prints them.

\Y\P\4\&{procedure}\1\  \37$\\{mod\_print}(\|p:\\{name\_pointer})$;\C{print all
module names in subtree \|p}\2\6
\&{begin} \37\&{if} $\|p>0$ \1\&{then}\6
\&{begin} \37$\\{mod\_print}(\\{llink}[\|p])$;\6
$\\{out2}(\.{"\\"})(\.{":"})$;\6
$\\{tok\_ptr}\K1$;\5
$\\{text\_ptr}\K1$;\5
$\\{scrap\_ptr}\K0$;\5
\\{init\_stack};\5
$\\{app}(\|p+\\{mod\_flag})$;\5
\\{make\_output};\5
$\\{footnote}(0)$;\C{\\{cur\_xref} was set by \\{make\_output}}\6
\\{finish\_line};\6
$\\{mod\_print}(\\{rlink}[\|p])$;\6
\&{end};\2\6
\&{end};\par
\fi

\M257. \P$\X257:Output all the module names\X\S$\ $\\{mod\_print}(\\{root})$\par
\U239.\fi

\N258.  Debugging.
The \PASCAL\ debugger with which \.{WEAVE} was developed allows breakpoints
to be set, and variables can be read and changed, but procedures cannot be
executed. Therefore a `\\{debug\_help}' procedure has been inserted in the main
loops of each phase of the program; when \\{ddt} and \\{dd} are set to
appropriate
values, symbolic printouts of various tables will appear.

The idea is to set a breakpoint inside the \\{debug\_help} routine, at the
place of `\ignorespaces \\{breakpoint}: \unskip' below.  Then when
\\{debug\_help} is to be activated, set \\{trouble\_shooting} equal to %
\\{true}.
The \\{debug\_help} routine will prompt you for values of \\{ddt} and \\{dd},
discontinuing this when $\\{ddt}\L0$; thus you type $2n+1$ integers, ending
with zero or a negative number. Then control either passes to the
breakpoint, allowing you to look at and/or change variables (if you typed
zero), or to exit the routine (if you typed a negative value).

Another global variable, \\{debug\_cycle}, can be used to skip silently
past calls on \\{debug\_help}. If you set $\\{debug\_cycle}>1$, the program
stops
only every \\{debug\_cycle} times \\{debug\_help} is called; however,
any error stop will set \\{debug\_cycle} to zero.

\Y\P$\4\X9:Globals in the outer block\X\mathrel{+}\S$\6
\&{debug} \37\\{trouble\_shooting}: \37\\{boolean};\C{is \\{debug\_help}
wanted?}\6
\4\\{ddt}: \37\\{integer};\C{operation code for the \\{debug\_help} routine}\6
\4\\{dd}: \37\\{integer};\C{operand in procedures performed by \\{debug\_help}}%
\6
\4\\{debug\_cycle}: \37\\{integer};\C{threshold for \\{debug\_help} stopping}\6
\4\\{debug\_skipped}: \37\\{integer};\C{we have skipped this many \\{debug%
\_help} calls}\6
\4\\{term\_in}: \37\\{text\_file};\C{the user's terminal as an input file}\6
\&{gubed}\par
\fi

\M259. The debugging routine needs to read from the user's terminal.
\Y\P$\4\X10:Set initial values\X\mathrel{+}\S$\6
\&{debug} \37$\\{trouble\_shooting}\K\\{true}$;\5
$\\{debug\_cycle}\K1$;\5
$\\{debug\_skipped}\K0$;\5
$\\{tracing}\K0$;\6
$\\{trouble\_shooting}\K\\{false}$;\5
$\\{debug\_cycle}\K99999$;\C{use these when it almost works}\6
$\\{reset}(\\{term\_in},\39\.{\'TTY:\'},\39\.{\'/I\'})$;\C{open \\{term\_in} as
the terminal, don't do a \\{get}}\6
\&{gubed}\par
\fi

\M260. \P\D \37$\\{breakpoint}=888$\C{place where a breakpoint is desirable}\par
\Y\P\&{debug} \37\&{procedure}\1\  \37\\{debug\_help};\C{routine to display
various things}\6
\4\&{label} \37$\\{breakpoint},\39\\{exit}$;\6
\4\&{var} \37\|k: \37\\{integer};\C{index into various arrays}\2\6
\&{begin} \37$\\{incr}(\\{debug\_skipped})$;\6
\&{if} $\\{debug\_skipped}<\\{debug\_cycle}$ \1\&{then}\5
\&{return};\2\6
$\\{debug\_skipped}\K0$;\6
\~ \1\&{loop}\ \&{begin} \37$\\{print\_nl}(\.{\'\#\'})$;\5
\\{update\_terminal};\C{prompt}\6
$\\{read}(\\{term\_in},\39\\{ddt})$;\C{read a debug-command code}\6
\&{if} $\\{ddt}<0$ \1\&{then}\5
\&{return}\6
\4\&{else} \&{if} $\\{ddt}=0$ \1\&{then}\6
\&{begin} \37\&{goto} \37\\{breakpoint};\5
\]\C{go to every label at least once}\6
\4\\{breakpoint}: \37$\\{ddt}\K0$;\5
\]\6
\&{end}\6
\4\&{else} \&{begin} \37$\\{read}(\\{term\_in},\39\\{dd})$;\6
\&{case} $\\{ddt}$ \1\&{of}\6
\41: \37$\\{print\_id}(\\{dd})$;\6
\42: \37$\\{print\_text}(\\{dd})$;\6
\43: \37\&{for} $\|k\K1\mathrel{\&{to}}\\{dd}$ \1\&{do}\5
$\\{print}(\\{xchr}[\\{buffer}[\|k]])$;\2\6
\44: \37\&{for} $\|k\K1\mathrel{\&{to}}\\{dd}$ \1\&{do}\5
$\\{print}(\\{xchr}[\\{mod\_text}[\|k]])$;\2\6
\45: \37\&{for} $\|k\K1\mathrel{\&{to}}\\{out\_ptr}$ \1\&{do}\5
$\\{print}(\\{xchr}[\\{out\_buf}[\|k]])$;\2\6
\46: \37\&{for} $\|k\K1\mathrel{\&{to}}\\{dd}$ \1\&{do}\6
\&{begin} \37$\\{print\_cat}(\\{cat}[\|k])$;\5
$\\{print}(\.{\'\ \'})$;\6
\&{end};\2\6
\4\&{othercases} \37$\\{print}(\.{\'?\'})$\2\6
\&{endcases};\6
\&{end};\2\2\6
\&{end};\2\6
\4\\{exit}: \37\&{end};\6
\&{gubed}\par
\fi

\N261.  The main program.
Let's put it all together now: \.{WEAVE} starts and ends here.

The main procedure has been split into three sub-procedures in order to
keep certain \PASCAL\ compilers from overflowing their capacity.

\Y\P\4\&{procedure}\1\  \37\\{Phase\_I};\2\6
\&{begin} \37\X109:Phase I: Read all the user's text and store the cross
references\X;\6
\&{end};\7
\4\&{procedure}\1\  \37\\{Phase\_II};\2\6
\&{begin} \37\X218:Phase II: Read all the text again and translate it to \TeX\
form\X;\6
\&{end};\7
\&{begin} \37\\{initialize};\C{beginning of the main program}\6
$\\{print\_ln}(\\{banner})$;\C{print a ``banner line''}\6
\X64:Store all the reserved words\X;\6
\\{Phase\_I};\5
\\{Phase\_II};\6
\X239:Phase III: Output the cross-reference index\X;\6
\X85:Check that all changes have been read\X;\6
\4\\{end\_of\_WEAVE}: \37\&{stat} \37\X262:Print statistics about memory usage%
\X;\ \&{tats}\6
\hbox{\4\4}\C{here files should be closed if the operating system requires it}\6
\X263:Print the job \\{history}\X;\6
\&{end}.\par
\fi

\M262. \P$\X262:Print statistics about memory usage\X\S$\6
$\\{print\_nl}(\.{\'Memory\ usage\ statistics:\ \'},\39\\{name\_ptr}:1,\39\.{\'%
\ names,\ \'},\39\\{xref\_ptr}:1,\39\.{\'\ cross\ references,\ \'},\39\\{byte%
\_ptr}[0]:1)$;\6
\&{for} $\\{cur\_bank}\K1\mathrel{\&{to}}\\{ww}-1$ \1\&{do}\5
$\\{print}(\.{\'+\'},\39\\{byte\_ptr}[\\{cur\_bank}]:1)$;\2\6
$\\{print}(\.{\'\ bytes;\'})$;\5
$\\{print\_nl}(\.{\'parsing\ required\ \'},\39\\{max\_scr\_ptr}:1,\39\.{\'\
scraps,\ \'},\39\\{max\_txt\_ptr}:1,\39\.{\'\ texts,\ \'},\39\\{max\_tok%
\_ptr}:1,\39\.{\'\ tokens,\ \'},\39\\{max\_stack\_ptr}:1,\39\.{\'\ levels;%
\'})$;\5
$\\{print\_nl}(\.{\'sorting\ required\ \'},\39\\{max\_sort\_ptr}:1,\39\.{\'\
levels.\'})$\par
\U261.\fi

\M263. Some implementations may wish to pass the \\{history} value to the
operating system so that it can be used to govern whether or not other
programs are started. Here we simply report the history to the user.

\Y\P$\4\X263:Print the job \\{history}\X\S$\6
\&{case} $\\{history}$ \1\&{of}\6
\4\\{spotless}: \37$\\{print\_nl}(\.{\'(No\ errors\ were\ found.)\'})$;\6
\4\\{harmless\_message}: \37$\\{print\_nl}(\.{\'(Did\ you\ see\ the\ warning\
message\ above?)\'})$;\6
\4\\{error\_message}: \37$\\{print\_nl}(\.{\'(Pardon\ me,\ but\ I\ think\ I\
spotted\ something\ wrong.)\'})$;\6
\4\\{fatal\_message}: \37$\\{print\_nl}(\.{\'(That\ was\ a\ fatal\ error,\ my\
friend.)\'})$;\2\6
\&{end}\C{there are no other cases}\par
\U261.\fi

\N264.  System-dependent changes.
This module should be replaced, if necessary, by changes to the program
that are necessary to make \.{WEAVE} work at a particular installation.
It is usually best to design your change file so that all changes to
previous modules preserve the module numbering; then everybody's version
will be consistent with the printed program. More extensive changes,
which introduce new modules, can be inserted here; then only the index
itself will get a new module number.

\fi

\N265.  Index.
If you have read and understood the code for Phase III above, you know what
is in this index and how it got here. All modules in which an identifier is
used are listed with that identifier, except that reserved words are
indexed only when they appear in format definitions, and the appearances
of identifiers in module names are not indexed. Underlined entries
correspond to where the identifier was declared. Error messages, control
sequences put into the output, and a few
other things like ``recursion'' are indexed here too.
\fi


\inx
\:\.{\\)}, 186.
\:\.{\\*}, 130.
\:\.{\\,}, 162, 163, 186.
\:\.{\\.}, 189, 253.
\:\.{\\:}, 252, 256.
\:\.{\\=}, 189.
\:\.{\\[}, 254.
\:\.{\\\ }, 186, 189, 193.
\:\.{\\\#}, 186, 189.
\:\.{\\\$}, 186, 189.
\:\.{\\\%}, 186, 189.
\:\.{\\\&}, 189, 209, 253.
\:\.{\\\'}, 189.
\:\.{\\\\}, 189, 209, 253.
\:\.{\\\^}, 186, 189.
\:\.{\\\`}, 189.
\:\.{\\\{}, 189.
\:\.{\\\}}, 189.
\:\.{\\\~}, 189, 193.
\:\.{\\]}, 186.
\:\.{\\|}, 209, 253.
\:\.{\\\_}, 131, 189.
\:\.{\\A}, 236.
\:\.{\\As}, 237.
\:\.{\\ast}, 186.
\:\.{\\B}, 186.
\:\.{\\C}, 198.
\:\.{\\con}, 239.
\:\.{\\D}, 227.
\:\.{\\E}, 186.
\:\.{\\ET}, 237.
\:\.{\\ETs}, 237.
\:\.{\\F}, 228.
\:\.{\\fi}, 238.
\:\.{\\fin}, 239.
\:\.{\\G}, 188.
\:\.{\\H}, 196, 224.
\:\.{\\I}, 188.
\:\.{\\in}, 186.
\:\.{\\input webmac}, 124.
\:\.{\\inx}, 239.
\:\.{\\J}, 186.
\:\.{\\K}, 188.
\:\.{\\L}, 188.
\:\.{\\M}, 221.
\:\.{\\N}, 221.
\:\.{\\O}, 196, 223.
\:\.{\\P}, 212, 226.
\:\.{\\R}, 188.
\:\.{\\S}, 188, 228, 231.
\:\.{\\T}, 186.
\:\.{\\to}, 186.
\:\.{\\U}, 236.
\:\.{\\Us}, 237.
\:\.{\\V}, 188.
\:\.{\\W}, 188.
\:\.{\\X}, 213.
\:\.{\\Y}, 212, 219, 226, 231.
\:\.{\\1}, 211, 212.
\:\.{\\2}, 211, 212.
\:\.{\\3}, 211, 212.
\:\.{\\4}, 211, 212.
\:\.{\\5}, 211, 212.
\:\.{\\6}, 211, 212, 226.
\:\.{\\7}, 211, 212, 226.
\:\.{\\9}, 253.
\:\.{\AT!1}, 88, 177.
\:\.{\AT!2}, 88, 177.
\:\|{a}, \[130], \[206], \[208].
\:\\{alpha}, \[140], 142, 143, 149, 192, 193.
\:\\{alpha\_cases}, 149, \[150].
\:\.{Ambiguous prefix}, 69.
\:\\{and\_sign}, \[15], 64, 188.
\:\\{app}, \[148], 151, 152, 153, 155, 156, 158, 159, 160, 161, 162, 163, 164,
165, 167, 168, 170, 180, 184, 186, 189, 190, 195, 196, 198, 207, 208, 226, 231,
256.
\:\\{app\_comment}, 183, 184, \[195], 197, 198, 226.
\:\\{app\_hex}, 183, 186, \[196].
\:\\{app\_octal}, 183, 186, \[196].
\:\\{app\_tok}, \[136], 137, 138, 148, 189, 190, 196, 197, 226.
\:\\{append\_xref}, \[50], 51.
\:\\{app1}, \[148], 151, 152, 153, 155, 156, 159, 160, 162, 163, 164, 165, 168,
170, 174, 180, 195.
\:\\{app2}, \[148], 153, 156, 158, 161, 163, 165, 167.
\:\\{app3}, \[148], 158, 164.
\:\\{array\_like}, \[42], 64, 191, 192.
\:{ASCII code}, 11, 86.
\:\\{ASCII\_code}, \[11], 13, 27, 28, 37, 65, 73, 87, 89, 91, 121, 127, 132,
136, 208, 242, 246, 247, 249.
\:\|{b}, \[122], \[208].
\:\\{backup}, \[141], 142, 143, 147, 160, 167, 192, 193, 208, 231.
\:\\{bal}, \[91], 92, \[112], \[136], 137, 138, \[198].
\:\\{banner}, \[1], 261.
\:\&{begin}, 3.
\:\\{begin\_comment}, \[86], 87, 97, 186, 222.
\:\\{begin\_like}, \[42], 64, 193.
\:\\{begin\_Pascal}, \[86], 87, 117, 229, 230.
\:\\{beginning}, \[140], 142, 143, 150, 152, 164, 170, 193.
\:\\{big\_cancel}, \[141], 142, 147, 186, 208, 212.
\:\\{big\_force}, \[141], 142, 147, 186, 208, 212, 226.
\:\\{big\_line\_break}, \[86], 87, 186, 222.
\:\\{blink}, \[242], 243, 250, 251, 252.
\:\\{boolean}, 28, 29, 45, 71, 74, 93, 122, 143, 258.
\:\\{break}, 22.
\:\\{break\_out}, 125, 126, \[127].
\:\\{break\_space}, \[141], 143, 147, 152, 155, 156, 160, 164, 168, 170, 200,
208, 211, 212.
\:\\{breakpoint}, 258, \[260].
\:\\{bucket}, \[242], 243, 249, 251.
\:\\{buf\_size}, \[8], 28, 73, 74, 75, 79, 123.
\:\\{buffer}, \[27], 28, 31, 32, 55, 58, 59, 61, 62, 63, 74, 76, 78, 79, 80,
81, 82, 83, 84, 85, 89, 90, 91, 92, 93, 95, 97, 98, 99, 100, 103, 104, 106,
107, 110, 123, 132, 133, 134, 135, 136, 137, 179, 182, 183, 189, 190, 196, 208,
214, 216, 217, 221, 223, 224, 260.
\:\\{byte\_mem}, 36, \[37], 38, 39, 40, 43, 44, 52, 58, 61, 62, 66, 67, 68, 69,
131, 208, 209, 214, 215, 216, 217, 243, 244, 251.
\:\\{byte\_ptr}, 38, \[39], 41, 62, 67, 262.
\:\\{byte\_start}, 36, \[37], 38, 39, 41, 44, 50, 55, 61, 62, 67, 68, 93, 114,
131, 209, 214, 243, 251.
\:\|{c}, \[66], \[69], \[87], \[89], \[90], \[91], \[95], \[132], \[134], %
\[136], \[140], \[172], \[174], \[242], \[247], \[249].
\:\\{cancel}, \[141], 142, 143, 147, 153, 155, 156, 159, 160, 162, 163, 164,
165, 193, 197, 200, 208, 211, 212.
\:\\{carriage\_return}, \[15], 17, 28.
\:\\{carryover}, \[122].
\:\\{case\_head}, \[140], 143, 149, 153, 154, 162, 163, 165.
\:\\{case\_like}, \[42], 64, 193.
\:\\{casey}, \[140], 142, 143, 149, 153, 165, 193.
\:\\{cat}, \[144], 149, 150, 151, 152, 153, 154, 155, 156, 158, 159, 160, 161,
162, 163, 164, 165, 167, 168, 170, 172, 174, 176, 178, 179, 180, 181, 183, 184,
194, 195, 197, 244, 250, 260.
\:\.{Change file ended...}, 77, 79, 84.
\:\.{Change file entry did not match}, 85.
\:\\{change\_buffer}, \[73], 74, 75, 78, 79, 83, 85.
\:\\{change\_changing}, \[72], 79, 81, 84.
\:\\{change\_exists}, \[45], 109, 110, 239.
\:\\{change\_file}, \[2], \[23], 24, 32, 71, 73, 76, 77, 79, 84.
\:\\{change\_limit}, \[73], 74, 75, 78, 79, 83, 85.
\:\\{change\_pending}, \[71], 79, 84.
\:\\{changed\_module}, \[45], 71, 79, 84, 109, 110, 130, 241.
\:\\{changing}, 32, \[71], 72, 73, 75, 79, 81, 82, 85, 110.
\:\\{char}, 12, 14.
\:\\{char\_like}, \[42], 64, 191.
\:\\{check\_change}, \[79], 83.
\:\\{check\_sum}, \[86], 87, 186, 222.
\:\\{chr}, 12, 13, 17, 18.
\:\\{clause}, \[140], 142, 143, 149, 151, 153, 154, 156, 193.
\:\\{close}, \[140], 142, 143, 152, 153, 160, 162, 163, 164, 167, 186, 193.
\:\\{collate}, \[246], 247, 248, 249.
\:\\{colon}, \[140], 142, 143, 148, 151, 160, 163, 167, 170, 186.
\:\\{comment}, \[142].
\:\\{comment\_scrap}, \[184], 186.
\:\\{compress}, \[97].
\:\\{cond}, \[140], 142, 143, 149, 193.
\:\\{confusion}, \[34].
\:\\{const\_like}, \[42], 64, 191, 192.
\:\\{continue}, \[5], 75, 76.
\:\.{Control codes are forbidden...}, 106.
\:\.{Control text didn't end}, 106.
\:\\{control\_code}, \[87], 88, 90, 93, 100, 135.
\:\\{copy\_comment}, 132, \[136], 198.
\:\\{copy\_limbo}, \[132], 218.
\:\\{copy\_TeX}, 132, \[134], 222.
\:\\{count}, \[69].
\:\\{cur\_bank}, \[244], 251, 262.
\:\\{cur\_byte}, \[244], 251.
\:\\{cur\_depth}, \[244], 250, 251.
\:\\{cur\_end}, 201, \[202], 204, 205, 206.
\:\\{cur\_mod\_name}, \[208], 214, 215, 216.
\:\\{cur\_mode}, 201, \[202], 204, 206, 208, 211, 212.
\:\\{cur\_module}, \[93], 101, 117, 230, 232.
\:\\{cur\_name}, \[63], 206, 209, 213, 214, 242, 243, 251, 252, 253, 255.
\:\\{cur\_state}, \[202], 204, 205.
\:\\{cur\_tok}, 201, \[202], 204, 205, 206.
\:\\{cur\_val}, \[244], 254.
\:\\{cur\_xref}, \[118], 119, 213, 231, 234, 235, 236, 237, 254, 255, 256.
\:\|{d}, \[95], \[127], \[172], \[174], \[249].
\:\\{dd}, \[258], 260.
\:\\{ddt}, \[258], 260.
\:\&{debug}, \[3], \[4], \[30], \[31], \[88], \[95], \[140], \[146], \[148], %
\[177], \[178], \[181], \[182], \[206], \[252], \[258], \[259], \[260].
\:\\{debug\_cycle}, 31, \[258], 259, 260.
\:\\{debug\_help}, \[30], 31, 95, 206, 252, 258, \[260].
\:\\{debug\_skipped}, 31, \[258], 259, 260.
\:\\{decr}, \[6], 28, 92, 98, 103, 122, 127, 130, 135, 137, 138, 205, 251, 252.
\:\\{def\_flag}, \[46], 48, 50, 51, 93, 100, 111, 113, 115, 117, 119, 130, 213,
231, 233, 235, 236, 254.
\:\\{definition}, \[86], 87, 115, 225.
\:\\{depth}, \[244], 249.
\:\\{dig}, \[129], 130.
\:\\{div\_like}, \[42], 64, 191, 192.
\:\\{do\_like}, \[42], 64, 191, 192.
\:\\{do\_nothing}, \[6], 95, 113, 149, 150, 186, 189, 222, 253.
\:\\{done}, \[5], 75, 76, 90, 91, 92, 95, 103, 104, 122, 134, 135, 136, 137,
138, 175, 179, 236, 237.
\:\.{Double \AT! required...}, 133.
\:\.{Double \AT! should be used...}, 189.
\:\\{double\_dot}, \[86], 97, 186.
\:\\{easy\_cases}, 183, 185, \[186].
\:\\{eight\_bits}, \[36], 58, 87, 90, 91, 95, 108, 112, 122, 134, 136, 140,
144, 172, 174, 178, 198, 206, 208, 244, 249.
\:\&{else}, 7.
\:\\{else\_like}, \[42], 64, 193.
\:\\{elsie}, \[140], 142, 143, 149, 156, 193.
\:\\{emit\_space\_if\_needed}, \[219], 225, 230.
\:\&{end}, 3, 7.
\:\\{end\_comment}, \[86], 87, 97, 186, 222.
\:\\{end\_field}, \[201], 202.
\:\\{end\_like}, \[42], 64, 193.
\:\\{end\_of\_WEAVE}, \[2], 33, 261.
\:\\{end\_translation}, \[141], 147, 201, 207, 208, 212.
\:\&{endcases}, \[7].
\:\\{eof}, 28.
\:\\{eoln}, 28.
\:\\{equal}, \[66], 67, 68.
\:\\{equivalence\_sign}, \[15], 97, 116, 188, 228, 231.
\:\\{err\_print}, \[31], 66, 69, 72, 76, 77, 79, 80, 84, 85, 87, 95, 99, 103,
104, 106, 107, 133, 136, 137, 189, 197, 222, 227, 228, 231, 232.
\:\\{error}, 28, \[31], 33.
\:\\{error\_message}, \[9], 263.
\:\\{exit}, \[5], 6, 50, 74, 75, 79, 89, 111, 123, 127, 132, 183, 208, 236, 260.
\:\\{exp}, \[140], 142, 143, 149, 186.
\:\\{exponent}, \[93], 98, 186.
\:\\{extension}, \[66], 68, 69.
\:\.{Extra \}}, 95.
\:\.{Extra \AT!>}, 87.
\:\|{f}, \[28].
\:\\{false}, 28, 29, 72, 73, 74, 79, 81, 84, 94, 96, 109, 122, 123, 127, 218,
238, 259.
\:\\{fatal\_error}, \[33], 34, 35.
\:\\{fatal\_message}, \[9], 263.
\:\\{final\_limit}, \[28].
\:\\{finish\_line}, \[123], 124, 132, 134, 135, 212, 218, 226, 236, 238, 239,
254, 256.
\:\\{finish\_Pascal}, 225, \[226], 230.
\:\\{first\_text\_char}, \[12], 18.
\:\\{first\_xref}, \[234], 235.
\:\\{five\_cases}, 149, \[150].
\:\\{flag}, \[236], 237.
\:\\{flush\_buffer}, \[122], 123, 127, 128, 218, 238.
\:\\{footnote}, 233, \[236], 256.
\:\\{for\_like}, \[42], 64, 191, 192.
\:\\{force}, \[141], 142, 143, 146, 147, 153, 155, 156, 160, 161, 167, 186,
192, 193, 198, 200, 208, 212, 226, 231.
\:\\{force\_line}, \[86], 87, 186.
\:\\{form\_feed}, \[15], 28.
\:\\{format}, \[86], 87, 111, 112, 113, 115, 183, 198, 222, 225.
\:\\{forward}, 30, 207.
\:\\{found}, \[5], 58, 60, 61, 66, 95, 96, 122, 148, 149, 150, 151, 175, 179,
208, 216.
\:\\{freeze\_text}, \[171], 172, 180, 184, 195, 198, 208.
\:\\{get}, 28, 259.
\:\\{get\_line}, 71, \[82], 89, 90, 91, 95, 103, 123, 132, 134, 136.
\:\\{get\_next}, 93, \[95], 108, 111, 113, 115, 116, 117, 183, 222, 227, 228,
230, 231, 232.
\:\\{get\_output}, \[206], 207, 208, 211, 212.
\:\\{goto\_like}, \[42], 64, 191, 192.
\:\\{greater}, \[66], 68, 69.
\:\\{greater\_or\_equal}, \[15], 97, 188.
\:\&{gubed}, \[3].
\:\|{h}, \[56], \[58], \[242].
\:\\{harmless\_message}, \[9], 263.
\:\\{hash}, 38, \[55], 57, 60, 242, 243.
\:\\{hash\_size}, \[8], 55, 56, 57, 58, 59, 242, 243.
\:\\{head}, \[244], 249, 250, 251, 252.
\:\\{hex}, \[86], 87, 100, 186, 222.
\:\\{hi\_ptr}, \[144], 176, 178, 179.
\:\\{history}, \[9], 10, 263.
\:\.{Hmm... n of the preceding...}, 80.
\:\|{i}, \[16], \[58], \[172], \[174], \[179].
\:\\{id\_first}, \[55], 58, 59, 61, 62, 63, 93, 98, 99, 106, 107, 189, 190.
\:\\{id\_flag}, \[146], 192, 206, 227, 228.
\:\\{id\_loc}, \[55], 58, 59, 61, 62, 64, 93, 98, 99, 106, 107, 189, 190.
\:\\{id\_lookup}, 55, \[58], 63, 93, 111, 113, 116, 191, 227, 228.
\:\\{identifier}, \[93], 98, 111, 113, 116, 185, 206, 208, 209, 227, 228.
\:\\{id2}, \[63], 64.
\:\\{id3}, \[63], 64.
\:\\{id4}, \[63], 64.
\:\\{id5}, \[63], 64.
\:\\{id6}, \[63], 64.
\:\\{id7}, \[63], 64.
\:\\{id8}, \[63], 64.
\:\\{id9}, \[63], 64.
\:\\{if\_like}, \[42], 64, 193.
\:\\{if\_module\_start\_then\_make\_change\_pending}, \[79], 84.
\:\\{ignore}, \[86], 87, 88, 186.
\:\\{ii}, \[71], 85.
\:\\{ilk}, 36, \[37], 42, 43, 55, 58, 60, 62, 111, 116, 191, 192, 253.
\:\.{Illegal control code...}, 215.
\:\.{Illegal use of \AT!...}, 137.
\:\.{Improper format definition}, 228.
\:\.{Improper macro definition}, 227.
\:\\{in\_like}, \[42].
\:\.{Incompatible section names}, 66.
\:\\{incr}, \[6], 28, 50, 59, 61, 62, 67, 68, 69, 76, 77, 79, 83, 84, 89, 90,
91, 92, 95, 97, 98, 99, 100, 103, 104, 106, 107, 110, 122, 125, 130, 133, 135,
136, 137, 148, 149, 150, 171, 176, 184, 189, 196, 204, 206, 214, 215, 216, 217,
220, 223, 224, 241, 249, 260.
\:\\{indent}, \[141], 142, 143, 147, 151, 160, 165, 193, 208.
\:\\{infinity}, \[249], 250.
\:\\{init\_stack}, \[202], 222, 225, 230, 256.
\:\\{initialize}, \[2], 261.
\:\\{inner}, 200, \[201], 206, 212.
\:\\{inner\_tok\_flag}, \[146], 198, 206, 207.
\:\.{Input ended in mid-comment}, 136.
\:\.{Input ended in section name}, 103.
\:\.{Input line too long}, 28.
\:\\{input\_has\_ended}, \[71], 79, 81, 83, 89, 90, 91, 95, 103, 109, 132, 134,
136, 218.
\:\\{input\_ln}, \[28], 76, 77, 79, 83, 84.
\:\\{integer}, 14, 71, 79, 121, 130, 172, 174, 219, 258, 260.
\:\\{intro}, \[140], 142, 143, 148, 150, 157, 160, 162, 163, 165, 167, 170,
192, 193, 227, 228.
\:\|{j}, \[66], \[69], \[95], \[122], \[146], \[172], \[174], \[179], \[183], %
\[208].
\:\\{join}, \[86], 87, 186, 222.
\:\\{jump\_out}, 2, \[33].
\:\|{k}, \[31], \[44], \[58], \[66], \[69], \[74], \[75], \[79], \[95], \[122],
\[123], \[127], \[130], \[131], \[172], \[174], \[178], \[179], \[208], \[260].
\:\\{k\_limit}, \[208], 214, 216.
\:\\{k\_module}, \[240], 241.
\:\|{l}, \[31], \[58], \[66], \[69].
\:\\{last\_text\_char}, \[12], 18.
\:\\{lbrace}, \[146], 147.
\:\\{left\_arrow}, \[15], 97, 188.
\:\\{length}, \[38], 60, 209, 253.
\:\\{less}, \[66], 67, 68, 69.
\:\\{less\_or\_equal}, \[15], 97, 188.
\:\\{lhs}, \[114], 116.
\:\\{limit}, 28, 32, \[71], 74, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 89, 90,
91, 95, 97, 99, 103, 106, 107, 123, 132, 133, 134, 135, 136, 208, 214, 216, 223.
\:\\{line}, 32, \[71], 72, 76, 77, 79, 81, 83, 84, 85, 182.
\:\.{Line had to be broken}, 128.
\:\\{line\_break}, \[86], 87, 186, 222.
\:\\{line\_feed}, \[15], 28.
\:\\{line\_length}, \[8], 121, 122, 125, 127.
\:\\{lines\_dont\_match}, \[74], 79.
\:\\{link}, 36, \[37], 38, 43, 60, 243.
\:\\{llink}, \[43], 66, 67, 69, 119, 256.
\:\\{lo\_ptr}, \[144], 172, 175, 176, 178, 179, 180, 181.
\:\\{loc}, 28, 32, \[71], 76, 79, 80, 81, 82, 84, 85, 89, 90, 91, 92, 95, 97,
98, 99, 100, 103, 104, 106, 107, 110, 113, 132, 133, 134, 135, 136, 137, 182,
196, 208, 214, 221, 222, 223, 224.
\:\\{long\_buf\_size}, \[8], 27, 28, 31, 55, 58, 71, 179, 183, 208, 216, 217.
\:\\{longest\_name}, \[8], 65, 66, 69, 95, 103, 105.
\:\&{loop}, \[6].
\:\\{loop\_like}, \[42], 64, 193.
\:\|{m}, \[50], \[130].
\:\\{make\_output}, \[207], \[208], 213, 226, 256.
\:\\{mark\_error}, \[9], 31, 215, 216.
\:\\{mark\_fatal}, \[9], 33.
\:\\{mark\_harmless}, \[9], 105, 119, 128, 181, 182.
\:\\{math}, 139, \[140], 142, 143, 148, 150, 151, 158, 160, 162, 163, 167, 170,
179, 180, 186, 188, 192, 227, 228, 231.
\:\\{math\_bin}, \[141], 142, 147, 192, 208, 210.
\:\\{math\_break}, \[86], 87, 186, 222.
\:\\{math\_op}, \[141], 143, 147, 162, 163, 208.
\:\\{math\_rel}, \[141], 142, 146, 147, 192, 208, 210, 231.
\:\\{max\_bytes}, \[8], 37, 39, 44, 58, 62, 66, 67, 69, 131, 208, 244.
\:\\{max\_modules}, \[8], 45, 46, 110, 240.
\:\\{max\_names}, \[8], 37, 38, 62, 67, 69, 242.
\:\\{max\_refs}, \[8], 47, 50.
\:\\{max\_scr\_ptr}, \[144], 145, 187, 197, 199, 226, 262.
\:\\{max\_scraps}, \[8], 144, 172, 174, 178, 179, 187, 197, 199, 244.
\:\\{max\_sort\_ptr}, \[244], 245, 249, 262.
\:\\{max\_sorts}, \[244], 249.
\:\\{max\_stack\_ptr}, \[202], 203, 204, 262.
\:\\{max\_texts}, \[8], 52, 175, 179, 187, 199.
\:\\{max\_tok\_ptr}, \[53], 54, 175, 187, 199, 207, 226, 262.
\:\\{max\_toks}, \[8], 53, 136, 146, 175, 179, 180, 187, 189, 198, 199.
\:\\{max\_txt\_ptr}, \[53], 54, 175, 187, 199, 207, 226, 262.
\:\\{mid\_xref}, \[234], 235.
\:\.{Missing "|"...}, 197.
\:\\{mod\_check}, \[119], 120.
\:\\{mod\_flag}, \[146], 206, 231, 232, 256.
\:\\{mod\_lookup}, 65, \[66], 101, 102.
\:\\{mod\_name}, \[206], 208.
\:\\{mod\_print}, \[256], 257.
\:\\{mod\_scrap}, \[140], 142, 143, 149, 167, 231, 232.
\:\\{mod\_text}, \[65], 66, 67, 68, 69, 95, 101, 102, 103, 104, 105, 260.
\:\\{mod\_xref\_switch}, 46, \[48], 49, 51, 117.
\:\\{mode}, \[201], 208.
\:\\{mode\_field}, \[201], 202.
\:\\{module\_count}, \[45], 50, 51, 71, 79, 84, 109, 110, 181, 218, 220, 221,
231, 241.
\:\\{module\_name}, \[86], 87, 93, 100, 113, 117, 222, 230, 232.
\:\|{n}, \[50], \[79], \[178].
\:\.{Name does not match}, 69.
\:\\{name\_pointer}, \[38], 39, 44, 50, 51, 58, 63, 66, 69, 93, 111, 114, 119,
131, 144, 183, 192, 208, 229, 242, 256.
\:\\{name\_ptr}, 38, \[39], 41, 44, 58, 60, 62, 67, 262.
\:\.{Never defined: <section name>}, 119.
\:\.{Never used: <section name>}, 119.
\:\\{new\_line}, \[20], 31, 32, 33, 128.
\:\\{new\_mod\_xref}, \[51], 117.
\:\\{new\_module}, \[86], 87, 90, 95, 134.
\:\\{new\_xref}, \[50], 111, 113, 116.
\:\\{next\_control}, \[108], 111, 112, 113, 115, 116, 117, 183, 185, 186, 189,
191, 197, 198, 207, 222, 225, 227, 228, 229, 230, 231, 232.
\:\\{next\_name}, \[242], 243, 251.
\:\\{next\_xref}, \[234], 235, 255.
\:\&{nil}, 6.
\:\\{nil\_like}, \[42], 64, 191, 192.
\:\\{no\_line\_break}, \[86], 87, 186, 222.
\:\\{no\_underline}, \[86], 87, 100, 113.
\:\\{normal}, \[42], 58, 60, 111, 116, 191, 192, 227, 228, 253.
\:\\{not\_equal}, \[15], 97, 188.
\:\\{not\_found}, \[5].
\:\\{not\_sign}, \[15], 64, 188.
\:\\{num}, \[46], 49, 50, 51, 119, 213, 231, 235, 236, 237, 254.
\:\\{num\_field}, 46, \[48].
\:\\{octal}, \[86], 87, 186, 222.
\:\\{omega}, \[140], 142, 143, 151, 192, 193, 195.
\:\\{oot}, \[125].
\:\\{oot1}, \[125].
\:\\{oot2}, \[125].
\:\\{oot3}, \[125].
\:\\{oot4}, \[125].
\:\\{oot5}, \[125].
\:\\{open}, 139, \[140], 142, \[143], 150, 186.
\:\\{open\_input}, \[24], 81.
\:\\{opt}, 139, \[141], 142, 143, 147, 159, 163, 186, 208, 211.
\:\\{or\_sign}, \[15], 64, 188.
\:\\{ord}, 13.
\:\\{other\_line}, \[71], 72, 81, 85.
\:\&{othercases}, \[7].
\:\\{others}, 7.
\:\\{out}, \[125], 130, 131, 133, 135, 208, 209, 210, 211, 212, 213, 214, 221,
222, 223, 224, 236, 237, 241, 254.
\:\\{out\_buf}, \[121], 122, 124, 125, 126, 127, 128, 212, 226, 231, 260.
\:\\{out\_line}, \[121], 122, 124, 128, 219.
\:\\{out\_mod}, \[130], 213, 221, 237, 241, 254.
\:\\{out\_name}, \[131], 209, 253.
\:\\{out\_ptr}, \[121], 122, 123, 124, 125, 127, 128, 135, 212, 219, 226, 231,
260.
\:\\{outdent}, \[141], 143, 147, 153, 155, 156, 160, 162, 163, 164, 208.
\:\\{outer}, 200, \[201], 202, 211, 212.
\:\\{outer\_parse}, \[198], 225, 230.
\:\\{outer\_xref}, \[112], 115, 117, 198.
\:\\{output\_Pascal}, \[207], 214, 222.
\:\\{output\_state}, \[201], 202.
\:\\{out2}, \[125], 130, 210, 211, 212, 213, 219, 221, 226, 237, 241, 252, 253,
254, 256.
\:\\{out3}, \[125], 210, 223, 224, 237, 238.
\:\\{out4}, \[125], 226, 239, 241.
\:\\{out5}, \[125], 210.
\:\\{overflow}, \[35], 50, 62, 67, 110, 136, 175, 180, 187, 199, 204, 216, 217,
249.
\:\|{p}, \[44], \[50], \[51], \[58], \[66], \[69], \[111], \[119], \[131], %
\[146], \[183], \[192], \[197], \[198], \[204], \[226].
\:\\{param}, \[86].
\:\.{Pascal text...didn't end}, 216.
\:\\{Pascal\_parse}, \[183], 186, 192, 196, 197, 198.
\:\\{Pascal\_translate}, \[197], 198, 207.
\:\\{Pascal\_xref}, \[111], 112, 113, 183, 198.
\:\\{per\_cent}, \[122].
\:\\{Phase\_I}, \[261].
\:\\{Phase\_II}, \[261].
\:\\{phase\_one}, \[29], 31, 109.
\:\\{phase\_three}, \[29], 109, 213, 239.
\:\\{pop\_level}, \[205], 206.
\:\\{pp}, \[144], 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 173, 175, 176, 178, 179.
\:\\{prefix}, \[66], 68.
\:\\{prefix\_lookup}, \[69], 101.
\:\\{prime\_the\_change\_buffer}, \[75], 81, 84.
\:\\{print}, \[20], 31, 32, 33, 44, 105, 110, 119, 128, 140, 146, 147, 178,
181, 182, 215, 216, 221, 239, 260, 262.
\:\\{print\_cat}, \[140], 178, 181, 260.
\:\\{print\_id}, \[44], 119, 146, 215, 216, 260.
\:\\{print\_ln}, \[20], 32, 128, 181, 261.
\:\\{print\_nl}, \[20], 28, 105, 119, 128, 178, 181, 182, 215, 216, 218, 239,
260, 262, 263.
\:\\{print\_text}, \[146], 260.
\:\\{proc}, \[140], 142, \[143], 149, 162, 163, 164, 193.
\:\\{proc\_like}, \[42], 64, 111, 193.
\:\\{prod}, 148, \[178], 183.
\:\\{production}, \[148].
\:\\{production\_end}, \[148].
\:{productions, table of}, 143.
\:\\{pseudo\_semi}, \[86], 87, 186, 222.
\:\\{push\_level}, \[204], 206, 208.
\:\|{q}, \[50], \[51], \[66], \[69], \[198], \[236].
\:\|{r}, \[51], \[69], \[146].
\:\\{rbrace}, \[146].
\:\\{read}, 260.
\:\\{read\_ln}, 28.
\:\\{record\_head}, \[140], 142, 143, 149, 193.
\:\\{record\_like}, \[42], 64, 193.
\:{recursion}, 119, 207, 256.
\:\\{red}, 148, \[172], 174.
\:\\{reduce}, \[148], 151, 152, 153, 155, 156, 158, 159, 160, 161, 162, 163,
164, 165, 167, 168, 170, 172, 178.
\:\\{repeat\_like}, \[42], 64, 193.
\:\\{res\_flag}, \[146], 192, 193, 206.
\:\\{res\_word}, \[206], 208, 209.
\:\\{reserved}, \[42], 50, 60.
\:\\{reset}, 24, 259.
\:\\{reset\_input}, \[81], 109, 218.
\:\\{restart}, \[5], 82, 95, 100, 206.
\:\\{reswitch}, \[5], 183, 185, 191, 208, 212.
\:\&{return}, 5, \[6].
\:\\{rewrite}, 21, 26.
\:\\{rhs}, \[114], 116.
\:\\{rlink}, \[43], 66, 67, 69, 119, 256.
\:\\{roman}, \[42], 111, 253.
\:\\{root}, \[43], 66, 69, 120, 257.
\:\\{save\_base}, \[197].
\:\\{save\_limit}, \[208], 214.
\:\\{save\_line}, \[219].
\:\\{save\_loc}, \[208], 214.
\:\\{save\_mode}, \[208], 212.
\:\\{save\_next\_control}, \[207].
\:\\{save\_place}, \[219].
\:\\{save\_position}, \[219], 220, 225.
\:\\{save\_text\_ptr}, \[207].
\:\\{save\_tok\_ptr}, \[207].
\:\\{scanning\_hex}, \[93], 94, 95, 96, 100.
\:\\{scrap\_base}, \[144], 145, 173, 178, 179, 180, 181, 194, 195, 197.
\:\\{scrap\_ptr}, \[144], 145, 176, 178, 179, 183, 184, 187, 194, 195, 197,
199, 226, 228, 244, 256.
\:\\{sc0}, \[184], 186, 193, 194, 195, 228.
\:\\{sc1}, \[184], 186, 189, 190, 192, 193, 196, 227, 228, 231, 232.
\:\\{sc2}, \[184], 186, 188, 192, 193, 227, 228, 231.
\:\\{sc3}, \[184], 186, 192, 193, 231.
\:\\{sc4}, \[184], 186, 193.
\:\.{Section name didn't end}, 104.
\:\.{Section name too long}, 105.
\:\\{semi}, 139, \[140], 142, 143, 149, 161, 163, 186, 194, 195, 228, 231.
\:\\{set\_element\_sign}, \[15], 64, 186.
\:\\{sid1}, \[63].
\:\\{sid2}, \[63].
\:\\{sid3}, \[63].
\:\\{sid4}, \[63].
\:\\{sid5}, \[63].
\:\\{sid6}, \[63].
\:\\{sid7}, \[63].
\:\\{sid8}, \[63].
\:\\{sid9}, \[63].
\:\\{simp}, \[140], 142, 143, 148, 150, 151, 158, 160, 161, 162, 167, 170, 186,
189, 190, 192, 196.
\:\\{sixteen\_bits}, \[36], 37, 48, 50, 53, 55, 66, 69, 172, 174, 201, 206,
207, 219, 236, 242, 244.
\:\\{skip\_comment}, \[91], 112, 132, 136.
\:\\{skip\_limbo}, \[89], 109, 132.
\:\\{skip\_TeX}, \[90], 113, 132.
\:\.{Sorry, x capacity exceeded}, 35.
\:\\{sort\_ptr}, \[244], 249, 250, 251, 252.
\:{special string characters}, 189.
\:{split procedures}, 149, 183, 261.
\:\\{spotless}, \[9], 10, 263.
\:\\{sq}, 148, \[174].
\:\\{squash}, \[148], 151, 152, 154, 157, 160, 161, 162, 163, 166, 167, 169,
170, 174, 178.
\:\\{stack}, 201, \[202], 204, 205.
\:\\{stack\_ptr}, 201, \[202], 204, 205.
\:\\{stack\_size}, \[8], 202, 204.
\:\&{stat}, \[3].
\:\\{stmt}, \[140], 143, 149, 152, 153, 155, 156, 159, 160, 161, 162, 164, 167,
168, 169, 170.
\:\\{string}, \[93], 99, 185.
\:\.{String constant didn't end}, 99.
\:\\{string\_delimiter}, \[208], 216.
\:\\{sub\_cases}, 183, 191, \[192].
\:{system dependencies}, \[1], 2, 4, 7, 12, 17, 20, 21, 22, 24, 26, 28, 32, 33,
259, 260, 261, 263, 264.
\:\\{s0}, \[184].
\:\\{s1}, \[184].
\:\\{s2}, \[184].
\:\\{s3}, \[184].
\:\\{s4}, \[184].
\:\|{t}, \[58].
\:\\{tab\_mark}, \[15], 32, 79, 87, 89, 92, 95, 103, 104, 123, 133, 135.
\:\&{tats}, \[3].
\:\\{temp\_line}, \[71], 72.
\:\\{term\_in}, \[258], 259, 260.
\:\\{term\_out}, \[20], 21, 22.
\:\\{terminator}, 139, \[140], 142, 143, 149, 152, 153, 160, 161, 164, 166,
167, 179, 194, 195.
\:\.{TeX string should be...}, 222.
\:\\{tex\_file}, \[2], \[25], 26, 122, 124.
\:\\{TeX\_string}, \[86], 87, 93, 100, 185, 222.
\:\\{text\_char}, \[12], 13, 20.
\:\\{text\_file}, \[12], 20, 23, 25, 28, 258.
\:\\{text\_pointer}, \[52], 53, 144, 146, 179, 197, 198, 204, 207, 226.
\:\\{text\_ptr}, \[53], 54, 146, 171, 172, 175, 179, 180, 184, 187, 195, 198,
199, 207, 208, 226, 256.
\:\\{thin\_space}, \[86], 87, 186, 222.
\:\.{This can't happen}, 34.
\:\\{this\_module}, \[229], 230, 231, 233, 235.
\:\\{this\_xref}, \[234], 235, 255.
\:\\{to\_like}, \[42], 64, 191, 192.
\:\\{tok\_field}, \[201], 202.
\:\\{tok\_flag}, \[146], 148, 195, 198, 206, 226.
\:\\{tok\_mem}, \[53], 136, \[146], 148, 201, 202, 206, 213.
\:\\{tok\_ptr}, \[53], 54, 136, 137, 148, 171, 175, 179, 180, 187, 189, 198,
199, 207, 226, 256.
\:\\{tok\_start}, 52, \[53], 54, 144, 146, 171, 204.
\:\\{tracing}, 88, \[177], 178, 181, 182, 259.
\:\\{trans}, \[144], 148, 172, 176, 179, 183, 184, 195, 197, 244.
\:\\{translate}, 149, \[179], 180, 197, 226.
\:\\{trouble\_shooting}, 95, 206, 252, \[258], 259.
\:\\{true}, 6, 28, 29, 71, 72, 74, 79, 81, 83, 84, 85, 93, 100, 109, 110, 122,
127, 128, 239, 258, 259.
\:\\{typewriter}, \[42], 111, 253.
\:\\{unbucket}, \[249], 250, 251.
\:\\{underline}, \[86], 87, 100, 113.
\:\.{Unknown control code}, 87.
\:\\{until\_like}, \[42], 64, 193.
\:\\{up\_to}, \[95].
\:\\{update\_terminal}, \[22], 31, 110, 221, 260.
\:\\{var\_head}, \[140], 142, 143, 148, 149, 162, 163, 170, 193.
\:\\{var\_like}, \[42], 64, 111, 193.
\:\\{verbatim}, \[86], 87, 100, 107, 185, 189.
\:\.{Verbatim string didn't end}, 107.
\:\|{w}, \[44], \[58], \[66], \[69], \[131], \[208].
\:\\{WEAVE}, \[2].
\:\.{WEB file ended...}, 79.
\:\\{web\_file}, \[2], \[23], 24, 32, 71, 73, 79, 83, 85.
\:\.{webmac}, 124.
\:\.{Where is the match...}, 76, 80, 84.
\:\\{wi}, \[40], 41.
\:\\{wildcard}, \[42], 111, 253.
\:\\{write}, 20, 122, 124.
\:\\{write\_ln}, 20, 122.
\:\\{ww}, 8, \[37], 38, 39, 40, 41, 44, 50, 58, 61, 62, 66, 67, 68, 69, 131,
208, 209, 214, 243, 244, 251, 262.
\:\\{xchr}, \[13], 14, 16, 17, 18, 32, 44, 105, 122, 128, 146, 147, 182, 260.
\:\&{xclause}, 6.
\:\\{xlink}, \[46], 50, 51, 119, 213, 235, 237, 254, 255.
\:\\{xlink\_field}, 46, \[48].
\:\\{xmem}, 46, \[48].
\:\\{xord}, \[13], 16, 18, 28.
\:\\{xref}, 36, \[37], 46, 49, 50, 51, 62, 67, 119, 213, 231, 235, 243, 255.
\:\\{xref\_number}, \[47], 48, 50, 51, 118, 234, 236.
\:\\{xref\_ptr}, 46, \[48], 49, 50, 51, 262.
\:\\{xref\_roman}, \[86], 87, 93, 100, 111, 113, 186, 222.
\:\\{xref\_switch}, 46, \[48], 49, 50, 93, 100, 101, 111, 113, 115.
\:\\{xref\_typewriter}, \[86], 87, 93, 111, 113, 186, 222.
\:\\{xref\_wildcard}, \[86], 87, 93, 111, 113, 186, 222.
\:\.{You can't do that...}, 222, 232.
\:\.{You need an = sign...}, 231.
\fin
\:\X189:Append a \(string scrap\X
\U185.
\:\X190:Append a \TeX\ string scrap\X
\U185.
\:\X191:Append an identifier scrap\X
\U185.
\:\X185:Append the scrap appropriate to \\{next\_control}\X
\U183.
\:\X194:Append \\{terminator} if not already present\X
\Us193, 193\ETs193.
\:\X151:Cases for \\{alpha}\X
\U150.
\:\X152:Cases for \\{beginning}\X
\U150.
\:\X153:Cases for \\{case\_head}\X
\U149.
\:\X154:Cases for \\{casey}\X
\U149.
\:\X155:Cases for \\{clause}\X
\U149.
\:\X156:Cases for \\{cond}\X
\U149.
\:\X157:Cases for \\{elsie}\X
\U149.
\:\X158:Cases for \\{exp}\X
\U149.
\:\X159:Cases for \\{intro}\X
\U150.
\:\X160:Cases for \\{math}\X
\U150.
\:\X161:Cases for \\{mod\_scrap}\X
\U149.
\:\X163:Cases for $\\{open}\,\\{math}$\X
\U162.
\:\X162:Cases for \\{open}\X
\U150.
\:\X164:Cases for \\{proc}\X
\U149.
\:\X165:Cases for \\{record\_head}\X
\U149.
\:\X166:Cases for \\{semi}\X
\U149.
\:\X167:Cases for \\{simp}\X
\U150.
\:\X168:Cases for \\{stmt}\X
\U149.
\:\X169:Cases for \\{terminator}\X
\U149.
\:\X170:Cases for \\{var\_head}\X
\U149.
\:\X188:Cases involving nonstandard ASCII characters\X
\U186.
\:\X193:Cases that generate more than one scrap\X
\U191.
\:\X173:Change \\{pp} to $\max(\\{scrap\_base},$\\{pp}+\|d$)$\X
\Us172\ET174.
\:\X105:Check for overlong name\X
\U103.
\:\X85:Check that all changes have been read\X
\U261.
\:\X231:Check that $=$ or $\S$ follows this module name, and emit the scraps to
start the module definition\X
\U230.
\:\X138:Clear \\{bal} and \&{goto} \\{done}\X
\Us136\ET137.
\:\X180:Combine the irreducible scraps that remain\X
\U179.
\:\X61:Compare name \|p with current identifier, \&{goto} \\{found} if equal\X
\U60.
\:\X4:Compiler directives\X
\U2.
\:\X97:Compress two-symbol combinations like `\.{:=}'\X
\U95.
\:\X59:Compute the hash code \|h\X
\U58.
\:\X60:Compute the name location \|p\X
\U58.
\:\X8:Constants in the outer block\X
\U2.
\:\X217:Copy a control code into the buffer\X
\U216.
\:\X137:Copy special things when $\|c=\.{"@"},\.{"\\"},\.{"\{"},\.{"\}"}$; %
\&{goto} \\{done} at end\X
\U136.
\:\X216:Copy the \PASCAL\ text into $\\{buffer}[(\\{limit}+1)\to\|j]$\X
\U214.
\:\X135:Copy up to `\v' or control code, \&{goto} \\{done} if finished\X
\U134.
\:\X133:Copy up to control code, \&{return} if finished\X
\U132.
\:\X150:Declaration of subprocedures for \\{translate}\X
\U179.
\:\X195:Declaration of the \\{app\_comment} procedure\X
\U183.
\:\X196:Declaration of the \\{app\_octal} and \\{app\_hex} procedures\X
\U183.
\:\X186:Declaration of the \\{easy\_cases} procedure\X
\U183.
\:\X192:Declaration of the \\{sub\_cases} procedure\X
\U183.
\:\X92:Do special things when $\|c=\.{"@"},\.{"\\"},\.{"\{"},\.{"\}"}$; %
\&{goto} \\{done} at end\X
\U91.
\:\X243:Do the first pass of sorting\X
\U239.
\:\X232:Emit the scrap for a module name if present\X
\U230.
\:\X67:Enter a new module name into the tree\X
\U66.
\:\X62:Enter a new name into the table at position \|p\X
\U58.
\:\X30, 31, 33:Error handling procedures\X
\U2.
\:\X99:Get a string\X
\U95.
\:\X98:Get an identifier\X
\U95.
\:\X100:Get control code and possible module name\X
\U95.
\:\X9, 13, 20, 23, 25, 27, 29, 37, 39, 45, 48, 53, 55, 63, 65, 71, 73, 93, 108,
114, 118, 121, 129, 144, 177, 202, 219, 229, 234, 240, 242, 244, 246,
258:Globals in the outer block\X
\U2.
\:\X96:Go to \\{found} if \|c is a hexadecimal digit, otherwise set $%
\\{scanning\_hex}\K\\{false}$\X
\U95.
\:\X104:If end of name, \&{goto} \\{done}\X
\U103.
\:\X181:If semi-tracing, show the irreducible scraps\X
\U180.
\:\X80:If the current line starts with \.{@y}, report any discrepancies and %
\&{return}\X
\U79.
\:\X182:If tracing, print an indication of where we are\X
\U179.
\:\X255:Invert the cross-reference list at \\{cur\_name}, making \\{cur\_xref}
the head\X
\U254.
\:\X16, 40, 56, 247:Local variables for initialization\X
\U2.
\:\X212:Look ahead for strongest line break, \&{goto} \\{reswitch}\X
\U211.
\:\X187:Make sure that there is room for at least four more scraps, six more
tokens, and four more texts\X
\U185.
\:\X199:Make sure that there is room for at least seven more tokens, three more
texts, and one more scrap\X
\U198.
\:\X176:Make sure the entries $\\{cat}[\\{pp}\to(\\{pp}+3)]$ are defined\X
\U175.
\:\X149:Match a production at \\{pp}, or increase \\{pp} if there is no match\X
\U175.
\:\X78:Move \\{buffer} and \\{limit} to \\{change\_buffer} and \\{change%
\_limit}\X
\Us75\ET79.
\:\X211:Output a \(control, look ahead in case of line breaks, possibly %
\&{goto} \\{reswitch}\X
\U208.
\:\X210:Output a \.{\\math} operator\X
\U208.
\:\X213:Output a module name\X
\U208.
\:\X257:Output all the module names\X
\U239.
\:\X237:Output all the module numbers on the reference list \\{cur\_xref}\X
\U236.
\:\X209:Output an identifier\X
\U208.
\:\X252:Output index entries for the list at \\{sort\_ptr}\X
\U250.
\:\X221:Output the code for the beginning of a new module\X
\U220.
\:\X238:Output the code for the end of a module\X
\U220.
\:\X254:Output the cross-references at \\{cur\_name}\X
\U252.
\:\X253:Output the name at \\{cur\_name}\X
\U252.
\:\X214:Output the text of the module name\X
\U213.
\:\X109:Phase I: Read all the user's text and store the cross references\X
\U261.
\:\X218:Phase II: Read all the text again and translate it to \TeX\ form\X
\U261.
\:\X239:Phase III: Output the cross-reference index\X
\U261.
\:\X32:Print error location based on input buffer\X
\U31.
\:\X120:Print error messages about unused or undefined module names\X
\U109.
\:\X262:Print statistics about memory usage\X
\U261.
\:\X263:Print the job \\{history}\X
\U261.
\:\X147:Print token \|r in symbolic form\X
\U146.
\:\X128:Print warning message, break the line, \&{return}\X
\U127.
\:\X116:Process a format definition\X
\U115.
\:\X103:Put module name into $\\{mod\_text}[1\to\|k]$\X
\U101.
\:\X84:Read from \\{change\_file} and maybe turn off \\{changing}\X
\U82.
\:\X83:Read from \\{web\_file} and maybe turn on \\{changing}\X
\U82.
\:\X235:Rearrange the list pointed to by \\{cur\_xref}\X
\U233.
\:\X175:Reduce the scraps using the productions until no more rules apply\X
\U179.
\:\X107:Scan a verbatim string\X
\U100.
\:\X101:Scan the module name and make \\{cur\_module} point to it\X
\U100.
\:\X106:Scan to the next \.{@>}\X
\U100.
\:\X10, 14, 17, 18, 21, 26, 41, 43, 49, 54, 57, 94, 102, 124, 126, 145, 203,
245, 248, 259:Set initial values\X
\U2.
\:\X68:Set variable \|c to the result of comparing the given name to name \|p\X
\Us66\ET69.
\:\X233:Show cross references to this module\X
\U220.
\:\X215:Skip next character, give error if not `\.{@}'\X
\U214.
\:\X76:Skip over comment lines in the change file; \&{return} if end of file\X
\U75.
\:\X77:Skip to the next nonblank line; \&{return} if end of file\X
\U75.
\:\X250:Sort and output the index\X
\U239.
\:\X88:Special control codes allowed only when debugging\X
\U87.
\:\X251:Split the list at \\{sort\_ptr} into further lists\X
\U250.
\:\X228:Start a format definition\X
\U225.
\:\X227:Start a macro definition\X
\U225.
\:\X64:Store all the reserved words\X
\U261.
\:\X110:Store cross reference data for the current module\X
\U109.
\:\X115:Store cross references in the \(definition part of a module\X
\U110.
\:\X117:Store cross references in the \PASCAL\ part of a module\X
\U110.
\:\X113:Store cross references in the \TeX\ part of a module\X
\U110.
\:\X241:Tell about changed modules\X
\U239.
\:\X224:Translate a hexadecimal constant appearing in \TeX\ text\X
\U222.
\:\X223:Translate an octal constant appearing in \TeX\ text\X
\U222.
\:\X220:Translate the \(current module\X
\U218.
\:\X225:Translate the \(definition part of the current module\X
\U220.
\:\X230:Translate the \PASCAL\ part of the current module\X
\U220.
\:\X222:Translate the \TeX\ part of the current module\X
\U220.
\:\X11, 12, 36, 38, 47, 52, 201:Types in the outer block\X
\U2.
\con
